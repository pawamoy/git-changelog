{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"git-changelog","text":"<p>Automatic Changelog generator using Jinja2 templates. From git logs to change logs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Jinja2 templates!   You get full control over the rendering.   Built-in Keep a Changelog and Angular templates   (also see Conventional Changelog).</li> <li>Commit styles/conventions parsing.   Built-in Angular, Conventional Commit and basic conventions.</li> <li>Git service/provider agnostic,   plus references parsing (issues, commits, etc.).   Built-in GitHub, Gitlab and Bitbucket support.</li> <li>Understands Semantic Versioning:   major/minor/patch for versions and commits.   Guesses next version based on last commits.</li> <li> <p>Parses Git trailers, allowing to reference   issues, PRs, etc., in your commit messages   in a clean, provider-agnostic way.</p> </li> <li> <p>Todo:</p> <ul> <li>Plugin architecture,   to support more commit conventions and git services.</li> <li>Template context injection,   to furthermore customize how your changelog will be rendered.</li> <li>Easy access to \"Breaking Changes\" in the templates.</li> <li>Commits/dates/versions range limitation ability.</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>:</p> <pre><code>pip install git-changelog\n</code></pre> <p>With <code>pipx</code>:</p> <pre><code>python3.8 -m pip install --user pipx\npipx install git-changelog\n</code></pre>"},{"location":"#usage-command-line","title":"Usage (command-line)","text":"<pre><code>usage: git-changelog [-b] [-h] [-i] [-g VERSION_REGEX] [-m MARKER_LINE]\n                     [-o OUTPUT] [-r] [-R] [-I INPUT]\n                     [-c {angular,conventional,basic}] [-s SECTIONS]\n                     [-t {angular,keepachangelog}] [-T] [-E] [-v]\n                     [REPOSITORY]\n\nAutomatic Changelog generator using Jinja2 templates.\n\nThis tool parses your commit messages to extract useful data\nthat is then rendered using Jinja2 templates, for example to\na changelog file formatted in Markdown.\n\nEach Git tag will be treated as a version of your project.\nEach version contains a set of commits, and will be an entry\nin your changelog. Commits in each version will be grouped\nby sections, depending on the commit convention you follow.\n\nBASIC CONVENTION\n\nDefault sections:\n- add: Added\n- fix: Fixed\n- change: Changed\n- remove: Removed\n\nAdditional sections:\n- merge: Merged\n- doc: Documented\n\nANGULAR CONVENTION\n\nDefault sections:\n- feat: Features\n- fix: Bug Fixes\n- revert: Reverts\n- ref, refactor: Code Refactoring\n- perf: Performance Improvements\n\nAdditional sections:\n- build: Build\n- chore: Chore\n- ci: Continuous Integration\n- deps: Dependencies\n- doc, docs: Docs\n- style: Style\n- test, tests: Tests\n\nCONVENTIONALCOMMIT CONVENTION\n\nDefault sections:\n- feat: Features\n- fix: Bug Fixes\n- revert: Reverts\n- ref, refactor: Code Refactoring\n- perf: Performance Improvements\n\nAdditional sections:\n- build: Build\n- chore: Chore\n- ci: Continuous Integration\n- deps: Dependencies\n- doc, docs: Docs\n- style: Style\n- test, tests: Tests\n\npositional arguments:\n  REPOSITORY            The repository path, relative or absolute. Default: .\n\noptions:\n  -b, --bump-latest     Deprecated, use --bump=auto instead.\n                        Guess the new latest version by bumping the previous\n                        one based on the set of unreleased commits. For\n                        example, if a commit contains breaking changes, bump\n                        the major number (or the minor number for 0.x\n                        versions). Else if there are new features, bump the\n                        minor number. Else just bump the patch number.\n                        Default: False.\n  --bump VERSION        Specify the bump from latest version for the set\n                        of unreleased commits. Can be one of 'auto',\n                        'major', 'minor', 'patch' or a valid semver version\n                        (eg. 1.2.3). With 'auto', if a commit contains breaking\n                        changes, bump the major number (or the minor number\n                        for 0.x versions), else if there are new features,\n                        bump the minor number, else just bump the patch number.\n                        Default: None.\n  -h, --help            Show this help message and exit.\n  -i, --in-place        Insert new entries (versions missing from changelog)\n                        in-place. An output file must be specified. With\n                        custom templates, you can pass two additional\n                        arguments: --version-regex and --marker-line. When\n                        writing in-place, an 'in_place' variable will be\n                        injected in the Jinja context, allowing to adapt the\n                        generated contents (for example to skip changelog\n                        headers or footers). Default: False.\n  -g, --version-regex VERSION_REGEX\n                        A regular expression to match versions in the existing\n                        changelog (used to find the latest release) when\n                        writing in-place. The regular expression must be a\n                        Python regex with a 'version' named group. Default:\n                        ^## \\[(?P&lt;version&gt;v?[^\\]]+).\n  -m, --marker-line MARKER_LINE\n                        A marker line at which to insert new entries (versions\n                        missing from changelog). If two marker lines are\n                        present in the changelog, the contents between those\n                        two lines will be overwritten (useful to update an\n                        'Unreleased' entry for example). Default:\n                        &lt;!-- insertion marker --&gt;.\n  -o, --output OUTPUT   Output to given file. Default: stdout.\n  -p {github,gitlab}, --provider {github,gitlab}\n                        Explicitly specify the repository provider.\n  -r, --parse-refs      Parse provider-specific references in commit messages\n                        (GitHub/GitLab/Bitbucket issues, PRs, etc.). Default: False.\n  -R, --release-notes   Output release notes to stdout based on the last entry\n                        in the changelog. Default: False.\n  -I, --input INPUT     Read from given file when creating release notes.\n                        Default: CHANGELOG.md.\n  -c, --style, --commit-style, --convention {angular,conventional,basic}\n                        The commit convention to match against. Default:\n                        basic.\n  -s, --sections SECTIONS\n                        A comma-separated list of sections to render. See the\n                        available sections for each supported convention in\n                        the description. Default: None.\n  -t {angular,keepachangelog}, --template {angular,keepachangelog}\n                        The Jinja2 template to use. Prefix with \"path:\" to\n                        specify the path to a directory containing a file\n                        named \"changelog.md\". Default: keepachangelog.\n  -T, --trailers, --git-trailers\n                        Parse Git trailers in the commit message. See\n                        https://git-scm.com/docs/git-interpret-trailers.\n                        Default: False.\n  -E, --omit-empty-versions\n                        Omit empty versions in the output. Default: False.\n  -v, --version         Show the current version of the program and exit.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#232-2023-10-25","title":"2.3.2 - 2023-10-25","text":"<p>Compare with 2.3.1</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Use tomli instead of toml on Python less than 3.11 (37f7cf1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#231-2023-10-10","title":"2.3.1 - 2023-10-10","text":"<p>Compare with 2.3.0</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Remove any credentials from remote URLs, not just GitHub tokens (5d07e91 by Timoth\u00e9e Mazzucotelli). Issue #61</li> </ul>"},{"location":"changelog/#230-2023-10-08","title":"2.3.0 - 2023-10-08","text":"<p>Compare with 2.2.0</p>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>CLI argument <code>--bump-latest</code> and API parameter <code>bump_latest</code>     are deprecated in favor of <code>--bump=auto</code> and <code>bump=\"auto\"</code>     argument and parameter, respectively.     See \"Understand the relationship with SemVer\".</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add configuration files (b527ccf by Oscar Esteban). Issue #54, PR #55, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add bump option (CLI, library) allowing to specify an exact version to bump to, as well as <code>auto</code>, <code>major</code>, <code>minor</code> or <code>patch</code> (2c0dbb8 by Th\u00e9o Goudout). Issue #38, PR #41, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add provider CLI option (908531b by Th\u00e9o Goudout). Issue #37, PR #40, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#220-2023-08-17","title":"2.2.0 - 2023-08-17","text":"<p>Compare with 2.1.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add option to omit empty versions from output (b91f777 by Sven Axelsson). PR #52</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Remove broken Atom commit convention (2f33180 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#210-2023-08-04","title":"2.1.0 - 2023-08-04","text":"<p>Compare with 2.0.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Add Bitbucket provider (5d793e5 by Sven Axelsson).</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Stop using deprecated <code>datetime.utcfromtimestamp</code> (Python 3.12) (1f3ed5d by Sven Axelsson).</li> </ul>"},{"location":"changelog/#200-2023-07-03","title":"2.0.0 - 2023-07-03","text":"<p>Compare with 1.0.1</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Drop support for Python 3.7</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Add option to output release notes (483745a by Timoth\u00e9e Mazzucotelli). Issue #49</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Remove GitHub tokens from remote URL (187e26e by Timoth\u00e9e Mazzucotelli). Issue #50</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Show default for every CLI option (f015830 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove Python 3.7 related code (3295812 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#101-2023-05-10","title":"1.0.1 - 2023-05-10","text":"<p>Compare with 1.0.0</p>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Check if the latest version tag is already part of the changelog (1fad8a8 by Kevin Squire).</li> <li>Include <code>v</code> prefix in default version regular expression (a50d6a2 by Kevin Squire).</li> </ul>"},{"location":"changelog/#100-2023-02-04","title":"1.0.0 - 2023-02-04","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<p>This version brings a lot of new features, so I took this opportunity to break things, allowing to clean things up, and to bump to version 1.0.0.</p> <ul> <li>New version is not automatically guessed anymore (by bumping latest version).     Enable it again with the <code>--bump-latest</code> CLI option.</li> <li>Provider-specific references are not parsed by default anymore.     Parse them again with the <code>--parse-refs</code> CLI option.</li> <li>The commit convention cannot be passed with the <code>-s</code> CLI option anymore.     This option is now used for declaring sections. Use <code>-c</code> instead.     See usage.</li> <li>Rename Python objects by replacing occurrences of \"style\" by \"convention\" everywhere.</li> </ul>"},{"location":"changelog/#features_4","title":"Features","text":"<p>Lots of new features! Usage is documented here: https://pawamoy.github.io/git-changelog/usage/.</p> <ul> <li>Support updating changelog in-place (18029cd by Timoth\u00e9e Mazzucotelli). Issue #15</li> <li>Better handle single, initial versions (4c6ecf5 by Timoth\u00e9e Mazzucotelli).</li> <li>Use current directory by default (d50d0b1 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow choosing whether to guess new version by bumping latest (85c04fd by Timoth\u00e9e Mazzucotelli).</li> <li>Support Git trailers, render them in Keep A Changelog template (cdf17c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Disable parsing of provider-specific references by default, allow enabling it (cf41a97 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Clean up body to fix parsing trailers (1183c25 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix building commit body (f76bf32 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix spacing in keepachangelog templates (cf5117a by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash when trying to parse the latest tag as semver (e90aa2b by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: don't capitalize commit summary (87348ed by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: respect sections order (don't sort) (f645e62 by Timoth\u00e9e Mazzucotelli).</li> <li>Use <code>importlib.metadata</code> instead of <code>pkg_resources</code> to get current version (79109d0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Allow passing sections with <code>-s</code> CLI option (removed from commit convention option) (a1ae778 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename 'style' to 'convention' everywhere (c454481 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>inplace</code> variable to <code>in_place</code> (7a271ef by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI: all flags default to false (9616bdd by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI for better library usage (43ec5d1 by Timoth\u00e9e Mazzucotelli).</li> <li>Make changelog methods private (0b4bbc0 by Timoth\u00e9e Mazzucotelli).</li> <li>Expose <code>Changelog</code> and <code>Commit</code> from <code>git_changelog</code> (d3dca05 by Timoth\u00e9e Mazzucotelli).</li> <li>Detect more commit types (Karma/Angular), rework section titles (f751736 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing datetimes, UTC timestamps as strings, or nothing when creating commit (34460ab by Timoth\u00e9e Mazzucotelli).</li> <li>Build body before instantiating commit (37de53f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#060-2022-10-26","title":"0.6.0 - 2022-10-26","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add GIT_CHANGELOG_REMOTE variable (9b9b3fc by Luk\u00e1\u0161 Zapletal). PR #35</li> </ul>"},{"location":"changelog/#050-2021-11-14","title":"0.5.0 - 2021-11-14","text":"<p>Compare with 0.4.2</p>"},{"location":"changelog/#dependencies_1","title":"Dependencies","text":"<ul> <li>Accept Jinja2 3.x (9ef3259 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>Allow to choose conventional style from CLI (aafa779 by Ivan Gonzalez). PR #32</li> <li>Add ConventionalCommit commit type (3becce8 by Kevin Squire). PR #30</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Properly bump semver version (ecc7dd4 by Kevin Squire). References: #31</li> <li>Fix typo in keepachangelog template (fa9b434 by Alexander Schleifer). PR #28</li> </ul>"},{"location":"changelog/#code-refactoring_4","title":"Code Refactoring","text":"<ul> <li>Use semver to bump version more reliably (b68a565 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#042-2021-01-06","title":"0.4.2 - 2021-01-06","text":"<p>Compare with 0.4.1</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Handle prerelease tags better (4bcc451 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#041-2020-12-21","title":"0.4.1 - 2020-12-21","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Fix wrong version being printed (0ec050f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#040-2020-05-21","title":"0.4.0 - 2020-05-21","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Use actual url for references (46a8790 by Timoth\u00e9e Mazzucotelli).</li> <li>Use style subject if possible (7f2c3ad by Timoth\u00e9e Mazzucotelli).</li> <li>Correctly handle nested subgroups for gitlab repos (8ca990b by Timoth\u00e9e Mazzucotelli).</li> <li>Fix bumping versions starting with \"v\" (44e7644 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_5","title":"Code Refactoring","text":"<ul> <li>Move styles into new commit module to avoid cyclic dependencies (d90bd15 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Improve changelog rendering (e9dd3f4 by Timoth\u00e9e Mazzucotelli).<ul> <li>Use today's date for current version</li> <li>Move \"compare\" link below the heading (better table of contents in documentation)</li> <li>Improve \"compare\" links to handle first and current version</li> <li>Use selected commit types to render sections</li> </ul> </li> <li>Add default commit types to render variable (173392a by Timoth\u00e9e Mazzucotelli).</li> <li>Always use today's date for unreleased version (1c34fa8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#030-2020-03-31","title":"0.3.0 - 2020-03-31","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Fix <code>is_minor</code> method for version (6d08978 by Lo\u00efc Viennois).</li> <li>Fix <code>parse_refs</code> method for <code>ProviderRefParser</code> (dc51589 by Lo\u00efc Viennois).</li> <li>Correctly detect major version, for both angular style and basic style (7385e19 by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#code-refactoring_6","title":"Code Refactoring","text":"<ul> <li>Add type hints to all classes and methods (95276ef by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Update template <code>keepachangelog</code> (ce76ed6) by RainChen:<ul> <li>Capitalize commit subject</li> <li>Show author name for each commit</li> <li>Sort commits by date</li> <li>Unique commit subjects</li> </ul> </li> </ul>"},{"location":"changelog/#020-2019-11-24","title":"0.2.0 - 2019-11-24","text":"<p>Compare with 0.1.1</p> <p>Drop support for Python &lt; 3.6.</p> <p>Use poetry to manage the project!</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix detection of feature (is_minor) for angular style (4fbf0ee).</li> </ul>"},{"location":"changelog/#011-2018-06-27","title":"0.1.1 - 2018-06-27","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix build with MANIFEST.in, add license file (013fb69).</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Improve readability (5e590f6).</li> </ul>"},{"location":"changelog/#010-2018-06-27","title":"0.1.0 - 2018-06-27","text":"<p>Compare with first commit</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add github/github regexes (584fd73).</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix patch bump (8470e69).</li> <li>Fix refs parsing (8c77cb7).</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Continue packaging (#6) (a29af2c).</li> <li>Finish packaging (#6) (e92b492).</li> <li>Implement reference parsing (a9b4a89).</li> <li>Improve angular template, improve style/refs system (5b87d48).</li> <li>Initial commit (83845fe).</li> <li>Package code (#6) (1219eaf).</li> <li>Update changelog for version 0.1.0 (14edcaf).</li> <li>Update changelog for version 0.1.0 (610633d).</li> <li>Update changelog for version 0.1.0 (2eaaa2e).</li> <li>Work in progress (27a60e8).</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pawamoy@pm.me. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd git-changelog\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install pdm\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>pdm install</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>pdm run git-changelog [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you run the task directly with <code>pdm run duty TASK</code>.</p> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>These projects were used to build git-changelog. Thank you!</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>appdirs</code> A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=1.4</code> <code>1.4.4</code> MIT <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.10</code> <code>3.1.2</code> BSD-3-Clause <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.3</code> BSD-3-Clause <code>semver</code> Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.2</code> BSD <code>tomli</code> A lil' TOML parser <code>&gt;=2.0; python_version &lt; '3.11'</code> <code>2.0.1</code> ?"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>babel</code> Internationalization utilities <code>~=2.10</code> <code>2.13.0</code> BSD-3-Clause <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>black</code> The uncompromising code formatter. <code>&gt;=23.9</code> <code>23.10.1</code> MIT <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.3.1</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>[toml]&gt;=5.2.1</code> <code>7.3.2</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>dparse</code> A parser for Python dependency files <code>&gt;=0.6.2</code> <code>0.6.3</code> MIT license <code>duty</code> A simple task runner. <code>&gt;=0.10</code> <code>1.0.0</code> ISC <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.3</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>failprint</code> Run a command, print its output only if it fails. <code>&gt;=0.11</code> <code>1.0.2</code> ISC <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.11</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.40</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.35</code> <code>0.36.7</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.3; python_version &lt; \"3.10\"</code> <code>6.8.0</code> ? <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.9</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.5</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.3</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=1.7</code> <code>1.7.0.1.0.1</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.3</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.5</code> <code>1.5.3</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=1.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.5</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of github committers and other useful GIT info such as last modified date <code>&gt;=1.2</code> <code>1.2.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.6</code> <code>0.6.1</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=9.4</code> <code>9.4.6+insiders.4.42.2</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.2</code> <code>1.3</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.7</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.23</code> <code>0.23.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.7.3.1.5.1</code> ISC <code>mypy</code> Optional static typing for Python <code>&gt;=1.5</code> <code>1.6.1</code> MIT License <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.0.0</code> MIT License <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>23.2</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2</code> <code>3.11.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ISC License (ISCL) <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.3.1</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;=7.4</code> <code>7.4.2</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;=4.1</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.15</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=3.3</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pytz</code> World timezone definitions, modern and historical <code>&gt;=2015.7; python_version &lt; \"3.9\"</code> <code>2023.3.post1</code> ? <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2023.10.3</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruamel-yaml</code> ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order <code>&gt;=0.17.21</code> <code>0.18.0</code> MIT license <code>ruamel-yaml-clib</code> C version of reader, parser and emitter for ruamel.yaml derived from libyaml <code>&gt;=0.2.7; platform_python_implementation == \"CPython\" and python_version &lt; \"3.13\"</code> <code>0.2.8</code> MIT <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;=0.0</code> <code>0.1.1</code> MIT <code>safety</code> Checks installed dependencies for known vulnerabilities and licenses. <code>&gt;=2.3</code> <code>2.3.4</code> MIT license <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>&gt;=19.3</code> <code>68.2.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.1</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.5</code> MIT License <code>tomli</code> A lil' TOML parser <code>&gt;=2.0; python_version &lt; '3.11'</code> <code>2.0.1</code> ? <code>tomli-w</code> A lil' TOML writer <code>&gt;=1.0</code> <code>1.0.0</code> MIT License <code>types-markdown</code> Typing stubs for Markdown <code>&gt;=3.5</code> <code>3.5.0.0</code> Apache-2.0 license <code>types-pyyaml</code> Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.12</code> Apache-2.0 license <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.8+ <code>&gt;=4.0.1; python_version &lt; \"3.11\"</code> <code>4.8.0</code> Python Software Foundation License <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.7</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0 <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.17.0</code> ? <p>More credits from the author</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2018, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>git-changelog parses your commit messages to extract useful data that is then rendered using Jinja2 templates, for example to a changelog file formatted in Markdown.</p> <p>Each Git tag will be treated as a version of your project. Each version contains a set of commits, and will be an entry in your changelog. Commits in each version will be grouped by sections, depending on the commit coonvention you follow.</p>"},{"location":"usage/#quick-usage","title":"Quick usage","text":"<p>Print the changelog on standard output, using the basic convention for commit messages and the Angular template:</p> <pre><code>git-changelog -c basic -t angular\n</code></pre> <p>Update a changelog in-place, overwriting and updating the \"Unreleased\" section, using the Angular commit message convention and the Keep A Changelog template (default):</p> <pre><code>git-changelog -io CHANGELOG.md -c angular\n</code></pre> <p>Same thing, but now you're ready to tag so you tell git-changelog to guess the new version by bumping the latest version based on the semantics of your commits:</p> <pre><code>git-changelog -bio CHANGELOG.md -c angular\n</code></pre> <p>Same thing, but also parse Git trailers and choose the sections to render, and their order (author's favorite!):</p> <pre><code>git-changelog -Tbio CHANGELOG.md -c angular -s build,deps,fix,feat,refactor\n</code></pre> <p>Generate a changelog using a custom template, and parsing provider-specific references (GitHub/GitLab/Bitbucket):</p> <pre><code>git-changelog -rt path:./templates/changelog.md.jinja\n</code></pre> <p>Generate a changelog using a specific provider (GitHub/GitLab/BitBucket):</p> <pre><code>git-changelog --provider github\n</code></pre> <p>Author's favorite, from Python:</p> <pre><code>from git_changelog.cli import build_and_render\n\nbuild_and_render(\n    repository=\".\",\n    output=\"CHANGELOG.md\",\n    convention=\"angular\",\n    provider=\"github\",\n    template=\"keepachangelog\",\n    parse_trailers=True,\n    parse_refs=False,\n    sections=(\"build\", \"deps\", \"feat\", \"fix\", \"refactor\"),\n    bump=\"auto\",\n    in_place=True,\n)\n</code></pre> <p>The following sections explain in more details all the features of git-changelog.</p>"},{"location":"usage/#output-a-changelog","title":"Output a changelog","text":"<p>To output a changelog for the current repository (current directory), simply run:</p> <pre><code>git-changelog\n</code></pre> <p>To output a changelog for another repository (directory), pass the path to that repository:</p> <pre><code>git-changelog /path/to/my/repo\n</code></pre> <p>By default, git-changelog will parse commit messages as if they use the \"basic\" convention, and render a Keep A Changelog-formatted changelog writing to the standard output.</p> <p>To write to a file instead, use the <code>-o</code> or <code>--output</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md\n</code></pre>"},{"location":"usage/#choose-the-commit-message-convention","title":"Choose the commit message convention","text":"<p>Different conventions, or styles, are supported by git-changelog. To select a different convention than the default one (basic, see below), use the <code>-c</code> or <code>--convention</code> CLI option:</p> <pre><code>git-changelog --convention angular\n</code></pre>"},{"location":"usage/#basic-convention","title":"Basic convention","text":"<p>The basic convention, as the name implies, is very simple. If a commit message summary (the first line of the message) with a particular word/prefix (case-insensitive), it is added to the corresponding section:</p> Type Section <code>add</code> Added <code>fix</code> Fixed <code>change</code> Changed <code>remove</code> Removed <code>merge</code> Merged <code>doc</code> Documented"},{"location":"usage/#angularkarma-convention","title":"Angular/Karma convention","text":"<p>The Angular/Karma convention initiated the Conventional Commit specification. It expects the following format for commit messages:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>The types and corresponding sections git-changelog recognizes are:</p> Type Section <code>build</code> Build <code>chore</code> Chore <code>ci</code> Continuous Integration <code>deps</code> Dependencies <code>doc(s)</code> Docs <code>feat</code> Features <code>fix</code> Bug Fixes <code>perf</code> Performance Improvements <code>ref(actor)</code> Code Refactoring <code>revert</code> Reverts <code>style</code> Style <code>test(s)</code> Tests <p>Breaking changes are detected by searching for <code>^break(s|ing changes?)?[ :]</code> in the commit message body.</p>"},{"location":"usage/#conventional-commit-convention","title":"Conventional Commit convention","text":"<p>The Conventional Commit specification originates from the Angular commit message convention. It's basically the same thing, but only the <code>feat</code> and <code>fix</code> types are specified, and the rest is up to you. In git-changelog though, it is equivalent to the Angular convention, with an additional thing: it detects breaking changes when <code>!</code> appears right before the colon in the message summary (for example: <code>refactor!: Stuff</code>).</p>"},{"location":"usage/#choose-the-sections-to-render","title":"Choose the sections to render","text":"<p>Each commit message convention has a default set of sections that will be rendered in the output. The other sections will be ignored. To override this, you can provide a list of sections to render to git-changelog with the <code>-s</code> or <code>--sections</code> CLI option:</p> <pre><code># with the basic convention\ngit-changelog --sections add,fix,remove,doc\n\n# with the angular/karma/conventionalcommit convention\ngit-changelog --sections build,deps,feat,fix,refactor\n</code></pre> <p>See the previous paragraphs to get the list of available sections for each commit message convetions.</p>"},{"location":"usage/#choose-a-changelog-template","title":"Choose a changelog template","text":"<p>git-changelog provides two built-in templates: <code>keepachangelog</code> and <code>angular</code>. Both are very similar, they just differ with the formatting a bit. We stronly recommend the <code>keepachangelog</code> format.</p> <p>You can also write and use your own changelog templates. Templates are single files written using the Jinja templating engine. You can get inspiration from the source of our built-in templates.</p>"},{"location":"usage/#understand-the-relationship-with-semver","title":"Understand the relationship with SemVer","text":"<p>Semver, or Semantic Versioning, helps users of tools and libraries understand the impact of version changes. To quote SemVer itself:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards compatible manner</li> <li>PATCH version when you make backwards compatible bug fixes</li> </ol> <p>Thanks to the SemVer specification and the commit message conventions, git-changelog is able to guess the new version your project is supposed to take given a set of untagged commits (commits more recent than the latest tag). An \"Added\" (basic convention) or \"feat\" (Angular/Karma/ConventionalCommit) commit will bump the MINOR part of the latest tag. Other types will bump the PATCH part. Commits containing breaking changes will bump the MAJOR part, unless MAJOR is 0, in which case they'll only bump the MINOR part.</p> <p>To tell git-changelog to try and guess the new version, use the <code>--bump=auto</code> CLI option:</p> <pre><code>git-changelog --bump auto\n</code></pre> <p>You can also specify a version to bump to directly:</p> <pre><code>git-changelog --bump 2.3.1\n</code></pre> <p>Or which part of the version to bump, resetting numbers on its right to 0:</p> <pre><code>git-changelog --bump major  # 1.2.3 -&gt; 2.0.0\ngit-changelog --bump minor  # 1.2.3 -&gt; 1.3.0\ngit-changelog --bump patch  # 1.2.3 -&gt; 1.2.4\n</code></pre> <p>Note that the major number won't be bumped if the latest version is 0.x. Instead, the minor number will be bumped:</p> <pre><code>git-changelog --bump major  # 0.1.2 -&gt; 0.2.0, same as minor because 0.x\ngit-changelog --bump minor  # 0.1.2 -&gt; 0.2.0\n</code></pre> <p>In that case, when you are ready to bump to 1.0.0, just pass this version as value:</p> <pre><code>git-changelog --bump 1.0.0\n</code></pre>"},{"location":"usage/#parse-additional-information-in-commit-messages","title":"Parse additional information in commit messages","text":"<p>git-changelog is able to parse the body of commit messages to find additional information.</p>"},{"location":"usage/#provider-specific-references","title":"Provider-specific references","text":"<p>git-changelog will detect when you are using GitHub, GitLab or Bitbucket by checking the <code>origin</code> remote configured in your local clone (or the remote indicated by the value of the <code>GIT_CHANGELOG_REMOTE</code> environment variable).</p> <p>Detecting the provider allows git-changelog to build URLs to specific commits and tags. But it also allows it to parse text references understood by these providers in the commit messages. For example: #18 (issue) or a78bcf2e (commit hash). These references are then available when rendering the changelog template, allowing to add links to issues, pull requests, users, etc.</p> <p>Example of a commit message with GitLab references:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14.\nFollow-up of MR !7.\nPart of milestone %2.\n</code></pre> <p>To enable provider-specific reference parsing, use the <code>-r</code> or <code>--parse-refs</code> CLI option:</p> <pre><code>git-changelog --parse-refs\n</code></pre> <p>Provider-references are a bit limited, difficult to parse and favor vendor lock-in, so for these reasons we do not recommend them. Instead, we recommend using Git trailers.</p>"},{"location":"usage/#git-trailers","title":"Git trailers","text":"<p>Git has an <code>interpret-trailers</code> command that allows to add or parse trailers line to commit messages. Trailers line are located in the footer of commit message: there must be a blank line between the body and the first trailer. Each trailer is a line of the form <code>token: value</code>, for example <code>Co-authored-by: Timoth\u00e9e Mazzucotelli &lt;pawamoy@pm.me&gt;</code>.</p> <p>The tokens are specified not to allow whitespace in them, but git-changelog takes the liberty to lift up this limitation for convenience. It means you can write <code>Issue 18: https://...</code> instead of <code>Issue-18: https://...</code>. The first colon + space (<code>:</code>) delimitate the token and value.</p> <p>Example of a commit message with Git trailers:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14: https://github.com/super/repo/issues/14\nFollow-up of PR #7: https://github.com/super/repo/pull/7\nPart of epic #5: https://agile-software.com/super/project/epics/5\n</code></pre> <p>As you can see, compared to provider-specific references, trailers are written out explicitly, so it's a bit more work, but this ensures your changelog can be rendered correctly anywhere, not just on GitHub, GitLab or Bitbucket, and without pre/post-processing.</p> <p>Trailers are rendered in the Keep A Changelog template. If the value is an URL, a link is created with the token as title. If not, the trailer is written as is.</p> <p>Example of how the previous trailers are rendered:</p> <pre><code>- Fix atrocious bug ([aafa779](https://github.com/super/repo/commit/aafa7793ec02a) by John Doe).\n    [Fixes issue #14](https://github.com/super/repo/issues/14),\n    [Follow-up of PR #7](https://github.com/super/repo/pull/7),\n    [Part of epic #5](https://agile-software.com/super/project/epics/5),\n</code></pre>   - Fix atrocious bug ([aafa779](https://github.com/super/repo/commit/aafa7793ec02a) by John Doe).     [Fixes issue #14](https://github.com/super/repo/issues/14),     [Follow-up of PR #7](https://github.com/super/repo/pull/7),     [Part of epic #5](https://agile-software.com/super/project/epics/5),   <p>To enable Git trailers parsing, use the <code>-T</code> or <code>--trailers</code> CLI option:</p> <pre><code>git-changelog --trailers\n</code></pre>"},{"location":"usage/#update-changelog-in-place","title":"Update changelog in place","text":"<p>Writing the whole generated changelog to a file is nice, but sometimes you need to tweak the entries in your changelog and you don't want to overwrite these slight modifications each time your regenerate your changelog.</p> <p>For this reason, git-changelog is able to update a changelog file in-place. It means that it will only insert new entries at the top of the changelog, without modifying existing ones.</p> <p>To update a changelog in-place, use the <code>-i</code> or <code>--in-place</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place\n</code></pre> <p>To achieve this, git-changelog searches for versions (entries) already written to the changelog with a regular expression. The verions that are not found in the changelog will be added at the top. To know where to add them exactly, we search for a marker line in the changelog. This marker line is an HTML comment: it is not visible when the changelog is displayed in web pages.</p> <p>To support in-place updates in a custom template, you have two choices:</p> <ol> <li> <p>format versions in your template so they match the default regular expression,     and use the default marker line(s) to tell git-changelog where     to insert new entries. Here are these default values:</p> <pre><code>DEFAULT_VERSION_REGEX = r\"^## \\[(?P&lt;version&gt;v?[^\\]]+)\"\nDEFAULT_MARKER_LINE = \"&lt;!-- insertion marker --&gt;\"\n</code></pre> </li> <li> <p>provide a custom regular expression and marker line,     to match the contents of your custom template,     with the <code>-g</code> or <code>--version-regex</code>, and <code>-m</code> or <code>--marker-line</code> CLI options:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place \\\n    --version-regex '&lt;a href=\"[^\"]+\"&gt;(?P&lt;version&gt;[^&lt;]+)' \\\n    --marker-line '&lt;!-- new entries will be injected here --&gt;'\n</code></pre> </li> </ol> <p>When only one marker line is found in the template, new entries are inserted at this line exactly, overwriting it (but the marker is added again by the new entries themselves).</p> <p>When two marker lines are found, new entries are applied between those two lines, overwriting the previous contents. This is useful when you don't tell git-changelog to bump the latest version: you will have an \"Unreleased\" section that is overwritten and updated each time you update your changelog in-place.</p>"},{"location":"usage/#output-release-notes","title":"Output release notes","text":"<p>Some platforms allow to announce releases with additional \"release notes\". git-changelog can help generating release notes too, by simply reading your existing changelog and printing the latest entry. So if you just pushed a tag with an updated changelog, you can use git-changelog in Continuous Integration/Deployment to create a release (specific to your platform, e.g. GitHub) with the latest changelog entry as release notes.</p> <p>For example, on GitHub, with the softprops/action-gh-release action:</p> <pre><code>name: github_release\n\non: push\n\njobs:\n  github_release:\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/')\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n    - name: Setup Python\n      uses: actions/setup-python@v4\n    - name: Install git-changelog\n      run: pip install git-changelog\n    - name: Prepare release notes\n      run: git-changelog --release-notes &gt; release-notes.md\n    - name: Create GitHub release\n      uses: softprops/action-gh-release@v1\n      with:\n        body_path: release-notes.md\n</code></pre> <p>By default git-changelog will try to read release notes from a file named <code>CHANGELOG.md</code>. Use the <code>-i</code>, <code>--input</code> option to specify another file to read from. Other options can be used to help git-changelog retrieving the latest entry from your changelog: <code>--version-regex</code> and <code>--marker-line</code>.</p>"},{"location":"usage/#configuration-files","title":"Configuration files","text":"<p>Project-wise, permanent configuration of git-changelog is possible. By default, git-changelog will search for the existence a suitable configuration in the <code>pyproject.toml</code> file or otherwise, the following configuration files  in this particular order:</p> <ul> <li><code>.git-changelog.toml</code></li> <li><code>config/git-changelog.toml</code></li> <li><code>.config/git-changelog.toml</code></li> <li><code>&lt;current-user-config-path&gt;/git-changelog.toml</code></li> </ul> <p>In the last case (<code>&lt;current-user-config-path&gt;/git-changelog.toml</code>), the <code>&lt;current-user-config-path&gt;</code> is platform-dependent and will be automatically inferred from your settings. In Unix systems, this will typically point at <code>$HOME/.config/git-changelog.toml</code>. The use of a configuration file can be disabled or overridden with the <code>--config-file</code> option. To disable the configuration file, pass <code>no</code>, <code>none</code>, <code>false</code>, <code>off</code>, <code>0</code> or empty string (<code>''</code>):</p> <pre><code>git-changelog --config-file no\n</code></pre> <p>To override the configuration file, pass the path to the new file:</p> <pre><code>git-changelog --config-file $HOME/.custom-git-changelog-config\n</code></pre> <p>The configuration file must be written in TOML language, and may take values for most of the command line options:</p> <pre><code>bump = \"auto\"\nconvention = \"basic\"\nin-place = false\nmarker-line = \"&lt;!-- insertion marker --&gt;\"\noutput = \"output.log\"\nparse-refs = false\nparse-trailers = false\nrepository = \".\"\nsections = [\"fix\", \"maint\"]\ntemplate = \"angular\"\nversion-regex = \"^## \\\\\\\\[(?P&lt;version&gt;v?[^\\\\\\\\]]+)\"\n</code></pre> <p>In the case of configuring git-changelog within <code>pyproject.toml</code>, these settings must be found in the appropriate section:</p> <pre><code>[tool.git-changelog]\nbump = \"minor\"\nconvention = \"conventional\"\nin-place = false\nmarker-line = \"&lt;!-- insertion marker --&gt;\"\noutput = \"output.log\"\nparse-refs = false\nparse-trailers = false\nrepository = \".\"\nsections = \"fix,maint\"\ntemplate = \"keepachangelog\"\nversion-regex = \"^## \\\\\\\\[(?P&lt;version&gt;v?[^\\\\\\\\]]+)\"\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> git_changelog<ul> <li> build</li> <li> cli</li> <li> commit</li> <li> debug</li> <li> providers</li> <li> templates</li> </ul> </li> </ul>"},{"location":"reference/git_changelog/","title":"Index","text":""},{"location":"reference/git_changelog/#git_changelog","title":"git_changelog","text":"<p>git-changelog package.</p> <p>Automatic Changelog generator using Jinja2 templates.</p> <p>Modules:</p> <ul> <li> <code>build</code>         \u2013          <p>The module responsible for building the data.</p> </li> <li> <code>cli</code>         \u2013          <p>Module that contains the command line application.</p> </li> <li> <code>commit</code>         \u2013          <p>Module containing the commit logic.</p> </li> <li> <code>debug</code>         \u2013          <p>Debugging utilities.</p> </li> <li> <code>providers</code>         \u2013          <p>Module containing the parsing utilities for git providers.</p> </li> <li> <code>templates</code>         \u2013          <p>The subpackage containing the builtin templates.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Bitbucket</code>         \u2013          <p>A parser for the Bitbucket references.</p> </li> <li> <code>Changelog</code>         \u2013          <p>The main changelog class.</p> </li> <li> <code>Commit</code>         \u2013          <p>A class to represent a commit.</p> </li> <li> <code>GitHub</code>         \u2013          <p>A parser for the GitHub references.</p> </li> <li> <code>GitLab</code>         \u2013          <p>A parser for the GitLab references.</p> </li> </ul>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket","title":"Bitbucket","text":"<pre><code>Bitbucket(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the Bitbucket references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog","title":"Changelog","text":"<pre><code>Changelog(\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser\n    | type[ProviderRefParser]\n    | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None\n)\n</code></pre> <p>The main changelog class.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str | Path</code>)         \u2013          <p>The repository (directory) for which to build the changelog.</p> </li> <li> <code>provider</code>             (<code>ProviderRefParser | type[ProviderRefParser] | None</code>, default:                 <code>None</code> )         \u2013          <p>The provider to use (github.com, gitlab.com, etc.).</p> </li> <li> <code>convention</code>             (<code>ConventionType | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit convention to use (angular, etc.).</p> </li> <li> <code>parse_provider_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references in the commit messages.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers in the commit messages.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The sections to render (features, bug fixes, etc.).</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use <code>bump=\"auto\"</code> instead. Whether to try and bump latest version to guess new one.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_log</code>           \u2013            <p>Get the <code>git log</code> output.</p> </li> <li> <code>get_remote_url</code>           \u2013            <p>Get the git remote URL for the repository.</p> </li> <li> <code>parse_commits</code>           \u2013            <p>Parse the output of 'git log' into a list of commits.</p> </li> <li> <code>run_git</code>           \u2013            <p>Run a git command in the chosen repository.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser | type[ProviderRefParser] | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Deprecated, use `bump=\"auto\"` instead. Whether to try and bump latest version to guess new one.\n        bump: Whether to try and bump to a given version.\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n\n    # set provider\n    if not isinstance(provider, ProviderRefParser):\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if callable(provider):\n            provider = provider(namespace, project, url=provider_url)\n        elif \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        elif \"bitbucket\" in provider_url:\n            provider = Bitbucket(namespace, project, url=provider_url)\n        else:\n            provider = None\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(  # noqa: T201\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    sections = (\n        [self.convention.TYPES[section] for section in sections] if sections else self.convention.DEFAULT_RENDER\n    )\n    self.sections = sections\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n\n    # apply dates to commits and group them by version\n    dates = self._apply_versions_to_commits()\n    v_list, v_dict = self._group_commits_by_version(dates)\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\n            \"`bump_latest=True` is deprecated in favor of `bump='auto'`\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        if bump is None:\n            bump = \"auto\"\n    if bump:\n        self._bump(bump)\n\n    # fix a single, initial version to 0.1.0\n    self._fix_single_version()\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.get_log","title":"get_log","text":"<pre><code>get_log() -&gt; str\n</code></pre> <p>Get the <code>git log</code> output.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The output of the <code>git log</code> command, with a particular format.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n    \"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.get_remote_url","title":"get_remote_url","text":"<pre><code>get_remote_url() -&gt; str\n</code></pre> <p>Get the git remote URL for the repository.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The origin remote URL.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:\n    \"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n\n    # Remove credentials from the URL.\n    if git_url.startswith((\"http://\", \"https://\")):\n        # (addressing scheme, network location, path, query, fragment identifier)\n        urlparts = list(urlsplit(git_url))\n        urlparts[1] = urlparts[1].split(\"@\", 1)[-1]\n        git_url = urlunsplit(urlparts)\n\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.parse_commits","title":"parse_commits","text":"<pre><code>parse_commits() -&gt; list[Commit]\n</code></pre> <p>Parse the output of 'git log' into a list of commits.</p> <p>Returns:</p> <ul> <li> <code>list[Commit]</code>         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n    \"\"\"Parse the output of 'git log' into a list of commits.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # don't count last blank line\n    commits = []\n    pos = 0\n    while pos &lt; size:\n        # build body\n        nbl_index = 9\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # build commit\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            subject=lines[pos + 8],\n            body=body,\n            parse_trailers=self.parse_trailers,\n        )\n\n        pos += nbl_index + 1\n\n        # expand commit object with provider parsing\n        if self.provider:\n            commit.update_with_provider(self.provider, parse_refs=self.parse_provider_refs)\n\n        # set the commit url based on remote_url (could be wrong)\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # expand commit object with convention parsing\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits.append(commit)\n\n    return commits\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.run_git","title":"run_git","text":"<pre><code>run_git(*args: str) -&gt; str\n</code></pre> <p>Run a git command in the chosen repository.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>Arguments passed to the git command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The git command output.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n    \"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit","title":"Commit","text":"<pre><code>Commit(\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False\n)\n</code></pre> <p>A class to represent a commit.</p> <p>Parameters:</p> <ul> <li> <code>commit_hash</code>             (<code>str</code>)         \u2013          <p>The commit hash.</p> </li> <li> <code>author_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author name.</p> </li> <li> <code>author_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author email.</p> </li> <li> <code>author_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The authoring date (datetime or UTC timestamp).</p> </li> <li> <code>committer_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer name.</p> </li> <li> <code>committer_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer email.</p> </li> <li> <code>committer_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The committing date (datetime or UTC timestamp).</p> </li> <li> <code>refs</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit refs.</p> </li> <li> <code>subject</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit message subject.</p> </li> <li> <code>body</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit message body.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit URL.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>update_with_convention</code>           \u2013            <p>Apply the convention-parsed data to this commit.</p> </li> <li> <code>update_with_provider</code>           \u2013            <p>Apply the provider-parsed data to this commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def __init__(\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(author_date, str):\n        author_date = datetime.fromtimestamp(float(author_date), tz=timezone.utc)\n    if not committer_date:\n        committer_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(committer_date, str):\n        committer_date = datetime.fromtimestamp(float(committer_date), tz=timezone.utc)\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()  # noqa: PLW2901\n        if ref.startswith(\"tag: \"):\n            tag = ref.replace(\"tag: \", \"\")\n            break\n    self.tag: str = tag\n    self.version: str = tag\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit.update_with_convention","title":"update_with_convention","text":"<pre><code>update_with_convention(\n    convention: CommitConvention,\n) -&gt; None\n</code></pre> <p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>convention</code>             (<code>CommitConvention</code>)         \u2013          <p>The convention to use.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n    \"\"\"Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit.update_with_provider","title":"update_with_provider","text":"<pre><code>update_with_provider(\n    provider: ProviderRefParser, parse_refs: bool = True\n) -&gt; None\n</code></pre> <p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>provider</code>             (<code>ProviderRefParser</code>)         \u2013          <p>The provider to use.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to parse references for this provider.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_provider(\n    self,\n    provider: ProviderRefParser,\n    parse_refs: bool = True,  # noqa: FBT001,FBT002\n) -&gt; None:\n    \"\"\"Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF:\n            self.text_refs[ref_type] = provider.get_refs(\n                ref_type,\n                \"\\n\".join([self.subject, *self.body]),\n            )\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub","title":"GitHub","text":"<pre><code>GitHub(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab","title":"GitLab","text":"<pre><code>GitLab(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/build/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> build","text":""},{"location":"reference/git_changelog/build/#git_changelog.build","title":"build","text":"<p>The module responsible for building the data.</p> <p>Classes:</p> <ul> <li> <code>Changelog</code>         \u2013          <p>The main changelog class.</p> </li> <li> <code>Section</code>         \u2013          <p>A list of commits grouped by section_type.</p> </li> <li> <code>Version</code>         \u2013          <p>A class to represent a changelog version.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>bump</code>           \u2013            <p>Bump a version.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog","title":"Changelog","text":"<pre><code>Changelog(\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser\n    | type[ProviderRefParser]\n    | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None\n)\n</code></pre> <p>The main changelog class.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str | Path</code>)         \u2013          <p>The repository (directory) for which to build the changelog.</p> </li> <li> <code>provider</code>             (<code>ProviderRefParser | type[ProviderRefParser] | None</code>, default:                 <code>None</code> )         \u2013          <p>The provider to use (github.com, gitlab.com, etc.).</p> </li> <li> <code>convention</code>             (<code>ConventionType | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit convention to use (angular, etc.).</p> </li> <li> <code>parse_provider_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references in the commit messages.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers in the commit messages.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The sections to render (features, bug fixes, etc.).</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use <code>bump=\"auto\"</code> instead. Whether to try and bump latest version to guess new one.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_log</code>           \u2013            <p>Get the <code>git log</code> output.</p> </li> <li> <code>get_remote_url</code>           \u2013            <p>Get the git remote URL for the repository.</p> </li> <li> <code>parse_commits</code>           \u2013            <p>Parse the output of 'git log' into a list of commits.</p> </li> <li> <code>run_git</code>           \u2013            <p>Run a git command in the chosen repository.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser | type[ProviderRefParser] | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Deprecated, use `bump=\"auto\"` instead. Whether to try and bump latest version to guess new one.\n        bump: Whether to try and bump to a given version.\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n\n    # set provider\n    if not isinstance(provider, ProviderRefParser):\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if callable(provider):\n            provider = provider(namespace, project, url=provider_url)\n        elif \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        elif \"bitbucket\" in provider_url:\n            provider = Bitbucket(namespace, project, url=provider_url)\n        else:\n            provider = None\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(  # noqa: T201\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    sections = (\n        [self.convention.TYPES[section] for section in sections] if sections else self.convention.DEFAULT_RENDER\n    )\n    self.sections = sections\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n\n    # apply dates to commits and group them by version\n    dates = self._apply_versions_to_commits()\n    v_list, v_dict = self._group_commits_by_version(dates)\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\n            \"`bump_latest=True` is deprecated in favor of `bump='auto'`\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        if bump is None:\n            bump = \"auto\"\n    if bump:\n        self._bump(bump)\n\n    # fix a single, initial version to 0.1.0\n    self._fix_single_version()\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_log","title":"get_log","text":"<pre><code>get_log() -&gt; str\n</code></pre> <p>Get the <code>git log</code> output.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The output of the <code>git log</code> command, with a particular format.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n    \"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_remote_url","title":"get_remote_url","text":"<pre><code>get_remote_url() -&gt; str\n</code></pre> <p>Get the git remote URL for the repository.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The origin remote URL.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:\n    \"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n\n    # Remove credentials from the URL.\n    if git_url.startswith((\"http://\", \"https://\")):\n        # (addressing scheme, network location, path, query, fragment identifier)\n        urlparts = list(urlsplit(git_url))\n        urlparts[1] = urlparts[1].split(\"@\", 1)[-1]\n        git_url = urlunsplit(urlparts)\n\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.parse_commits","title":"parse_commits","text":"<pre><code>parse_commits() -&gt; list[Commit]\n</code></pre> <p>Parse the output of 'git log' into a list of commits.</p> <p>Returns:</p> <ul> <li> <code>list[Commit]</code>         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n    \"\"\"Parse the output of 'git log' into a list of commits.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # don't count last blank line\n    commits = []\n    pos = 0\n    while pos &lt; size:\n        # build body\n        nbl_index = 9\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # build commit\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            subject=lines[pos + 8],\n            body=body,\n            parse_trailers=self.parse_trailers,\n        )\n\n        pos += nbl_index + 1\n\n        # expand commit object with provider parsing\n        if self.provider:\n            commit.update_with_provider(self.provider, parse_refs=self.parse_provider_refs)\n\n        # set the commit url based on remote_url (could be wrong)\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # expand commit object with convention parsing\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits.append(commit)\n\n    return commits\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.run_git","title":"run_git","text":"<pre><code>run_git(*args: str) -&gt; str\n</code></pre> <p>Run a git command in the chosen repository.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>Arguments passed to the git command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The git command output.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n    \"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Section","title":"Section","text":"<pre><code>Section(\n    section_type: str = \"\",\n    commits: list[Commit] | None = None,\n)\n</code></pre> <p>A list of commits grouped by section_type.</p> <p>Parameters:</p> <ul> <li> <code>section_type</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The section section_type.</p> </li> <li> <code>commits</code>             (<code>list[Commit] | None</code>, default:                 <code>None</code> )         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(self, section_type: str = \"\", commits: list[Commit] | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        section_type: The section section_type.\n        commits: The list of commits.\n    \"\"\"\n    self.type: str = section_type\n    self.commits: list[Commit] = commits or []\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version","title":"Version","text":"<pre><code>Version(\n    tag: str = \"\",\n    date: date | None = None,\n    sections: list[Section] | None = None,\n    commits: list[Commit] | None = None,\n    url: str = \"\",\n    compare_url: str = \"\",\n)\n</code></pre> <p>A class to represent a changelog version.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version tag.</p> </li> <li> <code>date</code>             (<code>date | None</code>, default:                 <code>None</code> )         \u2013          <p>The version date.</p> </li> <li> <code>sections</code>             (<code>list[Section] | None</code>, default:                 <code>None</code> )         \u2013          <p>The version sections.</p> </li> <li> <code>commits</code>             (<code>list[Commit] | None</code>, default:                 <code>None</code> )         \u2013          <p>The version commits.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version URL.</p> </li> <li> <code>compare_url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version 'compare' URL.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_major</code>             (<code>bool</code>)         \u2013          <p>Tell if this version is a major one.</p> </li> <li> <code>is_minor</code>             (<code>bool</code>)         \u2013          <p>Tell if this version is a minor one.</p> </li> <li> <code>typed_sections</code>             (<code>list[Section]</code>)         \u2013          <p>Return typed sections only.</p> </li> <li> <code>untyped_section</code>             (<code>Section | None</code>)         \u2013          <p>Return untyped section if any.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"\",\n    date: datetime.date | None = None,\n    sections: list[Section] | None = None,\n    commits: list[Commit] | None = None,\n    url: str = \"\",\n    compare_url: str = \"\",\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        tag: The version tag.\n        date: The version date.\n        sections: The version sections.\n        commits: The version commits.\n        url: The version URL.\n        compare_url: The version 'compare' URL.\n    \"\"\"\n    self.tag = tag\n    self.date = date\n\n    self.sections_list: list[Section] = sections or []\n    self.sections_dict: dict[str, Section] = {section.type: section for section in self.sections_list}\n    self.commits: list[Commit] = commits or []\n    self.url: str = url\n    self.compare_url: str = compare_url\n    self.previous_version: Version | None = None\n    self.next_version: Version | None = None\n    self.planned_tag: str | None = None\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_major","title":"is_major  <code>property</code>","text":"<pre><code>is_major: bool\n</code></pre> <p>Tell if this version is a major one.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether this version is major.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_minor","title":"is_minor  <code>property</code>","text":"<pre><code>is_minor: bool\n</code></pre> <p>Tell if this version is a minor one.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether this version is minor.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.typed_sections","title":"typed_sections  <code>property</code>","text":"<pre><code>typed_sections: list[Section]\n</code></pre> <p>Return typed sections only.</p> <p>Returns:</p> <ul> <li> <code>list[Section]</code>         \u2013          <p>The typed sections.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.untyped_section","title":"untyped_section  <code>property</code>","text":"<pre><code>untyped_section: Section | None\n</code></pre> <p>Return untyped section if any.</p> <p>Returns:</p> <ul> <li> <code>Section | None</code>         \u2013          <p>The untyped section if any.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.bump","title":"bump","text":"<pre><code>bump(\n    version: str,\n    part: Literal[\"major\", \"minor\", \"patch\"] = \"patch\",\n) -&gt; str\n</code></pre> <p>Bump a version.</p> <p>Parameters:</p> <ul> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>The version to bump.</p> </li> <li> <code>part</code>             (<code>Literal['major', 'minor', 'patch']</code>, default:                 <code>'patch'</code> )         \u2013          <p>The part of the version to bump (major, minor, or patch).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The bumped version.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def bump(version: str, part: Literal[\"major\", \"minor\", \"patch\"] = \"patch\") -&gt; str:\n    \"\"\"Bump a version.\n\n    Arguments:\n        version: The version to bump.\n        part: The part of the version to bump (major, minor, or patch).\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    prefix = \"\"\n    if version[0] == \"v\":\n        prefix = \"v\"\n        version = version[1:]\n\n    semver_version = VersionInfo.parse(version)\n    if part == \"major\" and semver_version.major != 0:\n        semver_version = semver_version.bump_major()\n    elif part == \"minor\" or (part == \"major\" and semver_version.major == 0):\n        semver_version = semver_version.bump_minor()\n    elif part == \"patch\" and not semver_version.prerelease:\n        semver_version = semver_version.bump_patch()\n    return prefix + str(semver_version)\n</code></pre>"},{"location":"reference/git_changelog/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"reference/git_changelog/cli/#git_changelog.cli","title":"cli","text":"<p>Module that contains the command line application.</p> <p>Classes:</p> <ul> <li> <code>Templates</code>         \u2013          <p>Helper to pick a template on the command line.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>build_and_render</code>           \u2013            <p>Build a changelog and render it.</p> </li> <li> <code>get_parser</code>           \u2013            <p>Return the CLI argument parser.</p> </li> <li> <code>get_release_notes</code>           \u2013            <p>Get release notes from existing changelog.</p> </li> <li> <code>get_version</code>           \u2013            <p>Return the current <code>git-changelog</code> version.</p> </li> <li> <code>main</code>           \u2013            <p>Run the main program.</p> </li> <li> <code>output_release_notes</code>           \u2013            <p>Print release notes from existing changelog.</p> </li> <li> <code>parse_settings</code>           \u2013            <p>Parse arguments and config files to build the final settings set.</p> </li> <li> <code>read_config</code>           \u2013            <p>Find config files and initialize settings with the one of highest priority.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_CONFIG_FILES</code>         \u2013          <p>Default configuration files read by git-changelog.</p> </li> </ul>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.DEFAULT_CONFIG_FILES","title":"DEFAULT_CONFIG_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG_FILES = [\n    \"pyproject.toml\",\n    \".git-changelog.toml\",\n    \"config/git-changelog.toml\",\n    \".config/git-changelog.toml\",\n    str(Path(user_config_dir()) / \"git-changelog.toml\"),\n]\n</code></pre> <p>Default configuration files read by git-changelog.</p>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.Templates","title":"Templates","text":"<p>             Bases: <code>tuple</code></p> <p>Helper to pick a template on the command line.</p>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.build_and_render","title":"build_and_render","text":"<pre><code>build_and_render(\n    repository: str,\n    template: str,\n    convention: str | CommitConvention,\n    parse_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    in_place: bool = False,\n    output: str | TextIO | None = None,\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    bump_latest: bool = False,\n    omit_empty_versions: bool = False,\n    provider: str | None = None,\n    bump: str | None = None,\n) -&gt; tuple[Changelog, str]\n</code></pre> <p>Build a changelog and render it.</p> <p>This function returns the changelog instance and the rendered contents, but also updates the specified output file (side-effect) or writes to stdout.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str</code>)         \u2013          <p>Path to a local repository.</p> </li> <li> <code>template</code>             (<code>str</code>)         \u2013          <p>Name of a builtin template, or path to a custom template (prefixed with <code>path:</code>).</p> </li> <li> <code>convention</code>             (<code>str | CommitConvention</code>)         \u2013          <p>Name of a commit message style/convention.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Sections to render (features, bug fixes, etc.).</p> </li> <li> <code>in_place</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to update the changelog in-place.</p> </li> <li> <code>output</code>             (<code>str | TextIO | None</code>, default:                 <code>None</code> )         \u2013          <p>Output/changelog file.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>Regular expression to match versions in an existing changelog file.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>Marker line used to insert contents in an existing changelog.</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use --bump=auto instead. Whether to try and bump the latest version to guess the new one.</p> </li> <li> <code>omit_empty_versions</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to omit empty versions from the output.</p> </li> <li> <code>provider</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Provider class used by this repository.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When some arguments are incompatible or missing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Changelog, str]</code>         \u2013          <p>The built changelog and the rendered contents.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def build_and_render(\n    repository: str,\n    template: str,\n    convention: str | CommitConvention,\n    parse_refs: bool = False,  # noqa: FBT001,FBT002\n    parse_trailers: bool = False,  # noqa: FBT001,FBT002\n    sections: list[str] | None = None,\n    in_place: bool = False,  # noqa: FBT001,FBT002\n    output: str | TextIO | None = None,\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    bump_latest: bool = False,  # noqa: FBT001,FBT002\n    omit_empty_versions: bool = False,  # noqa: FBT001,FBT002\n    provider: str | None = None,\n    bump: str | None = None,\n) -&gt; tuple[Changelog, str]:\n    \"\"\"Build a changelog and render it.\n\n    This function returns the changelog instance and the rendered contents,\n    but also updates the specified output file (side-effect) or writes to stdout.\n\n    Parameters:\n        repository: Path to a local repository.\n        template: Name of a builtin template, or path to a custom template (prefixed with `path:`).\n        convention: Name of a commit message style/convention.\n        parse_refs: Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).\n        parse_trailers: Whether to parse Git trailers.\n        sections: Sections to render (features, bug fixes, etc.).\n        in_place: Whether to update the changelog in-place.\n        output: Output/changelog file.\n        version_regex: Regular expression to match versions in an existing changelog file.\n        marker_line: Marker line used to insert contents in an existing changelog.\n        bump_latest: Deprecated, use --bump=auto instead.\n            Whether to try and bump the latest version to guess the new one.\n        omit_empty_versions: Whether to omit empty versions from the output.\n        provider: Provider class used by this repository.\n        bump: Whether to try and bump to a given version.\n\n    Raises:\n        ValueError: When some arguments are incompatible or missing.\n\n    Returns:\n        The built changelog and the rendered contents.\n    \"\"\"\n    # get template\n    if template.startswith(\"path:\"):\n        path = template.replace(\"path:\", \"\", 1)\n        try:\n            jinja_template = templates.get_custom_template(path)\n        except TemplateNotFound as error:\n            raise ValueError(f\"No such file: {path}\") from error\n    else:\n        jinja_template = templates.get_template(template)\n\n    if output is None:\n        output = sys.stdout\n\n    # handle misconfiguration early\n    if in_place and output is sys.stdout:\n        raise ValueError(\"Cannot write in-place to stdout\")\n\n    # get provider\n    provider_class = providers[provider] if provider else None\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\"`bump_latest=True` is deprecated in favor of `bump='auto'`\", DeprecationWarning, stacklevel=1)\n        if bump is None:\n            bump = \"auto\"\n\n    # build data\n    changelog = Changelog(\n        repository,\n        provider=provider_class,\n        convention=convention,\n        parse_provider_refs=parse_refs,\n        parse_trailers=parse_trailers,\n        sections=sections,\n        bump=bump,\n    )\n\n    # remove empty versions from changelog data\n    if omit_empty_versions:\n        section_set = set(changelog.sections)\n        empty_versions = [\n            version for version in changelog.versions_list if section_set.isdisjoint(version.sections_dict.keys())\n        ]\n        for version in empty_versions:\n            changelog.versions_list.remove(version)\n            changelog.versions_dict.pop(version.tag)\n\n    # render new entries in-place\n    if in_place:\n        # read current changelog lines\n        with open(output) as changelog_file:  # type: ignore[arg-type]\n            lines = changelog_file.read().splitlines()\n\n        # prepare version regex and marker line\n        if template in {\"angular\", \"keepachangelog\"}:\n            version_regex = DEFAULT_VERSION_REGEX\n            marker_line = DEFAULT_MARKER_LINE\n\n        # only keep new entries (missing from changelog)\n        last_released = _latest(lines, re.compile(version_regex))\n        if last_released:\n            # check if the latest version is already in the changelog\n            if last_released in [\n                changelog.versions_list[0].tag,\n                changelog.versions_list[0].planned_tag,\n            ]:\n                raise ValueError(f\"Version {last_released} already in changelog\")\n            changelog.versions_list = _unreleased(\n                changelog.versions_list,\n                last_released,\n            )\n\n        # render new entries\n        rendered = jinja_template.render(changelog=changelog, in_place=True).rstrip(\"\\n\") + \"\\n\"\n\n        # find marker line(s) in current changelog\n        marker = lines.index(marker_line)\n        try:\n            marker2 = lines[marker + 1 :].index(marker_line)\n        except ValueError:\n            # apply new entries at marker line\n            lines[marker] = rendered\n        else:\n            # apply new entries between marker lines\n            lines[marker : marker + marker2 + 2] = [rendered]\n\n        # write back updated changelog lines\n        with open(output, \"w\") as changelog_file:  # type: ignore[arg-type]\n            changelog_file.write(\"\\n\".join(lines).rstrip(\"\\n\") + \"\\n\")\n\n    # overwrite output file\n    else:\n        rendered = jinja_template.render(changelog=changelog)\n\n        # write result in specified output\n        if output is sys.stdout:\n            sys.stdout.write(rendered)\n        else:\n            with open(output, \"w\") as stream:  # type: ignore[arg-type]\n                stream.write(rendered)\n\n    return changelog, rendered\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_parser","title":"get_parser","text":"<pre><code>get_parser() -&gt; ArgumentParser\n</code></pre> <p>Return the CLI argument parser.</p> <p>Returns:</p> <ul> <li> <code>ArgumentParser</code>         \u2013          <p>An argparse parser.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        prog=\"git-changelog\",\n        description=re.sub(\n            r\"\\n *\",\n            \"\\n\",\n            f\"\"\"\n            Automatic Changelog generator using Jinja2 templates.\n\n            This tool parses your commit messages to extract useful data\n            that is then rendered using Jinja2 templates, for example to\n            a changelog file formatted in Markdown.\n\n            Each Git tag will be treated as a version of your project.\n            Each version contains a set of commits, and will be an entry\n            in your changelog. Commits in each version will be grouped\n            by sections, depending on the commit convention you follow.\n\n            {BasicConvention._format_sections_help()}\n            {AngularConvention._format_sections_help()}\n            {ConventionalCommitConvention._format_sections_help()}\n            \"\"\",\n        ),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        \"repository\",\n        metavar=\"REPOSITORY\",\n        nargs=\"?\",\n        help=\"The repository path, relative or absolute. Default: current working directory.\",\n    )\n\n    parser.add_argument(\n        \"--config-file\",\n        metavar=\"PATH\",\n        nargs=\"*\",\n        help=\"Configuration file(s).\",\n    )\n\n    parser.add_argument(\n        \"-b\",\n        \"--bump-latest\",\n        action=\"store_true\",\n        dest=\"bump_latest\",\n        help=\"Deprecated, use --bump=auto instead. \"\n        \"Guess the new latest version by bumping the previous one based on the set of unreleased commits. \"\n        \"For example, if a commit contains breaking changes, bump the major number (or the minor number for 0.x versions). \"\n        \"Else if there are new features, bump the minor number. Else just bump the patch number. \"\n        \"Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-B\",\n        \"--bump\",\n        action=\"store\",\n        dest=\"bump\",\n        metavar=\"VERSION\",\n        help=\"Specify the bump from latest version for the set of unreleased commits. \"\n        \"Can be one of 'auto', 'major', 'minor', 'patch' or a valid semver version (eg. 1.2.3). \"\n        \"With 'auto', if a commit contains breaking changes, bump the major number (or the minor number for 0.x versions), \"\n        \"else if there are new features, bump the minor number, else just bump the patch number. \"\n        \"Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-h\",\n        \"--help\",\n        action=\"help\",\n        default=argparse.SUPPRESS,\n        help=\"Show this help message and exit.\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--in-place\",\n        action=\"store_true\",\n        dest=\"in_place\",\n        help=\"Insert new entries (versions missing from changelog) in-place. \"\n        \"An output file must be specified. With custom templates, \"\n        \"you can pass two additional arguments: --version-regex and --marker-line. \"\n        \"When writing in-place, an 'in_place' variable \"\n        \"will be injected in the Jinja context, \"\n        \"allowing to adapt the generated contents \"\n        \"(for example to skip changelog headers or footers). Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-g\",\n        \"--version-regex\",\n        action=\"store\",\n        dest=\"version_regex\",\n        help=\"A regular expression to match versions in the existing changelog \"\n        \"(used to find the latest release) when writing in-place. \"\n        \"The regular expression must be a Python regex with a 'version' named group. \"\n        f\"Default: '{DEFAULT_VERSION_REGEX}'.\",\n    )\n\n    parser.add_argument(\n        \"-m\",\n        \"--marker-line\",\n        action=\"store\",\n        dest=\"marker_line\",\n        help=\"A marker line at which to insert new entries \"\n        \"(versions missing from changelog). \"\n        \"If two marker lines are present in the changelog, \"\n        \"the contents between those two lines will be overwritten \"\n        \"(useful to update an 'Unreleased' entry for example). \"\n        f\"Default: '{DEFAULT_MARKER_LINE}'.\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        action=\"store\",\n        dest=\"output\",\n        help=\"Output to given file. Default: standard output.\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--provider\",\n        dest=\"provider\",\n        choices=providers.keys(),\n        help=\"Explicitly specify the repository provider. Default: unset.\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--parse-refs\",\n        action=\"store_true\",\n        dest=\"parse_refs\",\n        help=\"Parse provider-specific references in commit messages (GitHub/GitLab/Bitbucket \"\n        \"issues, PRs, etc.). Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-R\",\n        \"--release-notes\",\n        action=\"store_true\",\n        dest=\"release_notes\",\n        help=\"Output release notes to stdout based on the last entry in the changelog. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-I\",\n        \"--input\",\n        dest=\"input\",\n        help=f\"Read from given file when creating release notes. Default: '{DEFAULT_CHANGELOG_FILE}'.\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--style\",\n        \"--commit-style\",\n        \"--convention\",\n        choices=CONVENTIONS,\n        dest=\"convention\",\n        help=f\"The commit convention to match against. Default: '{DEFAULT_SETTINGS['convention']}'.\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--sections\",\n        action=\"store\",\n        type=_comma_separated_list,\n        dest=\"sections\",\n        help=\"A comma-separated list of sections to render. \"\n        \"See the available sections for each supported convention in the description. \"\n        \"Default: unset (None).\",\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--template\",\n        choices=Templates((\"angular\", \"keepachangelog\")),\n        dest=\"template\",\n        help=\"The Jinja2 template to use. Prefix it with 'path:'' to specify the path \"\n        \"to a directory containing a file named 'changelog.md'. \"\n        f\"Default: '{DEFAULT_SETTINGS['template']}'.\",\n    )\n    parser.add_argument(\n        \"-T\",\n        \"--trailers\",\n        \"--git-trailers\",\n        action=\"store_true\",\n        dest=\"parse_trailers\",\n        help=\"Parse Git trailers in the commit message. \"\n        \"See https://git-scm.com/docs/git-interpret-trailers. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-E\",\n        \"--omit-empty-versions\",\n        action=\"store_true\",\n        dest=\"omit_empty_versions\",\n        help=\"Omit empty versions from the output. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s {debug.get_version()}\",\n        help=\"Show the current version of the program and exit.\",\n    )\n    parser.add_argument(\"--debug-info\", action=_DebugInfo, help=\"Print debug information.\")\n\n    return parser\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_release_notes","title":"get_release_notes","text":"<pre><code>get_release_notes(\n    input_file: str | Path = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n) -&gt; str\n</code></pre> <p>Get release notes from existing changelog.</p> <p>This will return the latest entry in the changelog.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str | Path</code>, default:                 <code>'CHANGELOG.md'</code> )         \u2013          <p>The changelog to read from.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>A regular expression to match version entries.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>The insertion marker line in the changelog.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The latest changelog entry.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_release_notes(\n    input_file: str | Path = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n) -&gt; str:\n    \"\"\"Get release notes from existing changelog.\n\n    This will return the latest entry in the changelog.\n\n    Parameters:\n        input_file: The changelog to read from.\n        version_regex: A regular expression to match version entries.\n        marker_line: The insertion marker line in the changelog.\n\n    Returns:\n        The latest changelog entry.\n    \"\"\"\n    release_notes = []\n    found_marker = False\n    found_version = False\n    with open(input_file) as changelog:\n        for line in changelog:\n            line = line.strip()  # noqa: PLW2901\n            if not found_marker:\n                if line == marker_line:\n                    found_marker = True\n                continue\n            if re.search(version_regex, line):\n                if found_version:\n                    break\n                found_version = True\n            release_notes.append(line)\n    result = \"\\n\".join(release_notes).strip()\n    if result.endswith(marker_line):\n        result = result[: -len(marker_line)].strip()\n    return result\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str\n</code></pre> <p>Return the current <code>git-changelog</code> version.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The current <code>git-changelog</code> version.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"Return the current `git-changelog` version.\n\n    Returns:\n        The current `git-changelog` version.\n    \"\"\"\n    try:\n        return metadata.version(\"git-changelog\")\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.main","title":"main","text":"<pre><code>main(args: list[str] | None = None) -&gt; int\n</code></pre> <p>Run the main program.</p> <p>This function is executed when you type <code>git-changelog</code> or <code>python -m git_changelog</code>.</p> <p>Parameters:</p> <ul> <li> <code>args</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>An exit code.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n    \"\"\"Run the main program.\n\n    This function is executed when you type `git-changelog` or `python -m git_changelog`.\n\n    Arguments:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    settings = parse_settings(args)\n\n    if settings.pop(\"release_notes\"):\n        output_release_notes(\n            input_file=settings[\"input\"],\n            version_regex=settings[\"version_regex\"],\n            marker_line=settings[\"marker_line\"],\n            output_file=settings[\"output\"],\n        )\n        return 0\n\n    # --input is not necessary anymore\n    settings.pop(\"input\", None)\n    try:\n        build_and_render(**settings)\n    except ValueError as error:\n        print(f\"git-changelog: {error}\", file=sys.stderr)\n        return 1\n\n    return 0\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.output_release_notes","title":"output_release_notes","text":"<pre><code>output_release_notes(\n    input_file: str = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    output_file: str | TextIO = sys.stdout,\n) -&gt; None\n</code></pre> <p>Print release notes from existing changelog.</p> <p>This will print the latest entry in the changelog.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str</code>, default:                 <code>'CHANGELOG.md'</code> )         \u2013          <p>The changelog to read from.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>A regular expression to match version entries.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>The insertion marker line in the changelog.</p> </li> <li> <code>output_file</code>             (<code>str | TextIO</code>, default:                 <code>stdout</code> )         \u2013          <p>Where to print/write the release notes.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def output_release_notes(\n    input_file: str = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    output_file: str | TextIO = sys.stdout,\n) -&gt; None:\n    \"\"\"Print release notes from existing changelog.\n\n    This will print the latest entry in the changelog.\n\n    Parameters:\n        input_file: The changelog to read from.\n        version_regex: A regular expression to match version entries.\n        marker_line: The insertion marker line in the changelog.\n        output_file: Where to print/write the release notes.\n    \"\"\"\n    release_notes = get_release_notes(input_file, version_regex, marker_line)\n    try:\n        output_file.write(release_notes)  # type: ignore[union-attr]\n    except AttributeError:\n        with open(output_file, \"w\") as file:  # type: ignore[arg-type]\n            file.write(release_notes)\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.parse_settings","title":"parse_settings","text":"<pre><code>parse_settings(args: list[str] | None = None) -&gt; dict\n</code></pre> <p>Parse arguments and config files to build the final settings set.</p> <p>Parameters:</p> <ul> <li> <code>args</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A dictionary with the final settings.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def parse_settings(args: list[str] | None = None) -&gt; dict:\n    \"\"\"Parse arguments and config files to build the final settings set.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        A dictionary with the final settings.\n    \"\"\"\n    parser = get_parser()\n    opts = vars(parser.parse_args(args=args))\n\n    # Determine which arguments were explicitly set with the CLI\n    sentinel = object()\n    sentinel_ns = argparse.Namespace(**{key: sentinel for key in opts})\n    explicit_opts_dict = {\n        key: opts.get(key, None)\n        for key, value in vars(parser.parse_args(namespace=sentinel_ns, args=args)).items()\n        if value is not sentinel\n    }\n\n    config_file = explicit_opts_dict.pop(\"config_file\", DEFAULT_CONFIG_FILES)\n    if str(config_file).strip().lower() in (\"no\", \"none\", \"off\", \"false\", \"0\", \"\"):\n        config_file = None\n    elif str(config_file).strip().lower() in (\"yes\", \"default\", \"on\", \"true\", \"1\"):\n        config_file = DEFAULT_CONFIG_FILES\n\n    settings = read_config(config_file)\n\n    # CLI arguments override the config file settings\n    settings.update(explicit_opts_dict)\n\n    # TODO: remove at some point\n    if \"bump_latest\" in explicit_opts_dict:\n        warnings.warn(\"`--bump-latest` is deprecated in favor of `--bump=auto`\", FutureWarning, stacklevel=1)\n\n    return settings\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.read_config","title":"read_config","text":"<pre><code>read_config(\n    config_file: Sequence[str | Path]\n    | str\n    | Path\n    | None = DEFAULT_CONFIG_FILES,\n) -&gt; dict\n</code></pre> <p>Find config files and initialize settings with the one of highest priority.</p> <p>Parameters:</p> <ul> <li> <code>config_file</code>             (<code>Sequence[str | Path] | str | Path | None</code>, default:                 <code>DEFAULT_CONFIG_FILES</code> )         \u2013          <p>A path or list of paths to configuration file(s); or <code>None</code> to disable config file settings. Default: a list of paths given by <code>git_changelog.cli.DEFAULT_CONFIG_FILES</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A settings dictionary. Default settings if no config file is found or <code>config_file</code> is <code>None</code>.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def read_config(\n    config_file: Sequence[str | Path] | str | Path | None = DEFAULT_CONFIG_FILES,\n) -&gt; dict:\n    \"\"\"Find config files and initialize settings with the one of highest priority.\n\n    Parameters:\n        config_file: A path or list of paths to configuration file(s); or `None` to\n            disable config file settings. Default: a list of paths given by\n            [`git_changelog.cli.DEFAULT_CONFIG_FILES`][].\n\n    Returns:\n        A settings dictionary. Default settings if no config file is found or `config_file` is `None`.\n\n    \"\"\"\n    project_config = DEFAULT_SETTINGS.copy()\n    if config_file is None:  # Unset config file\n        return project_config\n\n    for filename in config_file if isinstance(config_file, (list, tuple)) else [config_file]:\n        _path = Path(filename)\n\n        if not _path.exists():\n            continue\n\n        with _path.open(\"rb\") as file:\n            new_settings = tomllib.load(file)\n        if _path.name == \"pyproject.toml\":\n            new_settings = new_settings.get(\"tool\", {}).get(\"git-changelog\", {}) or new_settings.get(\n                \"tool.git-changelog\",\n                {},\n            )\n\n            if not new_settings:  # pyproject.toml did not have a git-changelog section\n                continue\n\n        # Settings can have hyphens like in the CLI\n        new_settings = {key.replace(\"-\", \"_\"): value for key, value in new_settings.items()}\n\n        # TODO: remove at some point\n        if \"bump_latest\" in new_settings:\n            _opt_value = new_settings[\"bump_latest\"]\n            _suggestion = (\n                \"remove it from the config file\" if not _opt_value else \"set `bump = 'auto'` in the config file instead\"\n            )\n            warnings.warn(\n                f\"`bump-latest = {str(_opt_value).lower()}` option found \"\n                f\"in config file ({_path.absolute()}). This option will be removed in the future. \"\n                f\"To achieve the same result, please {_suggestion}.\",\n                FutureWarning,\n                stacklevel=1,\n            )\n\n        # Massage found values to meet expectations\n        # Parse sections\n        if \"sections\" in new_settings:\n            # Remove \"sections\" from dict, only restore if the list is valid\n            sections = new_settings.pop(\"sections\", None)\n            if isinstance(sections, str):\n                sections = sections.split(\",\")\n\n            sections = [s.strip() for s in sections if isinstance(s, str) and s.strip()]\n\n            if sections:  # toml doesn't store null/nil\n                new_settings[\"sections\"] = sections\n\n        project_config.update(new_settings)\n        break\n\n    return project_config\n</code></pre>"},{"location":"reference/git_changelog/commit/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> commit","text":""},{"location":"reference/git_changelog/commit/#git_changelog.commit","title":"commit","text":"<p>Module containing the commit logic.</p> <p>Classes:</p> <ul> <li> <code>AngularConvention</code>         \u2013          <p>Angular commit message convention.</p> </li> <li> <code>BasicConvention</code>         \u2013          <p>Basic commit message convention.</p> </li> <li> <code>Commit</code>         \u2013          <p>A class to represent a commit.</p> </li> <li> <code>CommitConvention</code>         \u2013          <p>A base class for a convention of commit messages.</p> </li> <li> <code>ConventionalCommitConvention</code>         \u2013          <p>Conventional commit message convention.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention","title":"AngularConvention","text":"<p>             Bases: <code>CommitConvention</code></p> <p>Angular commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_subject</code>           \u2013            <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"feat\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.parse_subject","title":"parse_subject","text":"<pre><code>parse_subject(commit_subject: str) -&gt; dict[str, str]\n</code></pre> <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>         \u2013          <p>The parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n    \"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The parsed data.\n    \"\"\"\n    subject_match = self.SUBJECT_REGEX.match(commit_subject)\n    if subject_match:\n        dct = subject_match.groupdict()\n        dct[\"type\"] = self.TYPES[dct[\"type\"]]\n        return dct\n    return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention","title":"BasicConvention","text":"<p>             Bases: <code>CommitConvention</code></p> <p>Basic commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_type</code>           \u2013            <p>Parse the type of the commit given its subject.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"add\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.parse_type","title":"parse_type","text":"<pre><code>parse_type(commit_subject: str) -&gt; str\n</code></pre> <p>Parse the type of the commit given its subject.</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The commit type.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_type(self, commit_subject: str) -&gt; str:\n    \"\"\"Parse the type of the commit given its subject.\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The commit type.\n    \"\"\"\n    type_match = self.TYPE_REGEX.match(commit_subject)\n    if type_match:\n        return self.TYPES.get(type_match.groupdict()[\"type\"].lower(), \"\")\n    return \"\"\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit","title":"Commit","text":"<pre><code>Commit(\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False\n)\n</code></pre> <p>A class to represent a commit.</p> <p>Parameters:</p> <ul> <li> <code>commit_hash</code>             (<code>str</code>)         \u2013          <p>The commit hash.</p> </li> <li> <code>author_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author name.</p> </li> <li> <code>author_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author email.</p> </li> <li> <code>author_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The authoring date (datetime or UTC timestamp).</p> </li> <li> <code>committer_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer name.</p> </li> <li> <code>committer_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer email.</p> </li> <li> <code>committer_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The committing date (datetime or UTC timestamp).</p> </li> <li> <code>refs</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit refs.</p> </li> <li> <code>subject</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit message subject.</p> </li> <li> <code>body</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit message body.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit URL.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>update_with_convention</code>           \u2013            <p>Apply the convention-parsed data to this commit.</p> </li> <li> <code>update_with_provider</code>           \u2013            <p>Apply the provider-parsed data to this commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def __init__(\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(author_date, str):\n        author_date = datetime.fromtimestamp(float(author_date), tz=timezone.utc)\n    if not committer_date:\n        committer_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(committer_date, str):\n        committer_date = datetime.fromtimestamp(float(committer_date), tz=timezone.utc)\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()  # noqa: PLW2901\n        if ref.startswith(\"tag: \"):\n            tag = ref.replace(\"tag: \", \"\")\n            break\n    self.tag: str = tag\n    self.version: str = tag\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_convention","title":"update_with_convention","text":"<pre><code>update_with_convention(\n    convention: CommitConvention,\n) -&gt; None\n</code></pre> <p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>convention</code>             (<code>CommitConvention</code>)         \u2013          <p>The convention to use.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n    \"\"\"Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_provider","title":"update_with_provider","text":"<pre><code>update_with_provider(\n    provider: ProviderRefParser, parse_refs: bool = True\n) -&gt; None\n</code></pre> <p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>provider</code>             (<code>ProviderRefParser</code>)         \u2013          <p>The provider to use.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to parse references for this provider.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_provider(\n    self,\n    provider: ProviderRefParser,\n    parse_refs: bool = True,  # noqa: FBT001,FBT002\n) -&gt; None:\n    \"\"\"Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF:\n            self.text_refs[ref_type] = provider.get_refs(\n                ref_type,\n                \"\\n\".join([self.subject, *self.body]),\n            )\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention","title":"CommitConvention","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a convention of commit messages.</p> <p>Methods:</p> <ul> <li> <code>parse_commit</code>           \u2013            <p>Parse the commit to extract information.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention.parse_commit","title":"parse_commit  <code>abstractmethod</code>","text":"<pre><code>parse_commit(commit: Commit) -&gt; dict[str, str | bool]\n</code></pre> <p>Parse the commit to extract information.</p> <p>Parameters:</p> <ul> <li> <code>commit</code>             (<code>Commit</code>)         \u2013          <p>The commit to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str | bool]</code>         \u2013          <p>A dictionary containing the parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>@abstractmethod\ndef parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:\n    \"\"\"Parse the commit to extract information.\n\n    Arguments:\n        commit: The commit to parse.\n\n    Returns:\n        A dictionary containing the parsed data.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention","title":"ConventionalCommitConvention","text":"<p>             Bases: <code>AngularConvention</code></p> <p>Conventional commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_subject</code>           \u2013            <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"feat\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.parse_subject","title":"parse_subject","text":"<pre><code>parse_subject(commit_subject: str) -&gt; dict[str, str]\n</code></pre> <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>         \u2013          <p>The parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n    \"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The parsed data.\n    \"\"\"\n    subject_match = self.SUBJECT_REGEX.match(commit_subject)\n    if subject_match:\n        dct = subject_match.groupdict()\n        dct[\"type\"] = self.TYPES[dct[\"type\"]]\n        return dct\n    return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n</code></pre>"},{"location":"reference/git_changelog/debug/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> debug","text":""},{"location":"reference/git_changelog/debug/#git_changelog.debug","title":"debug","text":"<p>Debugging utilities.</p> <p>Classes:</p> <ul> <li> <code>Environment</code>         \u2013          <p>Dataclass to store environment information.</p> </li> <li> <code>Package</code>         \u2013          <p>Dataclass describing a Python package.</p> </li> <li> <code>Variable</code>         \u2013          <p>Dataclass describing an environment variable.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_debug_info</code>           \u2013            <p>Get debug/environment information.</p> </li> <li> <code>get_version</code>           \u2013            <p>Get version of the given distribution.</p> </li> <li> <code>print_debug_info</code>           \u2013            <p>Print debug/environment information.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment","title":"Environment  <code>dataclass</code>","text":"<p>Dataclass to store environment information.</p> <p>Attributes:</p> <ul> <li> <code>interpreter_name</code>             (<code>str</code>)         \u2013          <p>Python interpreter name.</p> </li> <li> <code>interpreter_version</code>             (<code>str</code>)         \u2013          <p>Python interpreter version.</p> </li> <li> <code>packages</code>             (<code>list[Package]</code>)         \u2013          <p>Installed packages.</p> </li> <li> <code>platform</code>             (<code>str</code>)         \u2013          <p>Operating System.</p> </li> <li> <code>variables</code>             (<code>list[Variable]</code>)         \u2013          <p>Environment variables.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.interpreter_name","title":"interpreter_name  <code>instance-attribute</code>","text":"<pre><code>interpreter_name: str\n</code></pre> <p>Python interpreter name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.interpreter_version","title":"interpreter_version  <code>instance-attribute</code>","text":"<pre><code>interpreter_version: str\n</code></pre> <p>Python interpreter version.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package]\n</code></pre> <p>Installed packages.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform: str\n</code></pre> <p>Operating System.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.variables","title":"variables  <code>instance-attribute</code>","text":"<pre><code>variables: list[Variable]\n</code></pre> <p>Environment variables.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package","title":"Package  <code>dataclass</code>","text":"<p>Dataclass describing a Python package.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Package name.</p> </li> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>Package version.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Package name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Package version.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable","title":"Variable  <code>dataclass</code>","text":"<p>Dataclass describing an environment variable.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Variable name.</p> </li> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>Variable value.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Variable name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>Variable value.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.get_debug_info","title":"get_debug_info","text":"<pre><code>get_debug_info() -&gt; Environment\n</code></pre> <p>Get debug/environment information.</p> <p>Returns:</p> <ul> <li> <code>Environment</code>         \u2013          <p>Environment information.</p> </li> </ul> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def get_debug_info() -&gt; Environment:\n    \"\"\"Get debug/environment information.\n\n    Returns:\n        Environment information.\n    \"\"\"\n    py_name, py_version = _interpreter_name_version()\n    packages = [\"git-changelog\"]\n    variables = [\"PYTHONPATH\", *[var for var in os.environ if var.startswith(\"GIT_CHANGELOG\")]]\n    return Environment(\n        interpreter_name=py_name,\n        interpreter_version=py_version,\n        platform=platform.platform(),\n        variables=[Variable(var, val) for var in variables if (val := os.getenv(var))],\n        packages=[Package(pkg, get_version(pkg)) for pkg in packages],\n    )\n</code></pre>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.get_version","title":"get_version","text":"<pre><code>get_version(dist: str = 'git-changelog') -&gt; str\n</code></pre> <p>Get version of the given distribution.</p> <p>Parameters:</p> <ul> <li> <code>dist</code>             (<code>str</code>, default:                 <code>'git-changelog'</code> )         \u2013          <p>A distribution name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A version number.</p> </li> </ul> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def get_version(dist: str = \"git-changelog\") -&gt; str:\n    \"\"\"Get version of the given distribution.\n\n    Parameters:\n        dist: A distribution name.\n\n    Returns:\n        A version number.\n    \"\"\"\n    try:\n        return metadata.version(dist)\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.print_debug_info","title":"print_debug_info","text":"<pre><code>print_debug_info() -&gt; None\n</code></pre> <p>Print debug/environment information.</p> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def print_debug_info() -&gt; None:\n    \"\"\"Print debug/environment information.\"\"\"\n    info = get_debug_info()\n    print(f\"- __System__: {info.platform}\")\n    print(f\"- __Python__: {info.interpreter_name} {info.interpreter_version}\")\n    print(\"- __Environment variables__:\")\n    for var in info.variables:\n        print(f\"  - `{var.name}`: `{var.value}`\")\n    print(\"- __Installed packages__:\")\n    for pkg in info.packages:\n        print(f\"  - `{pkg.name}` v{pkg.version}\")\n</code></pre>"},{"location":"reference/git_changelog/providers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> providers","text":""},{"location":"reference/git_changelog/providers/#git_changelog.providers","title":"providers","text":"<p>Module containing the parsing utilities for git providers.</p> <p>Classes:</p> <ul> <li> <code>Bitbucket</code>         \u2013          <p>A parser for the Bitbucket references.</p> </li> <li> <code>GitHub</code>         \u2013          <p>A parser for the GitHub references.</p> </li> <li> <code>GitLab</code>         \u2013          <p>A parser for the GitLab references.</p> </li> <li> <code>ProviderRefParser</code>         \u2013          <p>A base class for specific providers reference parsers.</p> </li> <li> <code>Ref</code>         \u2013          <p>A class to represent a reference and its URL.</p> </li> <li> <code>RefDef</code>         \u2013          <p>A class to store a reference regular expression and URL building string.</p> </li> <li> <code>RefRe</code>         \u2013          <p>An enum helper to store parts of regular expressions for references.</p> </li> </ul>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket","title":"Bitbucket","text":"<pre><code>Bitbucket(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the Bitbucket references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub","title":"GitHub","text":"<pre><code>GitHub(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab","title":"GitLab","text":"<pre><code>GitLab(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser","title":"ProviderRefParser","text":"<pre><code>ProviderRefParser(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>A base class for specific providers reference parsers.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>build_ref_url</code>           \u2013            <p>Build the URL for a reference type and a dictionary of matched groups.</p> </li> <li> <code>get_compare_url</code>           \u2013            <p>Get the URL for a tag comparison.</p> </li> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>get_tag_url</code>           \u2013            <p>Get the URL for a git tag.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.build_ref_url","title":"build_ref_url","text":"<pre><code>build_ref_url(\n    ref_type: str, match_dict: dict[str, str]\n) -&gt; str\n</code></pre> <p>Build the URL for a reference type and a dictionary of matched groups.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>match_dict</code>             (<code>dict[str, str]</code>)         \u2013          <p>The matched groups.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The built URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:\n    \"\"\"Build the URL for a reference type and a dictionary of matched groups.\n\n    Arguments:\n        ref_type: The reference type.\n        match_dict: The matched groups.\n\n    Returns:\n        The built URL.\n    \"\"\"\n    return self.REF[ref_type].url_string.format(**match_dict)\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_compare_url","title":"get_compare_url  <code>abstractmethod</code>","text":"<pre><code>get_compare_url(base: str, target: str) -&gt; str\n</code></pre> <p>Get the URL for a tag comparison.</p> <p>Parameters:</p> <ul> <li> <code>base</code>             (<code>str</code>)         \u2013          <p>The base tag.</p> </li> <li> <code>target</code>             (<code>str</code>)         \u2013          <p>The target tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The comparison URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_compare_url(self, base: str, target: str) -&gt; str:\n    \"\"\"Get the URL for a tag comparison.\n\n    Arguments:\n        base: The base tag.\n        target: The target tag.\n\n    Returns:\n        The comparison URL.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_tag_url","title":"get_tag_url  <code>abstractmethod</code>","text":"<pre><code>get_tag_url(tag: str) -&gt; str\n</code></pre> <p>Get the URL for a git tag.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>             (<code>str</code>)         \u2013          <p>The git tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The tag URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_tag_url(self, tag: str) -&gt; str:\n    \"\"\"Get the URL for a git tag.\n\n    Arguments:\n        tag: The git tag.\n\n    Returns:\n        The tag URL.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref","title":"Ref","text":"<pre><code>Ref(ref: str, url: str)\n</code></pre> <p>A class to represent a reference and its URL.</p> <p>Parameters:</p> <ul> <li> <code>ref</code>             (<code>str</code>)         \u2013          <p>The reference text.</p> </li> <li> <code>url</code>             (<code>str</code>)         \u2013          <p>The reference URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, ref: str, url: str) -&gt; None:\n    \"\"\"Initialization method.\n\n    Arguments:\n        ref: The reference text.\n        url: The reference URL.\n    \"\"\"\n    self.ref: str = ref\n    self.url: str = url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef","title":"RefDef","text":"<pre><code>RefDef(regex: Pattern, url_string: str)\n</code></pre> <p>A class to store a reference regular expression and URL building string.</p> <p>Parameters:</p> <ul> <li> <code>regex</code>             (<code>Pattern</code>)         \u2013          <p>The regular expression to match the reference.</p> </li> <li> <code>url_string</code>             (<code>str</code>)         \u2013          <p>The URL string to format using matched groups.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, regex: Pattern, url_string: str):\n    \"\"\"Initialization method.\n\n    Arguments:\n        regex: The regular expression to match the reference.\n        url_string: The URL string to format using matched groups.\n    \"\"\"\n    self.regex = regex\n    self.url_string = url_string\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefRe","title":"RefRe","text":"<p>An enum helper to store parts of regular expressions for references.</p>"},{"location":"reference/git_changelog/templates/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> templates","text":""},{"location":"reference/git_changelog/templates/#git_changelog.templates","title":"templates","text":"<p>The subpackage containing the builtin templates.</p> <p>Functions:</p> <ul> <li> <code>configure_env</code>           \u2013            <p>Configure the Jinja environment.</p> </li> <li> <code>get_custom_template</code>           \u2013            <p>Get a custom template instance.</p> </li> <li> <code>get_template</code>           \u2013            <p>Get a builtin template instance.</p> </li> </ul>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.configure_env","title":"configure_env","text":"<pre><code>configure_env(env: Environment) -&gt; None\n</code></pre> <p>Configure the Jinja environment.</p> <p>Parameters:</p> <ul> <li> <code>env</code>             (<code>Environment</code>)         \u2013          <p>The environment to configure.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def configure_env(env: Environment) -&gt; None:\n    \"\"\"Configure the Jinja environment.\n\n    Parameters:\n        env: The environment to configure.\n    \"\"\"\n    env.filters.update({\"is_url\": _filter_is_url})\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_custom_template","title":"get_custom_template","text":"<pre><code>get_custom_template(path: str | Path) -&gt; Template\n</code></pre> <p>Get a custom template instance.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the custom template.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Template</code>         \u2013          <p>The Jinja template.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def get_custom_template(path: str | Path) -&gt; Template:\n    \"\"\"Get a custom template instance.\n\n    Arguments:\n        path: Path to the custom template.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(Path(path).read_text())\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_template","title":"get_template","text":"<pre><code>get_template(name: str) -&gt; Template\n</code></pre> <p>Get a builtin template instance.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The template name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Template</code>         \u2013          <p>The Jinja template.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def get_template(name: str) -&gt; Template:\n    \"\"\"Get a builtin template instance.\n\n    Arguments:\n        name: The template name.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(TEMPLATES_PATH.joinpath(f\"{name}.md.jinja\").read_text())\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}