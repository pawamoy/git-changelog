{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"git-changelog","text":"<p>Automatic Changelog generator using Jinja2 templates. From git logs to change logs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Jinja2 templates!   You get full control over the rendering.   Built-in Keep a Changelog and Angular templates   (also see Conventional Changelog).</li> <li>Commit styles/conventions parsing.   Built-in Angular, Conventional Commit, Atom and basic conventions.</li> <li>Git service/provider agnostic,   plus references parsing (issues, commits, etc.).   Built-in GitHub and Gitlab support.</li> <li>Understands Semantic Versioning:   major/minor/patch for versions and commits.   Guesses next version based on last commits.</li> <li> <p>Parses Git trailers, allowing to reference   issues, PRs, etc., in your commit messages   in a clean, provider-agnostic way.</p> </li> <li> <p>Todo:</p> <ul> <li>Plugin architecture,   to support more commit conventions and git services.</li> <li>Template context injection,   to furthermore customize how your changelog will be rendered.</li> <li>Easy access to \"Breaking Changes\" in the templates.</li> <li>Commits/dates/versions range limitation ability.</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install git-changelog\n</code></pre></p> <p>With <code>pipx</code>: <pre><code>python3.7 -m pip install --user pipx\npipx install git-changelog\n</code></pre></p>"},{"location":"#usage-command-line","title":"Usage (command-line)","text":"<pre><code>usage: git-changelog [-b] [-h] [-i] [-g VERSION_REGEX] [-m MARKER_LINE]\n                     [-o OUTPUT] [-R] [-c {angular,atom,conventional,basic}]\n                     [-S SECTIONS [SECTIONS ...]]\n                     [-t {angular,keepachangelog}] [-T] [-v]\n                     [REPOSITORY]\n\nAutomatic Changelog generator using Jinja2 templates.\n\nThis tool parses your commit messages to extract useful data\nthat is then rendered using Jinja2 templates, for example to\na changelog file formatted in Markdown.\n\nEach Git tag will be treated as a version of your project.\nEach version contains a set of commits, and will be an entry\nin your changelog. Commits in each version will be grouped\nby sections, depending on the commit convention you follow.\n\nBASIC CONVENTION\n\nDefault sections:\n- add: Added\n- fix: Fixed\n- change: Changed\n- remove: Removed\n\nAdditional sections:\n- merge: Merged\n- doc: Documented\n\nANGULAR CONVENTION\n\nDefault sections:\n- feat: Features\n- fix: Bug Fixes\n- revert: Reverts\n- ref, refactor: Code Refactoring\n- perf: Performance Improvements\n\nAdditional sections:\n- build: Build\n- chore: Chore\n- ci: Continuous Integration\n- deps: Dependencies\n- doc, docs: Docs\n- style: Style\n- test, tests: Tests\n\nCONVENTIONALCOMMIT CONVENTION\n\nDefault sections:\n- feat: Features\n- fix: Bug Fixes\n- revert: Reverts\n- ref, refactor: Code Refactoring\n- perf: Performance Improvements\n\nAdditional sections:\n- build: Build\n- chore: Chore\n- ci: Continuous Integration\n- deps: Dependencies\n- doc, docs: Docs\n- style: Style\n- test, tests: Tests\n\npositional arguments:\n  REPOSITORY            The repository path, relative or absolute.\n\noptions:\n  -b, --bump            Guess the new latest version by bumping the previous\n                        one based on the set of unreleased commits. For\n                        example, if a commit contains breaking changes, bump\n                        the major number (or the minor number for 0.x\n                        versions). Else if there are new features, bump the\n                        minor number. Else just bump the patch number.\n  -h, --help            Show this help message and exit.\n  -i, --in-place        Insert new entries (versions missing from changelog)\n                        in-place. An output file must be specified. With\n                        custom templates, you can pass two additional\n                        arguments: --version-regex and --marker-line. When\n                        writing in-place, an 'in_place' variable will be\n                        injected in the Jinja context, allowing to adapt the\n                        generated contents (for example to skip changelog\n                        headers or footers).\n  -g, --version-regex VERSION_REGEX\n                        A regular expression to match versions in the existing\n                        changelog (used to find the latest release) when\n                        writing in-place. The regular expression must be a\n                        Python regex with a 'version' named group.\n  -m, --marker-line MARKER_LINE\n                        A marker line at which to insert new entries (versions\n                        missing from changelog). If two marker lines are\n                        present in the changelog, the contents between those\n                        two lines will be overwritten (useful to update an\n                        'Unreleased' entry for example).\n  -o OUTPUT, --output OUTPUT\n                        Output to given file. Default: stdout.\n  -r, --parse-refs      Parse provider-specific references in commit\n                        messages (GitHub/GitLab issues, PRs, etc.).\n  -c, -s, --style, --commit-style,  --convention {angular,atom,conventional,basic}\n                        The commit convention to match against. Default: basic.\n  -S, --sections SECTIONS [SECTIONS ...]\n                        The sections to render. See the available sections for\n                        each supported convention in the description.\n  -t, --template {angular,keepachangelog}\n                        The Jinja2 template to use. Prefix with \"path:\" to\n                        specify the path to a directory containing a file\n                        named \"changelog.md\".\n  -T, --trailers, --git-trailers\n                        Parse Git trailers in the commit message. See\n                        https://git-scm.com/docs/git-interpret-trailers.\n  -v, --version         Show the current version of the program and exit.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#100-2023-02-04","title":"1.0.0 - 2023-02-04","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<p>This version brings a lot of new features, so I took this opportunity to break things, allowing to clean things up, and to bump to version 1.0.0.</p> <ul> <li>New version is not automatically guessed anymore (by bumping latest version).     Enable it again with the <code>--bump-latest</code> CLI option.</li> <li>Provider-specific references are not parsed by default anymore.     Parse them again with the <code>--parse-refs</code> CLI option.</li> <li>The commit convention cannot be passed with the <code>-s</code> CLI option anymore.     This option is now used for declaring sections. Use <code>-c</code> instead.     See usage.</li> <li>Rename Python objects by replacing occurrences of \"style\" by \"convention\" everywhere.</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<p>Lots of new features! Usage is documented here: https://pawamoy.github.io/git-changelog/usage/.</p> <ul> <li>Support updating changelog in-place (18029cd by Timoth\u00e9e Mazzucotelli). Issue #15</li> <li>Better handle single, initial versions (4c6ecf5 by Timoth\u00e9e Mazzucotelli).</li> <li>Use current directory by default (d50d0b1 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow choosing whether to guess new version by bumping latest (85c04fd by Timoth\u00e9e Mazzucotelli).</li> <li>Support Git trailers, render them in Keep A Changelog template (cdf17c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Disable parsing of provider-specific references by default, allow enabling it (cf41a97 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Clean up body to fix parsing trailers (1183c25 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix building commit body (f76bf32 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix spacing in keepachangelog templates (cf5117a by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash when trying to parse the latest tag as semver (e90aa2b by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: don't capitalize commit summary (87348ed by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: respect sections order (don't sort) (f645e62 by Timoth\u00e9e Mazzucotelli).</li> <li>Use <code>importlib.metadata</code> instead of <code>pkg_resources</code> to get current version (79109d0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Allow passing sections with <code>-s</code> CLI option (removed from commit convention option) (a1ae778 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename 'style' to 'convention' everywhere (c454481 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>inplace</code> variable to <code>in_place</code> (7a271ef by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI: all flags default to false (9616bdd by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI for better library usage (43ec5d1 by Timoth\u00e9e Mazzucotelli).</li> <li>Make changelog methods private (0b4bbc0 by Timoth\u00e9e Mazzucotelli).</li> <li>Expose <code>Changelog</code> and <code>Commit</code> from <code>git_changelog</code> (d3dca05 by Timoth\u00e9e Mazzucotelli).</li> <li>Detect more commit types (Karma/Angular), rework section titles (f751736 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing datetimes, UTC timestamps as strings, or nothing when creating commit (34460ab by Timoth\u00e9e Mazzucotelli).</li> <li>Build body before instantiating commit (37de53f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#060-2022-10-26","title":"0.6.0 - 2022-10-26","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add GIT_CHANGELOG_REMOTE variable (9b9b3fc by Luk\u00e1\u0161 Zapletal). PR #35</li> </ul>"},{"location":"changelog/#050-2021-11-14","title":"0.5.0 - 2021-11-14","text":"<p>Compare with 0.4.2</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Accept Jinja2 3.x (9ef3259 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Allow to choose conventional style from CLI (aafa779 by Ivan Gonzalez). PR #32</li> <li>Add ConventionalCommit commit type (3becce8 by Kevin Squire). PR #30</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Properly bump semver version (ecc7dd4 by Kevin Squire). References: #31</li> <li>Fix typo in keepachangelog template (fa9b434 by Alexander Schleifer). PR #28</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Use semver to bump version more reliably (b68a565 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#042-2021-01-06","title":"0.4.2 - 2021-01-06","text":"<p>Compare with 0.4.1</p>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Handle prerelease tags better (4bcc451 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#041-2020-12-21","title":"0.4.1 - 2020-12-21","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Fix wrong version being printed (0ec050f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#040-2020-05-21","title":"0.4.0 - 2020-05-21","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Use actual url for references (46a8790 by Timoth\u00e9e Mazzucotelli).</li> <li>Use style subject if possible (7f2c3ad by Timoth\u00e9e Mazzucotelli).</li> <li>Correctly handle nested subgroups for gitlab repos (8ca990b by Timoth\u00e9e Mazzucotelli).</li> <li>Fix bumping versions starting with \"v\" (44e7644 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Move styles into new commit module to avoid cyclic dependencies (d90bd15 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Improve changelog rendering (e9dd3f4 by Timoth\u00e9e Mazzucotelli).<ul> <li>Use today's date for current version</li> <li>Move \"compare\" link below the heading (better table of contents in documentation)</li> <li>Improve \"compare\" links to handle first and current version</li> <li>Use selected commit types to render sections</li> </ul> </li> <li>Add default commit types to render variable (173392a by Timoth\u00e9e Mazzucotelli).</li> <li>Always use today's date for unreleased version (1c34fa8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#030-2020-03-31","title":"0.3.0 - 2020-03-31","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Fix <code>is_minor</code> method for version (6d08978 by Lo\u00efc Viennois).</li> <li>Fix <code>parse_refs</code> method for <code>ProviderRefParser</code> (dc51589 by Lo\u00efc Viennois).</li> <li>Correctly detect major version, for both angular style and basic style (7385e19 by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Add type hints to all classes and methods (95276ef by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Update template <code>keepachangelog</code> (ce76ed6) by RainChen:<ul> <li>Capitalize commit subject</li> <li>Show author name for each commit</li> <li>Sort commits by date</li> <li>Unique commit subjects</li> </ul> </li> </ul>"},{"location":"changelog/#020-2019-11-24","title":"0.2.0 - 2019-11-24","text":"<p>Compare with 0.1.1</p> <p>Drop support for Python &lt; 3.6.</p> <p>Use poetry to manage the project!</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix detection of feature (is_minor) for angular style (4fbf0ee).</li> </ul>"},{"location":"changelog/#011-2018-06-27","title":"0.1.1 - 2018-06-27","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix build with MANIFEST.in, add license file (013fb69).</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Improve readability (5e590f6).</li> </ul>"},{"location":"changelog/#010-2018-06-27","title":"0.1.0 - 2018-06-27","text":"<p>Compare with first commit</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add github/github regexes (584fd73).</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix patch bump (8470e69).</li> <li>Fix refs parsing (8c77cb7).</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Continue packaging (#6) (a29af2c).</li> <li>Finish packaging (#6) (e92b492).</li> <li>Implement reference parsing (a9b4a89).</li> <li>Improve angular template, improve style/refs system (5b87d48).</li> <li>Initial commit (83845fe).</li> <li>Package code (#6) (1219eaf).</li> <li>Update changelog for version 0.1.0 (14edcaf).</li> <li>Update changelog for version 0.1.0 (610633d).</li> <li>Update changelog for version 0.1.0 (2eaaa2e).</li> <li>Work in progress (27a60e8).</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd git-changelog\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install pdm\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>pdm install</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>pdm run git-changelog [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following:</p> <ol> <li><code>export PYTHON_VERSIONS=</code>: this will run the task    with only the current Python version</li> <li>run the task directly with <code>pdm run duty TASK</code></li> </ol> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git checkout -b feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs-serve</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commits messages must follow the Angular style:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes which are not features nor bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end:</p> <pre><code>Body.\n\nReferences: #10, #11.\nFixes #15.\n</code></pre>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash master\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":"<p>These projects were used to build <code>git-changelog</code>. Thank you!</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p>"},{"location":"credits/#exec-0--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>importlib-metadata</code> Read metadata from Python packages <code>; python_version &lt; '3.8'</code> <code>4.13.0</code> Apache Software License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.10,&lt;4</code> <code>3.1.2</code> BSD-3-Clause <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.2</code> BSD-3-Clause <code>semver</code> Python helper for Semantic Versioning (http://semver.org/) <code>~=2.13</code> <code>2.13.0</code> BSD <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=3.6.4; python_version &lt; \"3.8\"</code> <code>4.4.0</code> Python Software Foundation License <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.12.0</code> MIT License"},{"location":"credits/#exec-0--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>astor</code> Read/rewrite/write Python ASTs <code>&gt;=0.8</code> <code>0.8.1</code> BSD-3-Clause <code>attrs</code> Classes Without Boilerplate <code>&gt;=19.2.0</code> <code>22.2.0</code> MIT <code>autoflake</code> Removes unused imports and unused variables <code>&gt;=1.4</code> <code>1.7.8</code> MIT <code>bandit</code> Security oriented static analyser for python code. <code>&gt;=1.7.3</code> <code>1.7.4</code> Apache-2.0 license <code>black</code> The uncompromising code formatter. <code>&gt;=21.10b0</code> <code>23.1.0</code> MIT <code>cached-property</code> A decorator for caching properties in classes. <code>~=1.5; python_version &lt; \"3.8\"</code> <code>1.5.2</code> BSD <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2022.12.7</code> MPL-2.0 <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.0.1</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.3</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>[toml]&gt;=5.2.1</code> <code>7.1.0</code> Apache-2.0 <code>darglint</code> A utility for ensuring Google-style docstrings stay up to date with the source code. <code>&gt;=1.8</code> <code>1.8.1</code> MIT <code>dparse</code> A parser for Python dependency files <code>&gt;=0.6.2</code> <code>0.6.2</code> MIT license <code>duty</code> A simple task runner. <code>&gt;=0.7</code> <code>0.7.0</code> ISC <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.0</code> MIT License <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>1.9.0</code> MIT <code>failprint</code> Run a command, print its output only if it fails. <code>~=0.8</code> <code>0.8.0</code> ISC <code>flake8</code> the modular source code checker: pep8 pyflakes and co <code>&gt;=4; python_version &gt;= '3.8'</code> <code>5.0.4</code> MIT <code>flake8-bandit</code> Automated security testing with bandit and flake8. <code>&gt;=2.1</code> <code>4.1.1</code> MIT <code>flake8-black</code> flake8 plugin to call black as a code style validator <code>&gt;=0.2</code> <code>0.3.6</code> MIT <code>flake8-bugbear</code> A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. <code>&gt;=21.9</code> <code>23.1.20</code> MIT <code>flake8-builtins</code> Check for python builtins being used as variables or parameters. <code>&gt;=1.5</code> <code>2.1.0</code> GPL version 2 <code>flake8-comprehensions</code> A flake8 plugin to help you write better list/set/dict comprehensions. <code>&gt;=3.7</code> <code>3.10.1</code> MIT <code>flake8-docstrings</code> Extension for flake8 which uses pydocstyle to check docstrings <code>&gt;=1.6</code> <code>1.7.0</code> MIT <code>flake8-plugin-utils</code> The package provides base classes and utils for flake8 plugin writing <code>&lt;2.0.0,&gt;=1.3.2</code> <code>1.3.2</code> MIT <code>flake8-polyfill</code> Polyfill package for Flake8 plugins <code>&gt;=1.0.2</code> <code>1.0.2</code> MIT <code>flake8-pytest-style</code> A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. <code>&gt;=1.5</code> <code>1.6.0</code> MIT <code>flake8-string-format</code> string format checker, plugin for flake8 <code>&gt;=0.3</code> <code>0.3.0</code> MIT License <code>flake8-tidy-imports</code> A flake8 plugin that helps you write tidier imports. <code>&gt;=4.5</code> <code>4.8.0</code> MIT <code>flake8-variables-names</code> A flake8 extension that helps to make more readable variables names <code>&gt;=0.0</code> <code>0.0.5</code> MIT <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a python library used to interact with Git repositories <code>&gt;=1.0.1</code> <code>3.1.30</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.24</code> <code>0.25.4</code> ISC <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&lt;5; python_version &lt; '3.8'</code> <code>4.13.0</code> Apache Software License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>isort</code> A Python utility / library to sort Python imports. <code>&gt;=5.10</code> <code>5.11.5</code> MIT <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.2</code> BSD-3-Clause <code>markdown</code> Python implementation of Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.3.7</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.2</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=0.5</code> <code>1.2.0</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.2</code> BSD-3-Clause <code>mccabe</code> McCabe checker, plugin for flake8 <code>&lt;0.8.0,&gt;=0.7.0</code> <code>0.7.0</code> Expat license <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.3</code> <code>1.4.2</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=0.2</code> <code>0.2.6</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.3</code> <code>0.4.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.4</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=7.3</code> <code>9.0.11</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-section-index</code> MkDocs plugin to allow clickable sections that lead to an index page <code>&gt;=0.3</code> <code>0.3.5</code> MIT License <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.18</code> <code>0.20.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>0.8.3</code> ISC <code>mypy</code> Optional static typing for Python <code>&gt;=0.910</code> <code>0.991</code> MIT License <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.0.0</code> MIT License <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>23.0</code> BSD License <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.11.0</code> Mozilla Public License 2.0 (MPL 2.0) <code>pbr</code> Python Build Reasonableness <code>!=2.1.0,&gt;=2.0.0</code> <code>5.11.1</code> Apache Software License <code>pep8-naming</code> Check PEP-8 naming conventions, plugin for flake8 <code>&gt;=0.12</code> <code>0.13.3</code> Expat license <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2</code> <code>2.6.2</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.0.0</code> MIT <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ISC License (ISCL) <code>pycodestyle</code> Python style guide checker <code>&lt;2.10.0,&gt;=2.9.0</code> <code>2.9.1</code> Expat license <code>pydocstyle</code> Python docstring style checker <code>&gt;=2.1</code> <code>6.3.0</code> MIT <code>pyflakes</code> passive checker of Python programs <code>&lt;3,&gt;=1.1.0</code> <code>2.5.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.14</code> <code>2.14.0</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>9.9.2</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;=6.2</code> <code>7.2.1</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;=3.0</code> <code>4.0.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.10</code> <code>3.12.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=2.4</code> <code>3.1.0</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2022.10.31</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>&gt;=2.26</code> <code>2.28.2</code> Apache 2.0 <code>ruamel.yaml</code> ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order <code>&gt;=0.17.21</code> <code>0.17.21</code> MIT license <code>ruamel.yaml.clib</code> C version of reader, parser and emitter for ruamel.yaml derived from libyaml <code>&gt;=0.2.6; platform_python_implementation == \"CPython\" and python_version &lt; \"3.11\"</code> <code>0.2.7</code> MIT <code>safety</code> Checks installed dependencies for known vulnerabilities and licenses. <code>&gt;=2</code> <code>2.3.4</code> MIT license <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>&gt;=19.3</code> <code>67.1.0</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.0</code> BSD <code>snowballstemmer</code> This package provides 29 stemmers for 28 languages generated from Snowball algorithms. <code>&gt;=2.2.0</code> <code>2.2.0</code> BSD-3-Clause <code>stevedore</code> Manage dynamic plugins for Python applications <code>&gt;=1.20.0</code> <code>3.5.2</code> Apache Software License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;=0.10</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>&gt;=2.0.1; python_version &lt; \"3.11\"</code> <code>2.0.1</code> MIT License <code>typed-ast</code> a fork of Python 2 and 3 ast modules with type comment support <code>&gt;=1.4.2; python_version &lt; \"3.8\" and implementation_name == \"cpython\"</code> <code>1.5.4</code> Apache License 2.0 <code>types-docutils</code> Typing stubs for docutils <code>0.19.1.2</code> Apache-2.0 license <code>types-markdown</code> Typing stubs for Markdown <code>&gt;=3.3</code> <code>3.4.2.2</code> Apache-2.0 license <code>types-setuptools</code> Typing stubs for setuptools <code>&gt;=65.5.0.2</code> <code>67.1.0.0</code> Apache-2.0 license <code>types-toml</code> Typing stubs for toml <code>&gt;=0.10</code> <code>0.10.8.2</code> Apache-2.0 license <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=3.10.0.0; python_version &lt; \"3.10\"</code> <code>4.4.0</code> Python Software Foundation License <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;1.27,&gt;=1.21.1</code> <code>1.26.14</code> MIT <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>2.2.1</code> Apache License 2.0 <code>wps-light</code> The strictest and most opinionated python linter ever (lighter fork). <code>&gt;=0.15</code> <code>0.16.1</code> MIT <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.12.0</code> MIT License <p>More credits from the author</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2018, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>git-changelog parses your commit messages to extract useful data that is then rendered using Jinja2 templates, for example to a changelog file formatted in Markdown.</p> <p>Each Git tag will be treated as a version of your project. Each version contains a set of commits, and will be an entry in your changelog. Commits in each version will be grouped by sections, depending on the commit coonvention you follow.</p>"},{"location":"usage/#quick-usage","title":"Quick usage","text":"<p>Print the changelog on standard output, using the basic convention for commit messages and the Angular template:</p> <pre><code>git-changelog -c basic -t angular\n</code></pre> <p>Update a changelog in-place, overwriting and updating the \"Unreleased\" section, using the Angular commit message convention and the Keep A Changelog template (default):</p> <pre><code>git-changelog -io CHANGELOG.md -c angular  </code></pre> <p>Same thing, but now you're ready to tag so you tell git-changelog to guess the new version by bumping the latest version based on the semantics of your commits:</p> <pre><code>git-changelog -bio CHANGELOG.md -c angular\n</code></pre> <p>Same thing, but also parse Git trailers and choose the sections to render, and their order (author's favorite!):</p> <pre><code>git-changelog -Tbio CHANGELOG.md -c angular -s build,deps,fix,feat,refactor\n</code></pre> <p>Generate a changelog using a custom template, and parsing provider-specific references (GitHub/GitLab):</p> <pre><code>git-changelog -rt path:./templates/changelog.md.jinja </code></pre> <p>Author's favorite, from Python:</p> <pre><code>from git_changelog.cli import build_and_render\n\nbuild_and_render(\n    repository=\".\",\n    output=\"CHANGELOG.md\",\n    convention=\"angular\",\n    template=\"keepachangelog\",\n    parse_trailers=True,\n    parse_refs=False,\n    sections=(\"build\", \"deps\", \"feat\", \"fix\", \"refactor\"),\n    bump_latest=True,\n    in_place=True,\n)\n</code></pre> <p>The following sections explain in more details all the features of git-changelog.</p>"},{"location":"usage/#output-a-changelog","title":"Output a changelog","text":"<p>To output a changelog for the current repository (current directory), simply run:</p> <pre><code>git-changelog\n</code></pre> <p>To output a changelog for another repository (directory), pass the path to that repository:</p> <pre><code>git-changelog /path/to/my/repo\n</code></pre> <p>By default, git-changelog will parse commit messages as if they use the \"basic\" convention, and render a Keep A Changelog-formatted changelog writing to the standard output.</p> <p>To write to a file instead, use the <code>-o</code> or <code>--output</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md\n</code></pre>"},{"location":"usage/#choose-the-commit-message-convention","title":"Choose the commit message convention","text":"<p>Different conventions, or styles, are supported by git-changelog. To select a different convention than the default one (basic, see below), use the <code>-c</code> or <code>--convention</code> CLI option:</p> <pre><code>git-changelog --convention angular\n</code></pre>"},{"location":"usage/#basic-convention","title":"Basic convention","text":"<p>The basic convention, as the name implies, is very simple. If a commit message summary (the first line of the message) with a particular word/prefix (case-insensitive), it is added to the corresponding section:</p> Type Section <code>add</code> Added <code>fix</code> Fixed <code>change</code> Changed <code>remove</code> Removed <code>merge</code> Merged <code>doc</code> Documented"},{"location":"usage/#angularkarma-convention","title":"Angular/Karma convention","text":"<p>The Angular/Karma convention initiated the Conventional Commit specification. It expects the following format for commit messages:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>The types and corresponding sections git-changelog recognizes are:</p> Type Section <code>build</code> Build <code>chore</code> Chore <code>ci</code> Continuous Integration <code>deps</code> Dependencies <code>doc(s)</code> Docs <code>feat</code> Features <code>fix</code> Bug Fixes <code>perf</code> Performance Improvements <code>ref(actor)</code> Code Refactoring <code>revert</code> Reverts <code>style</code> Style <code>test(s)</code> Tests <p>Breaking changes are detected by searching for <code>^break(s|ing changes?)?[ :]</code> in the commit message body.</p>"},{"location":"usage/#conventional-commit-convention","title":"Conventional Commit convention","text":"<p>The Conventional Commit specification originates from the Angular commit message convention. It's basically the same thing, but only the <code>feat</code> and <code>fix</code> types are specified, and the rest is up to you. In git-changelog though, it is equivalent to the Angular convention, with an additional thing: it detects breaking changes when <code>!</code> appears right before the colon in the message summary (for example: <code>refactor!: Stuff</code>).</p>"},{"location":"usage/#choose-the-sections-to-render","title":"Choose the sections to render","text":"<p>Each commit message convention has a default set of sections that will be rendered in the output. The other sections will be ignored. To override this, you can provide a list of sections to render to git-changelog with the <code>-s</code> or <code>--sections</code> CLI option:</p> <pre><code># with the basic convention\ngit-changelog --sections add,fix,remove,doc\n\n# with the angular/karma/conventionalcommit convention\ngit-changelog --sections build,deps,feat,fix,refactor\n</code></pre> <p>See the previous paragraphs to get the list of available sections for each commit message convetions.</p>"},{"location":"usage/#choose-a-changelog-template","title":"Choose a changelog template","text":"<p>git-changelog provides two built-in templates: <code>keepachangelog</code> and <code>angular</code>. Both are very similar, they just differ with the formatting a bit. We stronly recommend the <code>keepachangelog</code> format.</p> <p>You can also write and use your own changelog templates. Templates are single files written using the Jinja templating engine. You can get inspiration from the source of our built-in templates.</p>"},{"location":"usage/#understand-the-relationship-with-semver","title":"Understand the relationship with SemVer","text":"<p>Semver, or Semantic Versioning, helps users of tools and libraries understand the impact of version changes. To quote SemVer itself:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards compatible manner</li> <li>PATCH version when you make backwards compatible bug fixes</li> </ol> <p>Thanks to the SemVer specification and the commit message conventions, git-changelog is able to guess the new version your project is supposed to take given a set of untagged commits (commits more recent than the latest tag). An \"Added\" (basic convention) or \"feat\" (Angular/Karma/ConventionalCommit) commit will bump the MINOR part of the latest tag. Other types will bump the PATCH part. Commits containing breaking changes will bump the MAJOR part, unless MAJOR is 0, in which case they'll only bump the MINOR part.</p> <p>To tell git-changelog to try and guess the new version, use the <code>-b</code> or <code>--bump-latest</code> CLI option:</p> <pre><code>git-changelog --bump\n</code></pre>"},{"location":"usage/#parse-additional-information-in-commit-messages","title":"Parse additional information in commit messages","text":"<p>git-changelog is able to parse the body of commit messages to find additional information.</p>"},{"location":"usage/#provider-specific-references","title":"Provider-specific references","text":"<p>git-changelog will detect when you are using GitHub or GitLab by checking the <code>origin</code> remote configured in your local clone (or the remote indicated by the value of the <code>GIT_CHANGELOG_REMOTE</code> environment variable).</p> <p>Detecting the provider allows git-changelog to build URLs to specific commits and tags. But it also allows it to parse text references understood by these providers in the commit messages. For example: #18 (issue) or a78bcf2e (commit hash). These references are then available when rendering the changelog template, allowing to add links to issues, pull requests, users, etc.</p> <p>Example of a commit message with GitLab references:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14.\nFollow-up of MR !7.\nPart of milestone %2.\n</code></pre> <p>To enable provider-specific reference parsing, use the <code>-r</code> or <code>--parse-refs</code> CLI option:</p> <pre><code>git-changelog --parse-refs\n</code></pre> <p>Provider-references are a bit limited, difficult to parse and favor vendor lock-in, so for these reasons we do not recommend them. Instead, we recommend using Git trailers.</p>"},{"location":"usage/#git-trailers","title":"Git trailers","text":"<p>Git has an <code>interpret-trailers</code> command that allows to add or parse trailers line to commit messages. Trailers line are located in the footer of commit message: there must be a blank line between the body and the first trailer. Each trailer is a line of the form <code>token: value</code>, for example <code>Co-authored-by: Timoth\u00e9e Mazzucotelli &lt;pawamoy@pm.me&gt;</code>.</p> <p>The tokens are specified not to allow whitespace in them, but git-changelog takes the liberty to lift up this limitation for convenience. It means you can write <code>Issue 18: https://...</code> instead of <code>Issue-18: https://...</code>. The first colon + space (<code>:</code>) delimitate the token and value.</p> <p>Example of a commit message with Git trailers:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14: https://github.com/super/repo/issues/14\nFollow-up of PR #7: https://github.com/super/repo/pull/7\nPart of epic #5: https://agile-software.com/super/project/epics/5\n</code></pre> <p>As you can see, compared to provider-specific references, trailers are written out explicitely, so it's a bit more work, but this ensures your changelog can be rendered correctly anywhere, not just on GitHub or GitLab, and without pre/post-processing.</p> <p>Trailers are rendered in the Keep A Changelog template. If the value is an URL, a link is created with the token as title. If not, the trailer is written as is.</p> <p>Example of how the previous trailers are rendered:</p> <pre><code>- Fix atrocious bug ([aafa779](https://github.com/super/repo/commit/aafa7793ec02a) by John Doe).\n    [Fixes issue #14](https://github.com/super/repo/issues/14),\n    [Follow-up of PR #7](https://github.com/super/repo/pull/7),\n    [Part of epic #5](https://agile-software.com/super/project/epics/5),\n</code></pre> <ul> <li>Fix atrocious bug (aafa779 by John Doe).     Fixes issue #14,     Follow-up of PR #7,     Part of epic #5,</li> </ul> <p>To enable Git trailers parsing, use the <code>-T</code> or <code>--parse-trailers</code> CLI option:</p> <pre><code>git-changelog --parse-trailers\n</code></pre>"},{"location":"usage/#update-changelog-in-place","title":"Update changelog in place","text":"<p>Writing the whole generated changelog to a file is nice, but sometimes you need to tweak the entries in your changelog and you don't want to overwrite these slight modifications each time your regenerate your changelog.</p> <p>For this reason, git-changelog is able to update a changelog file in-place. It means that it will only insert new entries at the top of the changelog, without modifying existing ones.</p> <p>To update a changelog in-place, use the <code>-i</code> or <code>--in-place</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place\n</code></pre> <p>To achieve this, git-changelog searches for versions (entries) already written to the changelog with a regular expression. The verions that are not found in the changelog will be added at the top. To know where to add them exactly, we search for a marker line in the changelog. This marker line is an HTML comment: it is not visible when the changelog is displayed in web pages.</p> <p>To support in-place updates in a custom template, you have two choices:</p> <ol> <li> <p>format versions in your template so they match the default regular expression,     and use the default marker line(s) to tell git-changelog where     to insert new entries. Here are these default values:</p> <pre><code>DEFAULT_VERSION_REGEX = r\"^## \\[v?(?P&lt;version&gt;[^\\]]+)\"\nDEFAULT_MARKER_LINE = \"&lt;!-- insertion marker --&gt;\"\n</code></pre> </li> <li> <p>provide a custom regular expression and marker line,     to match the contents of your custom template,     with the <code>-g</code> or <code>--version-regex</code>, and <code>-m</code> or <code>--marker-line</code> CLI options:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place \\\n--version-regex '&lt;a href=\"[^\"]+\"&gt;(?P&lt;version&gt;[^&lt;]+)' \\\n--marker-line '&lt;!-- new entries will be injected here --&gt;'\n</code></pre> </li> </ol> <p>When only one marker line is found in the template, new entries are inserted at this line exactly, overwriting it (but the marker is added again by the new entries themselves).</p> <p>When two marker lines are found, new entries are applied between those two lines, overwriting the previous contents. This is useful when you don't tell git-changelog to bump the latest version: you will have an \"Unreleased\" section that is overwritten and updated each time you update your changelog in-place.</p>"},{"location":"reference/git_changelog/","title":"git_changelog","text":"<p>git-changelog package.</p> <p>Automatic Changelog generator using Jinja2 templates.</p>"},{"location":"reference/git_changelog/#git_changelog.Changelog","title":"<code>Changelog</code>","text":"<p>The main changelog class.</p> Source code in <code>git_changelog/build.py</code> <pre><code>class Changelog:\n\"\"\"The main changelog class.\"\"\"\n\n    MARKER: str = \"--GIT-CHANGELOG MARKER--\"\n    FORMAT: str = (\n        r\"%H%n\"  # commit commit_hash  # noqa: WPS323\n        r\"%an%n\"  # author name\n        r\"%ae%n\"  # author email\n        r\"%ad%n\"  # author date\n        r\"%cn%n\"  # committer name\n        r\"%ce%n\"  # committer email\n        r\"%cd%n\"  # committer date\n        r\"%D%n\"  # tag\n        r\"%s%n\"  # subject\n        r\"%b%n\" + MARKER  # body\n    )\n    CONVENTION: dict[str, Type[CommitConvention]] = {\n        \"basic\": BasicConvention,\n        \"angular\": AngularConvention,\n        \"atom\": AtomConvention,\n        \"conventional\": ConventionalCommitConvention,\n    }\n\n    def __init__(  # noqa: WPS231\n        self,\n        repository: str | Path,\n        provider: ProviderRefParser | None = None,\n        convention: ConventionType | None = None,\n        parse_provider_refs: bool = False,\n        parse_trailers: bool = False,\n        sections: list[str] | None = None,\n        bump_latest: bool = False,\n    ):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            repository: The repository (directory) for which to build the changelog.\n            provider: The provider to use (github.com, gitlab.com, etc.).\n            convention: The commit convention to use (angular, atom, etc.).\n            parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n            parse_trailers: Whether to parse Git trailers in the commit messages.\n            sections: The sections to render (features, bug fixes, etc.).\n            bump_latest: Whether to try and bump latest version to guess new one.\n        \"\"\"\n        self.repository: str | Path = repository\n        self.parse_provider_refs: bool = parse_provider_refs\n        self.parse_trailers: bool = parse_trailers\n\n        # set provider\n        if not provider:\n            remote_url = self.get_remote_url()\n            split = remote_url.split(\"/\")\n            provider_url = \"/\".join(split[:3])\n            namespace, project = \"/\".join(split[3:-1]), split[-1]\n            if \"github\" in provider_url:\n                provider = GitHub(namespace, project, url=provider_url)\n            elif \"gitlab\" in provider_url:\n                provider = GitLab(namespace, project, url=provider_url)\n            self.remote_url: str = remote_url\n        self.provider = provider\n\n        # set convention\n        if isinstance(convention, str):\n            try:\n                convention = self.CONVENTION[convention]()\n            except KeyError:\n                print(\n                    f\"git-changelog: no such convention available: {convention}, using default convention\",\n                    file=sys.stderr,\n                )\n                convention = BasicConvention()\n        elif convention is None:\n            convention = BasicConvention()\n        elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n            convention = convention()\n        self.convention: CommitConvention = convention\n\n        # set sections\n        if sections:\n            sections = [self.convention.TYPES[section] for section in sections]\n        else:\n            sections = self.convention.DEFAULT_RENDER\n        self.sections = sections\n\n        # get git log and parse it into list of commits\n        self.raw_log: str = self.get_log()\n        self.commits: list[Commit] = self.parse_commits()\n\n        # apply dates to commits and group them by version\n        dates = self._apply_versions_to_commits()\n        v_list, v_dict = self._group_commits_by_version(dates)\n        self.versions_list = v_list\n        self.versions_dict = v_dict\n\n        # try to guess the new version by bumping the latest one\n        if bump_latest:\n            self._bump_latest()\n\n        # fix a single, initial version to 0.1.0\n        self._fix_single_version()\n\n    def run_git(self, *args: str) -&gt; str:\n\"\"\"Run a git command in the chosen repository.\n\n        Arguments:\n            *args: Arguments passed to the git command.\n\n        Returns:\n            The git command output.\n        \"\"\"\n        return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n\n    def get_remote_url(self) -&gt; str:  # noqa: WPS615\n\"\"\"Get the git remote URL for the repository.\n\n        Returns:\n            The origin remote URL.\n        \"\"\"\n        remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n        git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n        if git_url.startswith(\"git@\"):\n            git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n        if git_url.endswith(\".git\"):\n            git_url = git_url[:-4]\n        return git_url\n\n    def get_log(self) -&gt; str:\n\"\"\"Get the `git log` output.\n\n        Returns:\n            The output of the `git log` command, with a particular format.\n        \"\"\"\n        return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n\n    def parse_commits(self) -&gt; list[Commit]:\n\"\"\"Parse the output of 'git log' into a list of commits.\n\n        Returns:\n            The list of commits.\n        \"\"\"\n        lines = self.raw_log.split(\"\\n\")\n        size = len(lines) - 1  # don't count last blank line\n        commits = []\n        pos = 0\n        while pos &lt; size:\n            # build body\n            nbl_index = 9\n            body = []\n            while lines[pos + nbl_index] != self.MARKER:\n                body.append(lines[pos + nbl_index].strip(\"\\r\"))\n                nbl_index += 1\n\n            # build commit\n            commit = Commit(\n                commit_hash=lines[pos],\n                author_name=lines[pos + 1],\n                author_email=lines[pos + 2],\n                author_date=lines[pos + 3],\n                committer_name=lines[pos + 4],\n                committer_email=lines[pos + 5],\n                committer_date=lines[pos + 6],\n                refs=lines[pos + 7],\n                subject=lines[pos + 8],\n                body=body,\n                parse_trailers=self.parse_trailers,\n            )\n\n            pos += nbl_index + 1\n\n            # expand commit object with provider parsing\n            if self.provider:\n                commit.update_with_provider(self.provider, self.parse_provider_refs)\n\n            # set the commit url based on remote_url (could be wrong)\n            elif self.remote_url:\n                commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n            # expand commit object with convention parsing\n            if self.convention:\n                commit.update_with_convention(self.convention)\n\n            commits.append(commit)\n\n        return commits\n\n    def _apply_versions_to_commits(self) -&gt; dict[str, datetime.date]:\n        versions_dates = {\"\": datetime.date.today()}\n        version = None\n        for commit in self.commits:\n            if commit.version:\n                version = commit.version\n                versions_dates[version] = commit.committer_date.date()\n            elif version:\n                commit.version = version\n        return versions_dates\n\n    def _group_commits_by_version(  # noqa: WPS231\n        self, dates: dict[str, datetime.date]\n    ) -&gt; tuple[list[Version], dict[str, Version]]:\n        versions_list = []\n        versions_dict = {}\n        versions_types_dict: dict[str, dict[str, Section]] = {}\n        next_version = None\n        for commit in self.commits:\n            if commit.version not in versions_dict:\n                version = Version(tag=commit.version, date=dates[commit.version])\n                versions_dict[commit.version] = version\n                if self.provider:\n                    version.url = self.provider.get_tag_url(tag=commit.version)\n                if next_version:\n                    version.next_version = next_version\n                    next_version.previous_version = version\n                    if self.provider:\n                        next_version.compare_url = self.provider.get_compare_url(\n                            base=version.tag, target=next_version.tag or \"HEAD\"\n                        )\n                next_version = version\n                versions_list.append(version)\n                versions_types_dict[commit.version] = {}\n            versions_dict[commit.version].commits.append(commit)\n            if \"type\" in commit.convention and commit.convention[\"type\"] not in versions_types_dict[commit.version]:\n                section = Section(section_type=commit.convention[\"type\"])\n                versions_types_dict[commit.version][commit.convention[\"type\"]] = section\n                versions_dict[commit.version].sections_list.append(section)\n                versions_dict[commit.version].sections_dict = versions_types_dict[commit.version]\n            versions_types_dict[commit.version][commit.convention[\"type\"]].commits.append(commit)\n        if next_version is not None and self.provider:\n            next_version.compare_url = self.provider.get_compare_url(\n                base=versions_list[-1].commits[-1].hash, target=next_version.tag or \"HEAD\"\n            )\n        return versions_list, versions_dict\n\n    def _bump_latest(self) -&gt; None:  # noqa: WPS231\n        # guess the next version number based on last version and recent commits\n        last_version = self.versions_list[0]\n        if not last_version.tag and last_version.previous_version:\n            last_tag = last_version.previous_version.tag\n            major = minor = False  # noqa: WPS429\n            for commit in last_version.commits:\n                if commit.convention[\"is_major\"]:\n                    major = True\n                    break\n                elif commit.convention[\"is_minor\"]:\n                    minor = True\n            # never fail on non-semver versions\n            with suppress(ValueError):\n                if major:\n                    planned_tag = bump(last_tag, \"major\")\n                elif minor:\n                    planned_tag = bump(last_tag, \"minor\")\n                else:\n                    planned_tag = bump(last_tag, \"patch\")\n                last_version.planned_tag = planned_tag\n                if self.provider:\n                    last_version.url = self.provider.get_tag_url(tag=planned_tag)\n                    last_version.compare_url = self.provider.get_compare_url(\n                        base=last_version.previous_version.tag, target=last_version.planned_tag\n                    )\n\n    def _fix_single_version(self) -&gt; None:\n        last_version = self.versions_list[0]\n        if len(self.versions_list) == 1 and last_version.planned_tag is None:\n            planned_tag = \"0.1.0\"\n            last_version.tag = planned_tag\n            last_version.url += planned_tag\n            last_version.compare_url = last_version.compare_url.replace(\"HEAD\", planned_tag)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.build.Changelog.__init__","title":"<code>__init__(repository, provider=None, convention=None, parse_provider_refs=False, parse_trailers=False, sections=None, bump_latest=False)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>str | Path</code> <p>The repository (directory) for which to build the changelog.</p> required <code>provider</code> <code>ProviderRefParser | None</code> <p>The provider to use (github.com, gitlab.com, etc.).</p> <code>None</code> <code>convention</code> <code>ConventionType | None</code> <p>The commit convention to use (angular, atom, etc.).</p> <code>None</code> <code>parse_provider_refs</code> <code>bool</code> <p>Whether to parse provider-specific references in the commit messages.</p> <code>False</code> <code>parse_trailers</code> <code>bool</code> <p>Whether to parse Git trailers in the commit messages.</p> <code>False</code> <code>sections</code> <code>list[str] | None</code> <p>The sections to render (features, bug fixes, etc.).</p> <code>None</code> <code>bump_latest</code> <code>bool</code> <p>Whether to try and bump latest version to guess new one.</p> <code>False</code> Source code in <code>git_changelog/build.py</code> <pre><code>def __init__(  # noqa: WPS231\n    self,\n    repository: str | Path,\n    provider: ProviderRefParser | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, atom, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Whether to try and bump latest version to guess new one.\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n\n    # set provider\n    if not provider:\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    if sections:\n        sections = [self.convention.TYPES[section] for section in sections]\n    else:\n        sections = self.convention.DEFAULT_RENDER\n    self.sections = sections\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n\n    # apply dates to commits and group them by version\n    dates = self._apply_versions_to_commits()\n    v_list, v_dict = self._group_commits_by_version(dates)\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # try to guess the new version by bumping the latest one\n    if bump_latest:\n        self._bump_latest()\n\n    # fix a single, initial version to 0.1.0\n    self._fix_single_version()\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.build.Changelog.get_log","title":"<code>get_log()</code>","text":"<p>Get the <code>git log</code> output.</p> <p>Returns:</p> Type Description <code>str</code> <p>The output of the <code>git log</code> command, with a particular format.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n\"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.build.Changelog.get_remote_url","title":"<code>get_remote_url()</code>","text":"<p>Get the git remote URL for the repository.</p> <p>Returns:</p> Type Description <code>str</code> <p>The origin remote URL.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:  # noqa: WPS615\n\"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.build.Changelog.parse_commits","title":"<code>parse_commits()</code>","text":"<p>Parse the output of 'git log' into a list of commits.</p> <p>Returns:</p> Type Description <code>list[Commit]</code> <p>The list of commits.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n\"\"\"Parse the output of 'git log' into a list of commits.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # don't count last blank line\n    commits = []\n    pos = 0\n    while pos &lt; size:\n        # build body\n        nbl_index = 9\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # build commit\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            subject=lines[pos + 8],\n            body=body,\n            parse_trailers=self.parse_trailers,\n        )\n\n        pos += nbl_index + 1\n\n        # expand commit object with provider parsing\n        if self.provider:\n            commit.update_with_provider(self.provider, self.parse_provider_refs)\n\n        # set the commit url based on remote_url (could be wrong)\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # expand commit object with convention parsing\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits.append(commit)\n\n    return commits\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.build.Changelog.run_git","title":"<code>run_git(*args)</code>","text":"<p>Run a git command in the chosen repository.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Arguments passed to the git command.</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>The git command output.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n\"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit","title":"<code>Commit</code>","text":"<p>A class to represent a commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class Commit:\n\"\"\"A class to represent a commit.\"\"\"\n\n    def __init__(  # noqa: WPS231\n        self,\n        commit_hash: str,\n        author_name: str = \"\",\n        author_email: str = \"\",\n        author_date: str | datetime = \"\",\n        committer_name: str = \"\",\n        committer_email: str = \"\",\n        committer_date: str | datetime = \"\",\n        refs: str = \"\",\n        subject: str = \"\",\n        body: list[str] | None = None,\n        url: str = \"\",\n        parse_trailers: bool = False,\n    ):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            commit_hash: The commit hash.\n            author_name: The author name.\n            author_email: The author email.\n            author_date: The authoring date (datetime or UTC timestamp).\n            committer_name: The committer name.\n            committer_email: The committer email.\n            committer_date: The committing date (datetime or UTC timestamp).\n            refs: The commit refs.\n            subject: The commit message subject.\n            body: The commit message body.\n            url: The commit URL.\n            parse_trailers: Whether to parse Git trailers.\n        \"\"\"\n        if not author_date:\n            author_date = datetime.now()\n        elif isinstance(author_date, str):\n            author_date = datetime.utcfromtimestamp(float(author_date))\n        if not committer_date:\n            committer_date = datetime.now()\n        elif isinstance(committer_date, str):\n            committer_date = datetime.utcfromtimestamp(float(committer_date))\n\n        self.hash: str = commit_hash\n        self.author_name: str = author_name\n        self.author_email: str = author_email\n        self.author_date: datetime = author_date\n        self.committer_name: str = committer_name\n        self.committer_email: str = committer_email\n        self.committer_date: datetime = committer_date\n        self.subject: str = subject\n        self.body: list[str] = _clean_body(body) if body else []\n        self.url: str = url\n\n        tag = \"\"\n        for ref in refs.split(\",\"):\n            ref = ref.strip()\n            if ref.startswith(\"tag: \"):\n                tag = ref.replace(\"tag: \", \"\")\n                break\n        self.tag: str = tag\n        self.version: str = tag\n\n        self.text_refs: dict[str, list[Ref]] = {}\n        self.convention: dict[str, Any] = {}\n\n        self.trailers: dict[str, str] = {}\n        self.body_without_trailers = self.body\n\n        if parse_trailers:\n            self._parse_trailers()\n\n    def update_with_convention(self, convention: CommitConvention) -&gt; None:\n\"\"\"\n        Apply the convention-parsed data to this commit.\n\n        Arguments:\n            convention: The convention to use.\n        \"\"\"\n        self.convention.update(convention.parse_commit(self))\n\n    def update_with_provider(self, provider: ProviderRefParser, parse_refs: bool = True) -&gt; None:  # noqa: WPS231\n\"\"\"\n        Apply the provider-parsed data to this commit.\n\n        Arguments:\n            provider: The provider to use.\n            parse_refs: Whether to parse references for this provider.\n        \"\"\"\n        # set the commit url based on provider\n        # FIXME: hardcoded 'commits'\n        if \"commits\" in provider.REF:\n            self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n        else:\n            # use default \"commit\" url (could be wrong)\n            self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n        # build commit text references from its subject and body\n        if parse_refs:\n            for ref_type in provider.REF.keys():\n                self.text_refs[ref_type] = provider.get_refs(ref_type, \"\\n\".join([self.subject] + self.body))\n\n            if \"issues\" in self.text_refs:\n                self.text_refs[\"issues_not_in_subject\"] = []\n                for issue in self.text_refs[\"issues\"]:\n                    if issue.ref not in self.subject:\n                        self.text_refs[\"issues_not_in_subject\"].append(issue)\n\n    def _parse_trailers(self) -&gt; None:\n        last_blank_line = -1\n        for index, line in enumerate(self.body):\n            if not line:\n                last_blank_line = index\n        with suppress(ValueError):\n            trailers = self._parse_trailers_block(self.body[last_blank_line + 1 :])\n            if trailers:\n                self.trailers.update(trailers)\n                self.body_without_trailers = self.body[:last_blank_line]\n\n    def _parse_trailers_block(self, lines: list[str]) -&gt; dict[str, str]:\n        trailers = {}\n        for line in lines:\n            title, value = line.split(\": \", 1)\n            trailers[title] = value.strip()\n        return trailers  # or raise ValueError due to split unpacking\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.commit.Commit.__init__","title":"<code>__init__(commit_hash, author_name='', author_email='', author_date='', committer_name='', committer_email='', committer_date='', refs='', subject='', body=None, url='', parse_trailers=False)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>commit_hash</code> <code>str</code> <p>The commit hash.</p> required <code>author_name</code> <code>str</code> <p>The author name.</p> <code>''</code> <code>author_email</code> <code>str</code> <p>The author email.</p> <code>''</code> <code>author_date</code> <code>str | datetime</code> <p>The authoring date (datetime or UTC timestamp).</p> <code>''</code> <code>committer_name</code> <code>str</code> <p>The committer name.</p> <code>''</code> <code>committer_email</code> <code>str</code> <p>The committer email.</p> <code>''</code> <code>committer_date</code> <code>str | datetime</code> <p>The committing date (datetime or UTC timestamp).</p> <code>''</code> <code>refs</code> <code>str</code> <p>The commit refs.</p> <code>''</code> <code>subject</code> <code>str</code> <p>The commit message subject.</p> <code>''</code> <code>body</code> <code>list[str] | None</code> <p>The commit message body.</p> <code>None</code> <code>url</code> <code>str</code> <p>The commit URL.</p> <code>''</code> <code>parse_trailers</code> <code>bool</code> <p>Whether to parse Git trailers.</p> <code>False</code> Source code in <code>git_changelog/commit.py</code> <pre><code>def __init__(  # noqa: WPS231\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    parse_trailers: bool = False,\n):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()\n    elif isinstance(author_date, str):\n        author_date = datetime.utcfromtimestamp(float(author_date))\n    if not committer_date:\n        committer_date = datetime.now()\n    elif isinstance(committer_date, str):\n        committer_date = datetime.utcfromtimestamp(float(committer_date))\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()\n        if ref.startswith(\"tag: \"):\n            tag = ref.replace(\"tag: \", \"\")\n            break\n    self.tag: str = tag\n    self.version: str = tag\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.commit.Commit.update_with_convention","title":"<code>update_with_convention(convention)</code>","text":"<p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> Name Type Description Default <code>convention</code> <code>CommitConvention</code> <p>The convention to use.</p> required Source code in <code>git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n\"\"\"\n    Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.commit.Commit.update_with_provider","title":"<code>update_with_provider(provider, parse_refs=True)</code>","text":"<p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>ProviderRefParser</code> <p>The provider to use.</p> required <code>parse_refs</code> <code>bool</code> <p>Whether to parse references for this provider.</p> <code>True</code> Source code in <code>git_changelog/commit.py</code> <pre><code>def update_with_provider(self, provider: ProviderRefParser, parse_refs: bool = True) -&gt; None:  # noqa: WPS231\n\"\"\"\n    Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF.keys():\n            self.text_refs[ref_type] = provider.get_refs(ref_type, \"\\n\".join([self.subject] + self.body))\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub","title":"<code>GitHub</code>","text":"<p>         Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class GitHub(ProviderRefParser):\n\"\"\"A parser for the GitHub references.\"\"\"\n\n    url: str = \"https://github.com\"\n    project_url: str = \"{base_url}/{namespace}/{project}\"\n    tag_url: str = \"{base_url}/{namespace}/{project}/releases/tag/{ref}\"\n\n    commit_min_length = 8\n    commit_max_length = 40\n\n    REF: dict[str, RefDef] = {\n        \"issues\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=\"#\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues/{ref}\",\n        ),\n        \"commits\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit}{ba}\".format(\n                    np=RefRe.NP, commit=RefRe.COMMIT.format(min=commit_min_length, max=commit_max_length), ba=RefRe.BA\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/commit/{ref}\",\n        ),\n        \"commits_ranges\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit_range}\".format(\n                    np=RefRe.NP, commit_range=RefRe.COMMIT_RANGE.format(min=commit_min_length, max=commit_max_length)\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/compare/{ref}\",\n        ),\n        \"mentions\": RefDef(regex=re.compile(RefRe.BB + RefRe.MENTION, re.I), url_string=\"{base_url}/{ref}\"),\n    }\n\n    def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            namespace: The GitHub namespace.\n            project: The GitHub project.\n            url: The GitHub URL.\n        \"\"\"\n        self.namespace: str = namespace\n        self.project: str = project\n        self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n\n    def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:  # noqa: D102 (use parent docstring)\n        match_dict[\"base_url\"] = self.url\n        if not match_dict.get(\"namespace\"):\n            match_dict[\"namespace\"] = self.namespace\n        if not match_dict.get(\"project\"):\n            match_dict[\"project\"] = self.project\n        return super().build_ref_url(ref_type, match_dict)\n\n    def get_tag_url(self, tag: str = \"\") -&gt; str:  # noqa: D102,WPS615\n        return self.tag_url.format(base_url=self.url, namespace=self.namespace, project=self.project, ref=tag)\n\n    def get_compare_url(self, base: str, target: str) -&gt; str:  # noqa: D102 (use parent docstring)\n        return self.build_ref_url(\"commits_ranges\", {\"ref\": f\"{base}...{target}\"})\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.providers.GitHub.__init__","title":"<code>__init__(namespace, project, url=url)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>The GitHub namespace.</p> required <code>project</code> <code>str</code> <p>The GitHub project.</p> required <code>url</code> <code>str</code> <p>The GitHub URL.</p> <code>url</code> Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        namespace: The GitHub namespace.\n        project: The GitHub project.\n        url: The GitHub URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab","title":"<code>GitLab</code>","text":"<p>         Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class GitLab(ProviderRefParser):\n\"\"\"A parser for the GitLab references.\"\"\"\n\n    url: str = \"https://gitlab.com\"\n    project_url: str = \"{base_url}/{namespace}/{project}\"\n    tag_url: str = \"{base_url}/{namespace}/{project}/tags/{ref}\"\n\n    commit_min_length = 8\n    commit_max_length = 40\n\n    REF: dict[str, RefDef] = {\n        \"issues\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=\"#\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues/{ref}\",\n        ),\n        \"merge_requests\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"!\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/merge_requests/{ref}\",\n        ),\n        \"snippets\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"\\$\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/snippets/{ref}\",\n        ),\n        \"labels_ids\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"~\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",  # no label_id param?\n        ),\n        \"labels_one_word\": RefDef(\n            regex=re.compile(  # also matches label IDs\n                RefRe.BB + RefRe.NP + \"?\" + RefRe.ONE_WORD.format(symbol=r\"~\"), re.I\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",\n        ),\n        \"labels_multi_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.MULTI_WORD.format(symbol=r\"~\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",\n        ),\n        \"milestones_ids\": RefDef(\n            regex=re.compile(  # also matches milestones IDs\n                RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"%\"), re.I\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/milestones/{ref}\",\n        ),\n        \"milestones_one_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ONE_WORD.format(symbol=r\"%\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/milestones\",  # cannot guess ID\n        ),\n        \"milestones_multi_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.MULTI_WORD.format(symbol=r\"%\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/milestones\",  # cannot guess ID\n        ),\n        \"commits\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit}{ba}\".format(\n                    np=RefRe.NP, commit=RefRe.COMMIT.format(min=commit_min_length, max=commit_max_length), ba=RefRe.BA\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/commit/{ref}\",\n        ),\n        \"commits_ranges\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit_range}\".format(\n                    np=RefRe.NP, commit_range=RefRe.COMMIT_RANGE.format(min=commit_min_length, max=commit_max_length)\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/compare/{ref}\",\n        ),\n        \"mentions\": RefDef(regex=re.compile(RefRe.BB + RefRe.MENTION, re.I), url_string=\"{base_url}/{ref}\"),\n    }\n\n    def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            namespace: The GitLab namespace.\n            project: The GitLab project.\n            url: The GitLab URL.\n        \"\"\"\n        self.namespace: str = namespace\n        self.project: str = project\n        self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n\n    def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:  # noqa: D102 (use parent docstring)\n        match_dict[\"base_url\"] = self.url\n        if not match_dict.get(\"namespace\"):\n            match_dict[\"namespace\"] = self.namespace\n        if not match_dict.get(\"project\"):\n            match_dict[\"project\"] = self.project\n        if ref_type.startswith(\"label\"):\n            match_dict[\"ref\"] = match_dict[\"ref\"].replace('\"', \"\").replace(\" \", \"+\")\n        return super().build_ref_url(ref_type, match_dict)\n\n    def get_tag_url(self, tag: str = \"\") -&gt; str:  # noqa: D102,WPS615\n        return self.tag_url.format(base_url=self.url, namespace=self.namespace, project=self.project, ref=tag)\n\n    def get_compare_url(self, base: str, target: str) -&gt; str:  # noqa: D102 (use parent docstring)\n        return self.build_ref_url(\"commits_ranges\", {\"ref\": f\"{base}...{target}\"})\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.providers.GitLab.__init__","title":"<code>__init__(namespace, project, url=url)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>The GitLab namespace.</p> required <code>project</code> <code>str</code> <p>The GitLab project.</p> required <code>url</code> <code>str</code> <p>The GitLab URL.</p> <code>url</code> Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        namespace: The GitLab namespace.\n        project: The GitLab project.\n        url: The GitLab URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n</code></pre>"},{"location":"reference/git_changelog/build/","title":"build","text":"<p>The module responsible for building the data.</p>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog","title":"<code>Changelog</code>","text":"<p>The main changelog class.</p> Source code in <code>git_changelog/build.py</code> <pre><code>class Changelog:\n\"\"\"The main changelog class.\"\"\"\n\n    MARKER: str = \"--GIT-CHANGELOG MARKER--\"\n    FORMAT: str = (\n        r\"%H%n\"  # commit commit_hash  # noqa: WPS323\n        r\"%an%n\"  # author name\n        r\"%ae%n\"  # author email\n        r\"%ad%n\"  # author date\n        r\"%cn%n\"  # committer name\n        r\"%ce%n\"  # committer email\n        r\"%cd%n\"  # committer date\n        r\"%D%n\"  # tag\n        r\"%s%n\"  # subject\n        r\"%b%n\" + MARKER  # body\n    )\n    CONVENTION: dict[str, Type[CommitConvention]] = {\n        \"basic\": BasicConvention,\n        \"angular\": AngularConvention,\n        \"atom\": AtomConvention,\n        \"conventional\": ConventionalCommitConvention,\n    }\n\n    def __init__(  # noqa: WPS231\n        self,\n        repository: str | Path,\n        provider: ProviderRefParser | None = None,\n        convention: ConventionType | None = None,\n        parse_provider_refs: bool = False,\n        parse_trailers: bool = False,\n        sections: list[str] | None = None,\n        bump_latest: bool = False,\n    ):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            repository: The repository (directory) for which to build the changelog.\n            provider: The provider to use (github.com, gitlab.com, etc.).\n            convention: The commit convention to use (angular, atom, etc.).\n            parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n            parse_trailers: Whether to parse Git trailers in the commit messages.\n            sections: The sections to render (features, bug fixes, etc.).\n            bump_latest: Whether to try and bump latest version to guess new one.\n        \"\"\"\n        self.repository: str | Path = repository\n        self.parse_provider_refs: bool = parse_provider_refs\n        self.parse_trailers: bool = parse_trailers\n\n        # set provider\n        if not provider:\n            remote_url = self.get_remote_url()\n            split = remote_url.split(\"/\")\n            provider_url = \"/\".join(split[:3])\n            namespace, project = \"/\".join(split[3:-1]), split[-1]\n            if \"github\" in provider_url:\n                provider = GitHub(namespace, project, url=provider_url)\n            elif \"gitlab\" in provider_url:\n                provider = GitLab(namespace, project, url=provider_url)\n            self.remote_url: str = remote_url\n        self.provider = provider\n\n        # set convention\n        if isinstance(convention, str):\n            try:\n                convention = self.CONVENTION[convention]()\n            except KeyError:\n                print(\n                    f\"git-changelog: no such convention available: {convention}, using default convention\",\n                    file=sys.stderr,\n                )\n                convention = BasicConvention()\n        elif convention is None:\n            convention = BasicConvention()\n        elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n            convention = convention()\n        self.convention: CommitConvention = convention\n\n        # set sections\n        if sections:\n            sections = [self.convention.TYPES[section] for section in sections]\n        else:\n            sections = self.convention.DEFAULT_RENDER\n        self.sections = sections\n\n        # get git log and parse it into list of commits\n        self.raw_log: str = self.get_log()\n        self.commits: list[Commit] = self.parse_commits()\n\n        # apply dates to commits and group them by version\n        dates = self._apply_versions_to_commits()\n        v_list, v_dict = self._group_commits_by_version(dates)\n        self.versions_list = v_list\n        self.versions_dict = v_dict\n\n        # try to guess the new version by bumping the latest one\n        if bump_latest:\n            self._bump_latest()\n\n        # fix a single, initial version to 0.1.0\n        self._fix_single_version()\n\n    def run_git(self, *args: str) -&gt; str:\n\"\"\"Run a git command in the chosen repository.\n\n        Arguments:\n            *args: Arguments passed to the git command.\n\n        Returns:\n            The git command output.\n        \"\"\"\n        return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n\n    def get_remote_url(self) -&gt; str:  # noqa: WPS615\n\"\"\"Get the git remote URL for the repository.\n\n        Returns:\n            The origin remote URL.\n        \"\"\"\n        remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n        git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n        if git_url.startswith(\"git@\"):\n            git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n        if git_url.endswith(\".git\"):\n            git_url = git_url[:-4]\n        return git_url\n\n    def get_log(self) -&gt; str:\n\"\"\"Get the `git log` output.\n\n        Returns:\n            The output of the `git log` command, with a particular format.\n        \"\"\"\n        return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n\n    def parse_commits(self) -&gt; list[Commit]:\n\"\"\"Parse the output of 'git log' into a list of commits.\n\n        Returns:\n            The list of commits.\n        \"\"\"\n        lines = self.raw_log.split(\"\\n\")\n        size = len(lines) - 1  # don't count last blank line\n        commits = []\n        pos = 0\n        while pos &lt; size:\n            # build body\n            nbl_index = 9\n            body = []\n            while lines[pos + nbl_index] != self.MARKER:\n                body.append(lines[pos + nbl_index].strip(\"\\r\"))\n                nbl_index += 1\n\n            # build commit\n            commit = Commit(\n                commit_hash=lines[pos],\n                author_name=lines[pos + 1],\n                author_email=lines[pos + 2],\n                author_date=lines[pos + 3],\n                committer_name=lines[pos + 4],\n                committer_email=lines[pos + 5],\n                committer_date=lines[pos + 6],\n                refs=lines[pos + 7],\n                subject=lines[pos + 8],\n                body=body,\n                parse_trailers=self.parse_trailers,\n            )\n\n            pos += nbl_index + 1\n\n            # expand commit object with provider parsing\n            if self.provider:\n                commit.update_with_provider(self.provider, self.parse_provider_refs)\n\n            # set the commit url based on remote_url (could be wrong)\n            elif self.remote_url:\n                commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n            # expand commit object with convention parsing\n            if self.convention:\n                commit.update_with_convention(self.convention)\n\n            commits.append(commit)\n\n        return commits\n\n    def _apply_versions_to_commits(self) -&gt; dict[str, datetime.date]:\n        versions_dates = {\"\": datetime.date.today()}\n        version = None\n        for commit in self.commits:\n            if commit.version:\n                version = commit.version\n                versions_dates[version] = commit.committer_date.date()\n            elif version:\n                commit.version = version\n        return versions_dates\n\n    def _group_commits_by_version(  # noqa: WPS231\n        self, dates: dict[str, datetime.date]\n    ) -&gt; tuple[list[Version], dict[str, Version]]:\n        versions_list = []\n        versions_dict = {}\n        versions_types_dict: dict[str, dict[str, Section]] = {}\n        next_version = None\n        for commit in self.commits:\n            if commit.version not in versions_dict:\n                version = Version(tag=commit.version, date=dates[commit.version])\n                versions_dict[commit.version] = version\n                if self.provider:\n                    version.url = self.provider.get_tag_url(tag=commit.version)\n                if next_version:\n                    version.next_version = next_version\n                    next_version.previous_version = version\n                    if self.provider:\n                        next_version.compare_url = self.provider.get_compare_url(\n                            base=version.tag, target=next_version.tag or \"HEAD\"\n                        )\n                next_version = version\n                versions_list.append(version)\n                versions_types_dict[commit.version] = {}\n            versions_dict[commit.version].commits.append(commit)\n            if \"type\" in commit.convention and commit.convention[\"type\"] not in versions_types_dict[commit.version]:\n                section = Section(section_type=commit.convention[\"type\"])\n                versions_types_dict[commit.version][commit.convention[\"type\"]] = section\n                versions_dict[commit.version].sections_list.append(section)\n                versions_dict[commit.version].sections_dict = versions_types_dict[commit.version]\n            versions_types_dict[commit.version][commit.convention[\"type\"]].commits.append(commit)\n        if next_version is not None and self.provider:\n            next_version.compare_url = self.provider.get_compare_url(\n                base=versions_list[-1].commits[-1].hash, target=next_version.tag or \"HEAD\"\n            )\n        return versions_list, versions_dict\n\n    def _bump_latest(self) -&gt; None:  # noqa: WPS231\n        # guess the next version number based on last version and recent commits\n        last_version = self.versions_list[0]\n        if not last_version.tag and last_version.previous_version:\n            last_tag = last_version.previous_version.tag\n            major = minor = False  # noqa: WPS429\n            for commit in last_version.commits:\n                if commit.convention[\"is_major\"]:\n                    major = True\n                    break\n                elif commit.convention[\"is_minor\"]:\n                    minor = True\n            # never fail on non-semver versions\n            with suppress(ValueError):\n                if major:\n                    planned_tag = bump(last_tag, \"major\")\n                elif minor:\n                    planned_tag = bump(last_tag, \"minor\")\n                else:\n                    planned_tag = bump(last_tag, \"patch\")\n                last_version.planned_tag = planned_tag\n                if self.provider:\n                    last_version.url = self.provider.get_tag_url(tag=planned_tag)\n                    last_version.compare_url = self.provider.get_compare_url(\n                        base=last_version.previous_version.tag, target=last_version.planned_tag\n                    )\n\n    def _fix_single_version(self) -&gt; None:\n        last_version = self.versions_list[0]\n        if len(self.versions_list) == 1 and last_version.planned_tag is None:\n            planned_tag = \"0.1.0\"\n            last_version.tag = planned_tag\n            last_version.url += planned_tag\n            last_version.compare_url = last_version.compare_url.replace(\"HEAD\", planned_tag)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.__init__","title":"<code>__init__(repository, provider=None, convention=None, parse_provider_refs=False, parse_trailers=False, sections=None, bump_latest=False)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>str | Path</code> <p>The repository (directory) for which to build the changelog.</p> required <code>provider</code> <code>ProviderRefParser | None</code> <p>The provider to use (github.com, gitlab.com, etc.).</p> <code>None</code> <code>convention</code> <code>ConventionType | None</code> <p>The commit convention to use (angular, atom, etc.).</p> <code>None</code> <code>parse_provider_refs</code> <code>bool</code> <p>Whether to parse provider-specific references in the commit messages.</p> <code>False</code> <code>parse_trailers</code> <code>bool</code> <p>Whether to parse Git trailers in the commit messages.</p> <code>False</code> <code>sections</code> <code>list[str] | None</code> <p>The sections to render (features, bug fixes, etc.).</p> <code>None</code> <code>bump_latest</code> <code>bool</code> <p>Whether to try and bump latest version to guess new one.</p> <code>False</code> Source code in <code>git_changelog/build.py</code> <pre><code>def __init__(  # noqa: WPS231\n    self,\n    repository: str | Path,\n    provider: ProviderRefParser | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, atom, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Whether to try and bump latest version to guess new one.\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n\n    # set provider\n    if not provider:\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    if sections:\n        sections = [self.convention.TYPES[section] for section in sections]\n    else:\n        sections = self.convention.DEFAULT_RENDER\n    self.sections = sections\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n\n    # apply dates to commits and group them by version\n    dates = self._apply_versions_to_commits()\n    v_list, v_dict = self._group_commits_by_version(dates)\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # try to guess the new version by bumping the latest one\n    if bump_latest:\n        self._bump_latest()\n\n    # fix a single, initial version to 0.1.0\n    self._fix_single_version()\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_log","title":"<code>get_log()</code>","text":"<p>Get the <code>git log</code> output.</p> <p>Returns:</p> Type Description <code>str</code> <p>The output of the <code>git log</code> command, with a particular format.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n\"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_remote_url","title":"<code>get_remote_url()</code>","text":"<p>Get the git remote URL for the repository.</p> <p>Returns:</p> Type Description <code>str</code> <p>The origin remote URL.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:  # noqa: WPS615\n\"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.parse_commits","title":"<code>parse_commits()</code>","text":"<p>Parse the output of 'git log' into a list of commits.</p> <p>Returns:</p> Type Description <code>list[Commit]</code> <p>The list of commits.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n\"\"\"Parse the output of 'git log' into a list of commits.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # don't count last blank line\n    commits = []\n    pos = 0\n    while pos &lt; size:\n        # build body\n        nbl_index = 9\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # build commit\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            subject=lines[pos + 8],\n            body=body,\n            parse_trailers=self.parse_trailers,\n        )\n\n        pos += nbl_index + 1\n\n        # expand commit object with provider parsing\n        if self.provider:\n            commit.update_with_provider(self.provider, self.parse_provider_refs)\n\n        # set the commit url based on remote_url (could be wrong)\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # expand commit object with convention parsing\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits.append(commit)\n\n    return commits\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.run_git","title":"<code>run_git(*args)</code>","text":"<p>Run a git command in the chosen repository.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Arguments passed to the git command.</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>The git command output.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n\"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Section","title":"<code>Section</code>","text":"<p>A list of commits grouped by section_type.</p> Source code in <code>git_changelog/build.py</code> <pre><code>class Section:\n\"\"\"A list of commits grouped by section_type.\"\"\"\n\n    def __init__(self, section_type: str = \"\", commits: list[Commit] | None = None):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            section_type: The section section_type.\n            commits: The list of commits.\n        \"\"\"\n        self.type: str = section_type\n        self.commits: list[Commit] = commits or []\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Section.__init__","title":"<code>__init__(section_type='', commits=None)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>section_type</code> <code>str</code> <p>The section section_type.</p> <code>''</code> <code>commits</code> <code>list[Commit] | None</code> <p>The list of commits.</p> <code>None</code> Source code in <code>git_changelog/build.py</code> <pre><code>def __init__(self, section_type: str = \"\", commits: list[Commit] | None = None):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        section_type: The section section_type.\n        commits: The list of commits.\n    \"\"\"\n    self.type: str = section_type\n    self.commits: list[Commit] = commits or []\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version","title":"<code>Version</code>","text":"<p>A class to represent a changelog version.</p> Source code in <code>git_changelog/build.py</code> <pre><code>class Version:\n\"\"\"A class to represent a changelog version.\"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"\",\n        date: datetime.date | None = None,\n        sections: list[Section] | None = None,\n        commits: list[Commit] | None = None,\n        url: str = \"\",\n        compare_url: str = \"\",\n    ):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            tag: The version tag.\n            date: The version date.\n            sections: The version sections.\n            commits: The version commits.\n            url: The version URL.\n            compare_url: The version 'compare' URL.\n        \"\"\"\n        self.tag = tag\n        self.date = date\n\n        self.sections_list: list[Section] = sections or []\n        self.sections_dict: dict[str, Section] = {section.type: section for section in self.sections_list}\n        self.commits: list[Commit] = commits or []\n        self.url: str = url\n        self.compare_url: str = compare_url\n        self.previous_version: Version | None = None\n        self.next_version: Version | None = None\n        self.planned_tag: str | None = None\n\n    @property\n    def typed_sections(self) -&gt; list[Section]:\n\"\"\"Return typed sections only.\n\n        Returns:\n            The typed sections.\n        \"\"\"\n        return [section for section in self.sections_list if section.type]\n\n    @property\n    def untyped_section(self) -&gt; Section | None:\n\"\"\"Return untyped section if any.\n\n        Returns:\n            The untyped section if any.\n        \"\"\"\n        return self.sections_dict.get(\"\", None)\n\n    @property\n    def is_major(self) -&gt; bool:\n\"\"\"Tell if this version is a major one.\n\n        Returns:\n            Whether this version is major.\n        \"\"\"\n        return self.tag.split(\".\", 1)[1].startswith(\"0.0\")\n\n    @property\n    def is_minor(self) -&gt; bool:\n\"\"\"Tell if this version is a minor one.\n\n        Returns:\n            Whether this version is minor.\n        \"\"\"\n        return bool(self.tag.split(\".\", 2)[2])\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_major","title":"<code>is_major: bool</code>  <code>property</code>","text":"<p>Tell if this version is a major one.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this version is major.</p>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_minor","title":"<code>is_minor: bool</code>  <code>property</code>","text":"<p>Tell if this version is a minor one.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this version is minor.</p>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.typed_sections","title":"<code>typed_sections: list[Section]</code>  <code>property</code>","text":"<p>Return typed sections only.</p> <p>Returns:</p> Type Description <code>list[Section]</code> <p>The typed sections.</p>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.untyped_section","title":"<code>untyped_section: Section | None</code>  <code>property</code>","text":"<p>Return untyped section if any.</p> <p>Returns:</p> Type Description <code>Section | None</code> <p>The untyped section if any.</p>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.__init__","title":"<code>__init__(tag='', date=None, sections=None, commits=None, url='', compare_url='')</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The version tag.</p> <code>''</code> <code>date</code> <code>datetime.date | None</code> <p>The version date.</p> <code>None</code> <code>sections</code> <code>list[Section] | None</code> <p>The version sections.</p> <code>None</code> <code>commits</code> <code>list[Commit] | None</code> <p>The version commits.</p> <code>None</code> <code>url</code> <code>str</code> <p>The version URL.</p> <code>''</code> <code>compare_url</code> <code>str</code> <p>The version 'compare' URL.</p> <code>''</code> Source code in <code>git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"\",\n    date: datetime.date | None = None,\n    sections: list[Section] | None = None,\n    commits: list[Commit] | None = None,\n    url: str = \"\",\n    compare_url: str = \"\",\n):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        tag: The version tag.\n        date: The version date.\n        sections: The version sections.\n        commits: The version commits.\n        url: The version URL.\n        compare_url: The version 'compare' URL.\n    \"\"\"\n    self.tag = tag\n    self.date = date\n\n    self.sections_list: list[Section] = sections or []\n    self.sections_dict: dict[str, Section] = {section.type: section for section in self.sections_list}\n    self.commits: list[Commit] = commits or []\n    self.url: str = url\n    self.compare_url: str = compare_url\n    self.previous_version: Version | None = None\n    self.next_version: Version | None = None\n    self.planned_tag: str | None = None\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.bump","title":"<code>bump(version, part='patch')</code>","text":"<p>Bump a version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The version to bump.</p> required <code>part</code> <code>str</code> <p>The part of the version to bump (major, minor, or patch).</p> <code>'patch'</code> <p>Returns:</p> Type Description <code>str</code> <p>The bumped version.</p> Source code in <code>git_changelog/build.py</code> <pre><code>def bump(version: str, part: str = \"patch\") -&gt; str:  # noqa: WPS231\n\"\"\"\n    Bump a version.\n\n    Arguments:\n        version: The version to bump.\n        part: The part of the version to bump (major, minor, or patch).\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    prefix = \"\"\n    if version[0] == \"v\":\n        prefix = \"v\"\n        version = version[1:]\n\n    semver_version = VersionInfo.parse(version)\n    if part == \"major\" and semver_version.major != 0:\n        semver_version = semver_version.bump_major()\n    elif part == \"minor\" or (part == \"major\" and semver_version.major == 0):\n        semver_version = semver_version.bump_minor()\n    elif part == \"patch\" and not semver_version.prerelease:\n        semver_version = semver_version.bump_patch()\n    return prefix + str(semver_version)\n</code></pre>"},{"location":"reference/git_changelog/cli/","title":"cli","text":"<p>Module that contains the command line application.</p>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.Templates","title":"<code>Templates</code>","text":"<p>         Bases: <code>tuple</code></p> <p>Helper to pick a template on the command line.</p> Source code in <code>git_changelog/cli.py</code> <pre><code>class Templates(tuple):  # noqa: WPS600 (subclassing tuple)\n\"\"\"Helper to pick a template on the command line.\"\"\"\n\n    def __contains__(self, item: object) -&gt; bool:\n        if isinstance(item, str):\n            return item.startswith(\"path:\") or super().__contains__(item)\n        return False\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.build_and_render","title":"<code>build_and_render(repository, template, convention, parse_refs=False, parse_trailers=False, sections=None, in_place=False, output=None, version_regex=DEFAULT_VERSION_REGEX, marker_line=DEFAULT_MARKER_LINE, bump_latest=False)</code>","text":"<p>Build a changelog and render it.</p> <p>This function returns the changelog instance and the rendered contents, but also updates the specified output file (side-effect) or writes to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>str</code> <p>Path to a local repository.</p> required <code>template</code> <code>str</code> <p>Name of a builtin template, or path to a custom template (prefixed with <code>path:</code>).</p> required <code>convention</code> <code>str | CommitConvention</code> <p>Name of a commit message style/convention.</p> required <code>parse_refs</code> <code>bool</code> <p>Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).</p> <code>False</code> <code>parse_trailers</code> <code>bool</code> <p>Whether to parse Git trailers.</p> <code>False</code> <code>sections</code> <code>list[str] | None</code> <p>Sections to render (features, bug fixes, etc.).</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>Whether to update the changelog in-place.</p> <code>False</code> <code>output</code> <code>str | TextIO | None</code> <p>Output/changelog file.</p> <code>None</code> <code>version_regex</code> <code>str</code> <p>Regular expression to match versions in an existing changelog file.</p> <code>DEFAULT_VERSION_REGEX</code> <code>marker_line</code> <code>str</code> <p>Marker line used to insert contents in an existing changelog.</p> <code>DEFAULT_MARKER_LINE</code> <code>bump_latest</code> <code>bool</code> <p>Whether to try and bump the latest version to guess the new one.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When some arguments are incompatible or missing.</p> <p>Returns:</p> Type Description <code>tuple[Changelog, str]</code> <p>The built changelog and the rendered contents.</p> Source code in <code>git_changelog/cli.py</code> <pre><code>def build_and_render(  # noqa: WPS231\n    repository: str,\n    template: str,\n    convention: str | CommitConvention,\n    parse_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    in_place: bool = False,\n    output: str | TextIO | None = None,\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    bump_latest: bool = False,\n) -&gt; tuple[Changelog, str]:\n\"\"\"Build a changelog and render it.\n\n    This function returns the changelog instance and the rendered contents,\n    but also updates the specified output file (side-effect) or writes to stdout.\n\n    Parameters:\n        repository: Path to a local repository.\n        template: Name of a builtin template, or path to a custom template (prefixed with `path:`).\n        convention: Name of a commit message style/convention.\n        parse_refs: Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).\n        parse_trailers: Whether to parse Git trailers.\n        sections: Sections to render (features, bug fixes, etc.).\n        in_place: Whether to update the changelog in-place.\n        output: Output/changelog file.\n        version_regex: Regular expression to match versions in an existing changelog file.\n        marker_line: Marker line used to insert contents in an existing changelog.\n        bump_latest: Whether to try and bump the latest version to guess the new one.\n\n    Raises:\n        ValueError: When some arguments are incompatible or missing.\n\n    Returns:\n        The built changelog and the rendered contents.\n    \"\"\"\n    # get template\n    if template.startswith(\"path:\"):\n        path = template.replace(\"path:\", \"\", 1)\n        try:\n            jinja_template = templates.get_custom_template(path)\n        except TemplateNotFound:\n            raise ValueError(f\"No such file: {path}\")\n    else:\n        jinja_template = templates.get_template(template)\n\n    if output is None:\n        output = sys.stdout\n\n    # handle misconfiguration early\n    if in_place and output is sys.stdout:\n        raise ValueError(\"Cannot write in-place to stdout\")\n\n    # build data\n    changelog = Changelog(\n        repository,\n        convention=convention,\n        parse_provider_refs=parse_refs,\n        parse_trailers=parse_trailers,\n        sections=sections,\n        bump_latest=bump_latest,\n    )\n\n    # render new entries in-place\n    if in_place:\n        # read current changelog lines\n        with open(output, \"r\") as changelog_file:  # type: ignore[arg-type]\n            lines = changelog_file.read().splitlines()\n\n        # prepare version regex and marker line\n        if template in {\"angular\", \"keepachangelog\"}:\n            version_regex = DEFAULT_VERSION_REGEX\n            marker_line = DEFAULT_MARKER_LINE\n\n        # only keep new entries (missing from changelog)\n        last_released = _latest(lines, re.compile(version_regex))\n        if last_released:\n            changelog.versions_list = _unreleased(changelog.versions_list, last_released)\n\n        # render new entries\n        rendered = jinja_template.render(changelog=changelog, in_place=True).rstrip(\"\\n\") + \"\\n\"\n\n        # find marker line(s) in current changelog\n        marker = lines.index(marker_line)\n        try:\n            marker2 = lines[marker + 1 :].index(marker_line)\n        except ValueError:\n            # apply new entries at marker line\n            lines[marker] = rendered\n        else:\n            # apply new entries between marker lines\n            lines[marker : marker + marker2 + 2] = [rendered]  # noqa: WPS362\n\n        # write back updated changelog lines\n        with open(output, \"w\") as changelog_file:  # type: ignore[arg-type]  # noqa: WPS440\n            changelog_file.write(\"\\n\".join(lines).rstrip(\"\\n\") + \"\\n\")\n\n    # overwrite output file\n    else:\n        rendered = jinja_template.render(changelog=changelog)\n\n        # write result in specified output\n        if output is sys.stdout:\n            sys.stdout.write(rendered)\n        else:\n            with open(output, \"w\") as stream:  # type: ignore[arg-type]\n                stream.write(rendered)\n\n    return changelog, rendered\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_parser","title":"<code>get_parser()</code>","text":"<p>Return the CLI argument parser.</p> <p>Returns:</p> Type Description <code>argparse.ArgumentParser</code> <p>An argparse parser.</p> Source code in <code>git_changelog/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n\"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        prog=\"git-changelog\",\n        description=re.sub(\n            r\"\\n *\",\n            \"\\n\",\n            f\"\"\"\n            Automatic Changelog generator using Jinja2 templates.\n\n            This tool parses your commit messages to extract useful data\n            that is then rendered using Jinja2 templates, for example to\n            a changelog file formatted in Markdown.\n\n            Each Git tag will be treated as a version of your project.\n            Each version contains a set of commits, and will be an entry\n            in your changelog. Commits in each version will be grouped\n            by sections, depending on the commit convention you follow.\n\n{BasicConvention._format_sections_help()}\n{AngularConvention._format_sections_help()}\n{ConventionalCommitConvention._format_sections_help()}\n            \"\"\",  # noqa: WPS437\n        ),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        \"repository\", metavar=\"REPOSITORY\", nargs=\"?\", default=\".\", help=\"The repository path, relative or absolute.\"\n    )\n\n    parser.add_argument(\n        \"-b\",\n        \"--bump-latest\",\n        action=\"store_true\",\n        dest=\"bump_latest\",\n        default=False,\n        help=\"Guess the new latest version by bumping the previous one based on the set of unreleased commits. \"\n        \"For example, if a commit contains breaking changes, bump the major number (or the minor number for 0.x versions). \"\n        \"Else if there are new features, bump the minor number. Else just bump the patch number.\",\n    )\n    parser.add_argument(\n        \"-h\", \"--help\", action=\"help\", default=argparse.SUPPRESS, help=\"Show this help message and exit.\"\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--in-place\",\n        action=\"store_true\",\n        dest=\"in_place\",\n        default=False,\n        help=\"Insert new entries (versions missing from changelog) in-place. \"\n        \"An output file must be specified. With custom templates, \"\n        \"you can pass two additional arguments: --version-regex and --marker-line. \"\n        \"When writing in-place, an 'in_place' variable \"\n        \"will be injected in the Jinja context, \"\n        \"allowing to adapt the generated contents \"\n        \"(for example to skip changelog headers or footers).\",\n    )\n    parser.add_argument(\n        \"-g\",\n        \"--version-regex\",\n        action=\"store\",\n        dest=\"version_regex\",\n        default=DEFAULT_VERSION_REGEX,\n        help=\"A regular expression to match versions in the existing changelog \"\n        \"(used to find the latest release) when writing in-place. \"\n        \"The regular expression must be a Python regex with a 'version' named group. \",\n    )\n\n    parser.add_argument(\n        \"-m\",\n        \"--marker-line\",\n        action=\"store\",\n        dest=\"marker_line\",\n        default=DEFAULT_MARKER_LINE,\n        help=\"A marker line at which to insert new entries \"\n        \"(versions missing from changelog). \"\n        \"If two marker lines are present in the changelog, \"\n        \"the contents between those two lines will be overwritten \"\n        \"(useful to update an 'Unreleased' entry for example).\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        action=\"store\",\n        dest=\"output\",\n        default=sys.stdout,\n        help=\"Output to given file. Default: stdout.\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--parse-refs\",\n        action=\"store_true\",\n        dest=\"parse_refs\",\n        default=False,\n        help=\"Parse provider-specific references in commit messages (GitHub/GitLab issues, PRs, etc.).\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--style\",\n        \"--commit-style\",\n        \"--convention\",\n        choices=CONVENTIONS,\n        default=\"basic\",\n        dest=\"convention\",\n        help=\"The commit convention to match against. Default: basic.\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--sections\",\n        action=\"store\",\n        type=_comma_separated_list,\n        default=None,\n        dest=\"sections\",\n        help=\"A comma-separated list of sections to render. \"\n        \"See the available sections for each supported convention in the description.\",\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--template\",\n        choices=Templates((\"angular\", \"keepachangelog\")),\n        default=\"keepachangelog\",\n        dest=\"template\",\n        help='The Jinja2 template to use. Prefix with \"path:\" to specify the path '\n        'to a directory containing a file named \"changelog.md\".',\n    )\n    parser.add_argument(\n        \"-T\",\n        \"--trailers\",\n        \"--git-trailers\",\n        action=\"store_true\",\n        default=False,\n        dest=\"parse_trailers\",\n        help=\"Parse Git trailers in the commit message. See https://git-scm.com/docs/git-interpret-trailers.\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--version\",\n        action=\"version\",\n        version=\"%(prog)s \" + get_version(),  # noqa: WPS323 (%)\n        help=\"Show the current version of the program and exit.\",\n    )\n    return parser\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_version","title":"<code>get_version()</code>","text":"<p>Return the current <code>git-changelog</code> version.</p> <p>Returns:</p> Type Description <code>str</code> <p>The current <code>git-changelog</code> version.</p> Source code in <code>git_changelog/cli.py</code> <pre><code>def get_version() -&gt; str:\n\"\"\"Return the current `git-changelog` version.\n\n    Returns:\n        The current `git-changelog` version.\n    \"\"\"\n    try:\n        return metadata.version(\"git-changelog\")\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.main","title":"<code>main(args=None)</code>","text":"<p>Run the main program.</p> <p>This function is executed when you type <code>git-changelog</code> or <code>python -m git_changelog</code>.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments passed from the command line.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>An exit code.</p> Source code in <code>git_changelog/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n\"\"\"Run the main program.\n\n    This function is executed when you type `git-changelog` or `python -m git_changelog`.\n\n    Arguments:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    parser = get_parser()\n    opts = parser.parse_args(args=args)\n\n    try:\n        build_and_render(\n            repository=opts.repository,\n            template=opts.template,\n            convention=opts.convention,\n            parse_refs=opts.parse_refs,\n            parse_trailers=opts.parse_trailers,\n            sections=opts.sections,\n            in_place=opts.in_place,\n            output=opts.output,\n            version_regex=opts.version_regex,\n            marker_line=opts.marker_line,\n            bump_latest=opts.bump_latest,\n        )\n    except ValueError as error:\n        print(f\"git-changelog: {error}\", file=sys.stderr)\n        return 1\n\n    return 0\n</code></pre>"},{"location":"reference/git_changelog/commit/","title":"commit","text":"<p>Module containing the commit logic.</p>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention","title":"<code>AngularConvention</code>","text":"<p>         Bases: <code>CommitConvention</code></p> <p>Angular commit message convention.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class AngularConvention(CommitConvention):\n\"\"\"Angular commit message convention.\"\"\"\n\n    TYPES: dict[str, str] = {\n        \"build\": \"Build\",\n        \"chore\": \"Chore\",\n        \"ci\": \"Continuous Integration\",\n        \"deps\": \"Dependencies\",\n        \"doc\": \"Docs\",\n        \"docs\": \"Docs\",\n        \"feat\": \"Features\",\n        \"fix\": \"Bug Fixes\",\n        \"perf\": \"Performance Improvements\",\n        \"ref\": \"Code Refactoring\",\n        \"refactor\": \"Code Refactoring\",\n        \"revert\": \"Reverts\",\n        \"style\": \"Style\",\n        \"test\": \"Tests\",\n        \"tests\": \"Tests\",\n    }\n    SUBJECT_REGEX: Pattern = re.compile(\n        r\"^(?P&lt;type&gt;(%s))(?:\\((?P&lt;scope&gt;.+)\\))?: (?P&lt;subject&gt;.+)$\" % (\"|\".join(TYPES.keys()))  # noqa: WPS323 (%)\n    )\n    BREAK_REGEX: Pattern = re.compile(r\"^break(s|ing changes?)?[ :].+$\", re.I | re.MULTILINE)\n    DEFAULT_RENDER: list[str] = [TYPES[\"feat\"], TYPES[\"fix\"], TYPES[\"revert\"], TYPES[\"refactor\"], TYPES[\"perf\"]]\n\n    def parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:  # noqa: D102 (use parent docstring)\n        subject = self.parse_subject(commit.subject)\n        message = \"\\n\".join([commit.subject] + commit.body)\n        is_major = self.is_major(message)\n        is_minor = not is_major and self.is_minor(subject[\"type\"])\n        is_patch = not any((is_major, is_minor))\n\n        return {\n            \"type\": subject[\"type\"],\n            \"scope\": subject[\"scope\"],\n            \"subject\": subject[\"subject\"],\n            \"is_major\": is_major,\n            \"is_minor\": is_minor,\n            \"is_patch\": is_patch,\n        }\n\n    def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n\"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n        Arguments:\n            commit_subject: The commit message subject.\n\n        Returns:\n            The parsed data.\n        \"\"\"\n        subject_match = self.SUBJECT_REGEX.match(commit_subject)\n        if subject_match:\n            dct = subject_match.groupdict()\n            dct[\"type\"] = self.TYPES[dct[\"type\"]]\n            return dct\n        return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n\n    def is_minor(self, commit_type: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a minor bump.\n\n        Arguments:\n            commit_type: The commit type.\n\n        Returns:\n            Whether it's a minor commit.\n        \"\"\"\n        return commit_type == self.TYPES[\"feat\"]\n\n    def is_major(self, commit_message: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a major bump.\n\n        Arguments:\n            commit_message: The commit message.\n\n        Returns:\n            Whether it's a major commit.\n        \"\"\"\n        return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_major","title":"<code>is_major(commit_message)</code>","text":"<p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> Name Type Description Default <code>commit_message</code> <code>str</code> <p>The commit message.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether it's a major commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_minor","title":"<code>is_minor(commit_type)</code>","text":"<p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> Name Type Description Default <code>commit_type</code> <code>str</code> <p>The commit type.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether it's a minor commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"feat\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.parse_subject","title":"<code>parse_subject(commit_subject)</code>","text":"<p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> <p>Parameters:</p> Name Type Description Default <code>commit_subject</code> <code>str</code> <p>The commit message subject.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The parsed data.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n\"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The parsed data.\n    \"\"\"\n    subject_match = self.SUBJECT_REGEX.match(commit_subject)\n    if subject_match:\n        dct = subject_match.groupdict()\n        dct[\"type\"] = self.TYPES[dct[\"type\"]]\n        return dct\n    return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AtomConvention","title":"<code>AtomConvention</code>","text":"<p>         Bases: <code>CommitConvention</code></p> <p>Atom commit message convention.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class AtomConvention(CommitConvention):\n\"\"\"Atom commit message convention.\"\"\"\n\n    TYPES: dict[str, str] = {\n        \":art:\": \"\",  # when improving the format/structure of the code\n        \":racehorse:\": \"\",  # when improving performance\n        \":non-potable_water:\": \"\",  # when plugging memory leaks\n        \":memo:\": \"\",  # when writing docs\n        \":penguin:\": \"\",  # when fixing something on Linux\n        \":apple:\": \"\",  # when fixing something on Mac OS\n        \":checkered_flag:\": \"\",  # when fixing something on Windows\n        \":bug:\": \"\",  # when fixing a bug\n        \":fire:\": \"\",  # when removing code or files\n        \":green_heart:\": \"\",  # when fixing the CI build\n        \":white_check_mark:\": \"\",  # when adding tests\n        \":lock:\": \"\",  # when dealing with security\n        \":arrow_up:\": \"\",  # when upgrading dependencies\n        \":arrow_down:\": \"\",  # when downgrading dependencies\n        \":shirt:\": \"\",  # when removing linter warnings\n    }\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention","title":"<code>BasicConvention</code>","text":"<p>         Bases: <code>CommitConvention</code></p> <p>Basic commit message convention.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class BasicConvention(CommitConvention):\n\"\"\"Basic commit message convention.\"\"\"\n\n    TYPES: dict[str, str] = {\n        \"add\": \"Added\",\n        \"fix\": \"Fixed\",\n        \"change\": \"Changed\",\n        \"remove\": \"Removed\",\n        \"merge\": \"Merged\",\n        \"doc\": \"Documented\",\n    }\n\n    TYPE_REGEX: Pattern = re.compile(r\"^(?P&lt;type&gt;(%s))\" % \"|\".join(TYPES.keys()), re.I)  # noqa: WPS323\n    BREAK_REGEX: Pattern = re.compile(r\"^break(s|ing changes?)?[ :].+$\", re.I | re.MULTILINE)\n    DEFAULT_RENDER: list[str] = [TYPES[\"add\"], TYPES[\"fix\"], TYPES[\"change\"], TYPES[\"remove\"]]\n\n    def parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:  # noqa: D102 (use parent docstring)\n        commit_type = self.parse_type(commit.subject)\n        message = \"\\n\".join([commit.subject] + commit.body)\n        is_major = self.is_major(message)\n        is_minor = not is_major and self.is_minor(commit_type)\n        is_patch = not any((is_major, is_minor))\n\n        return {\"type\": commit_type, \"is_major\": is_major, \"is_minor\": is_minor, \"is_patch\": is_patch}\n\n    def parse_type(self, commit_subject: str) -&gt; str:\n\"\"\"Parse the type of the commit given its subject.\n\n        Arguments:\n            commit_subject: The commit message subject.\n\n        Returns:\n            The commit type.\n        \"\"\"\n        type_match = self.TYPE_REGEX.match(commit_subject)\n        if type_match:\n            return self.TYPES.get(type_match.groupdict()[\"type\"].lower(), \"\")\n        return \"\"\n\n    def is_minor(self, commit_type: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a minor bump.\n\n        Arguments:\n            commit_type: The commit type.\n\n        Returns:\n            Whether it's a minor commit.\n        \"\"\"\n        return commit_type == self.TYPES[\"add\"]\n\n    def is_major(self, commit_message: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a major bump.\n\n        Arguments:\n            commit_message: The commit message.\n\n        Returns:\n            Whether it's a major commit.\n        \"\"\"\n        return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_major","title":"<code>is_major(commit_message)</code>","text":"<p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> Name Type Description Default <code>commit_message</code> <code>str</code> <p>The commit message.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether it's a major commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_minor","title":"<code>is_minor(commit_type)</code>","text":"<p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> Name Type Description Default <code>commit_type</code> <code>str</code> <p>The commit type.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether it's a minor commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n\"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"add\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.parse_type","title":"<code>parse_type(commit_subject)</code>","text":"<p>Parse the type of the commit given its subject.</p> <p>Parameters:</p> Name Type Description Default <code>commit_subject</code> <code>str</code> <p>The commit message subject.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The commit type.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>def parse_type(self, commit_subject: str) -&gt; str:\n\"\"\"Parse the type of the commit given its subject.\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The commit type.\n    \"\"\"\n    type_match = self.TYPE_REGEX.match(commit_subject)\n    if type_match:\n        return self.TYPES.get(type_match.groupdict()[\"type\"].lower(), \"\")\n    return \"\"\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit","title":"<code>Commit</code>","text":"<p>A class to represent a commit.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class Commit:\n\"\"\"A class to represent a commit.\"\"\"\n\n    def __init__(  # noqa: WPS231\n        self,\n        commit_hash: str,\n        author_name: str = \"\",\n        author_email: str = \"\",\n        author_date: str | datetime = \"\",\n        committer_name: str = \"\",\n        committer_email: str = \"\",\n        committer_date: str | datetime = \"\",\n        refs: str = \"\",\n        subject: str = \"\",\n        body: list[str] | None = None,\n        url: str = \"\",\n        parse_trailers: bool = False,\n    ):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            commit_hash: The commit hash.\n            author_name: The author name.\n            author_email: The author email.\n            author_date: The authoring date (datetime or UTC timestamp).\n            committer_name: The committer name.\n            committer_email: The committer email.\n            committer_date: The committing date (datetime or UTC timestamp).\n            refs: The commit refs.\n            subject: The commit message subject.\n            body: The commit message body.\n            url: The commit URL.\n            parse_trailers: Whether to parse Git trailers.\n        \"\"\"\n        if not author_date:\n            author_date = datetime.now()\n        elif isinstance(author_date, str):\n            author_date = datetime.utcfromtimestamp(float(author_date))\n        if not committer_date:\n            committer_date = datetime.now()\n        elif isinstance(committer_date, str):\n            committer_date = datetime.utcfromtimestamp(float(committer_date))\n\n        self.hash: str = commit_hash\n        self.author_name: str = author_name\n        self.author_email: str = author_email\n        self.author_date: datetime = author_date\n        self.committer_name: str = committer_name\n        self.committer_email: str = committer_email\n        self.committer_date: datetime = committer_date\n        self.subject: str = subject\n        self.body: list[str] = _clean_body(body) if body else []\n        self.url: str = url\n\n        tag = \"\"\n        for ref in refs.split(\",\"):\n            ref = ref.strip()\n            if ref.startswith(\"tag: \"):\n                tag = ref.replace(\"tag: \", \"\")\n                break\n        self.tag: str = tag\n        self.version: str = tag\n\n        self.text_refs: dict[str, list[Ref]] = {}\n        self.convention: dict[str, Any] = {}\n\n        self.trailers: dict[str, str] = {}\n        self.body_without_trailers = self.body\n\n        if parse_trailers:\n            self._parse_trailers()\n\n    def update_with_convention(self, convention: CommitConvention) -&gt; None:\n\"\"\"\n        Apply the convention-parsed data to this commit.\n\n        Arguments:\n            convention: The convention to use.\n        \"\"\"\n        self.convention.update(convention.parse_commit(self))\n\n    def update_with_provider(self, provider: ProviderRefParser, parse_refs: bool = True) -&gt; None:  # noqa: WPS231\n\"\"\"\n        Apply the provider-parsed data to this commit.\n\n        Arguments:\n            provider: The provider to use.\n            parse_refs: Whether to parse references for this provider.\n        \"\"\"\n        # set the commit url based on provider\n        # FIXME: hardcoded 'commits'\n        if \"commits\" in provider.REF:\n            self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n        else:\n            # use default \"commit\" url (could be wrong)\n            self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n        # build commit text references from its subject and body\n        if parse_refs:\n            for ref_type in provider.REF.keys():\n                self.text_refs[ref_type] = provider.get_refs(ref_type, \"\\n\".join([self.subject] + self.body))\n\n            if \"issues\" in self.text_refs:\n                self.text_refs[\"issues_not_in_subject\"] = []\n                for issue in self.text_refs[\"issues\"]:\n                    if issue.ref not in self.subject:\n                        self.text_refs[\"issues_not_in_subject\"].append(issue)\n\n    def _parse_trailers(self) -&gt; None:\n        last_blank_line = -1\n        for index, line in enumerate(self.body):\n            if not line:\n                last_blank_line = index\n        with suppress(ValueError):\n            trailers = self._parse_trailers_block(self.body[last_blank_line + 1 :])\n            if trailers:\n                self.trailers.update(trailers)\n                self.body_without_trailers = self.body[:last_blank_line]\n\n    def _parse_trailers_block(self, lines: list[str]) -&gt; dict[str, str]:\n        trailers = {}\n        for line in lines:\n            title, value = line.split(\": \", 1)\n            trailers[title] = value.strip()\n        return trailers  # or raise ValueError due to split unpacking\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.__init__","title":"<code>__init__(commit_hash, author_name='', author_email='', author_date='', committer_name='', committer_email='', committer_date='', refs='', subject='', body=None, url='', parse_trailers=False)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>commit_hash</code> <code>str</code> <p>The commit hash.</p> required <code>author_name</code> <code>str</code> <p>The author name.</p> <code>''</code> <code>author_email</code> <code>str</code> <p>The author email.</p> <code>''</code> <code>author_date</code> <code>str | datetime</code> <p>The authoring date (datetime or UTC timestamp).</p> <code>''</code> <code>committer_name</code> <code>str</code> <p>The committer name.</p> <code>''</code> <code>committer_email</code> <code>str</code> <p>The committer email.</p> <code>''</code> <code>committer_date</code> <code>str | datetime</code> <p>The committing date (datetime or UTC timestamp).</p> <code>''</code> <code>refs</code> <code>str</code> <p>The commit refs.</p> <code>''</code> <code>subject</code> <code>str</code> <p>The commit message subject.</p> <code>''</code> <code>body</code> <code>list[str] | None</code> <p>The commit message body.</p> <code>None</code> <code>url</code> <code>str</code> <p>The commit URL.</p> <code>''</code> <code>parse_trailers</code> <code>bool</code> <p>Whether to parse Git trailers.</p> <code>False</code> Source code in <code>git_changelog/commit.py</code> <pre><code>def __init__(  # noqa: WPS231\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    parse_trailers: bool = False,\n):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()\n    elif isinstance(author_date, str):\n        author_date = datetime.utcfromtimestamp(float(author_date))\n    if not committer_date:\n        committer_date = datetime.now()\n    elif isinstance(committer_date, str):\n        committer_date = datetime.utcfromtimestamp(float(committer_date))\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()\n        if ref.startswith(\"tag: \"):\n            tag = ref.replace(\"tag: \", \"\")\n            break\n    self.tag: str = tag\n    self.version: str = tag\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_convention","title":"<code>update_with_convention(convention)</code>","text":"<p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> Name Type Description Default <code>convention</code> <code>CommitConvention</code> <p>The convention to use.</p> required Source code in <code>git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n\"\"\"\n    Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_provider","title":"<code>update_with_provider(provider, parse_refs=True)</code>","text":"<p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>ProviderRefParser</code> <p>The provider to use.</p> required <code>parse_refs</code> <code>bool</code> <p>Whether to parse references for this provider.</p> <code>True</code> Source code in <code>git_changelog/commit.py</code> <pre><code>def update_with_provider(self, provider: ProviderRefParser, parse_refs: bool = True) -&gt; None:  # noqa: WPS231\n\"\"\"\n    Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF.keys():\n            self.text_refs[ref_type] = provider.get_refs(ref_type, \"\\n\".join([self.subject] + self.body))\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention","title":"<code>CommitConvention</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A base class for a convention of commit messages.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class CommitConvention(ABC):\n\"\"\"A base class for a convention of commit messages.\"\"\"\n\n    TYPES: dict[str, str]\n    TYPE_REGEX: Pattern\n    BREAK_REGEX: Pattern\n    DEFAULT_RENDER: list[str]\n\n    @abstractmethod\n    def parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:\n\"\"\"\n        Parse the commit to extract information.\n\n        Arguments:\n            commit: The commit to parse.\n\n        Returns:\n            A dictionary containing the parsed data.\n        \"\"\"  # noqa: DAR202,DAR401\n        raise NotImplementedError\n\n    @classmethod\n    def _format_sections_help(cls):\n        reversed_map = defaultdict(list)\n        for section_type, section_title in cls.TYPES.items():\n            reversed_map[section_title].append(section_type)\n        default_sections = cls.DEFAULT_RENDER\n        default = \"- \" + \"\\n- \".join(f\"{', '.join(reversed_map[title])}: {title}\" for title in default_sections)\n        additional = \"- \" + \"\\n- \".join(\n            f\"{', '.join(types)}: {title}\" for title, types in reversed_map.items() if title not in default_sections\n        )\n        return re.sub(\n            r\"\\n *\",\n            \"\\n\",\n            f\"\"\"\n{cls.__name__.replace('Convention', '').upper()} CONVENTION\n\n            Default sections:\n{default}\n\n            Additional sections:\n{additional}\n            \"\"\",\n        )\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention.parse_commit","title":"<code>parse_commit(commit)</code>  <code>abstractmethod</code>","text":"<p>Parse the commit to extract information.</p> <p>Parameters:</p> Name Type Description Default <code>commit</code> <code>Commit</code> <p>The commit to parse.</p> required <p>Returns:</p> Type Description <code>dict[str, str | bool]</code> <p>A dictionary containing the parsed data.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>@abstractmethod\ndef parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:\n\"\"\"\n    Parse the commit to extract information.\n\n    Arguments:\n        commit: The commit to parse.\n\n    Returns:\n        A dictionary containing the parsed data.\n    \"\"\"  # noqa: DAR202,DAR401\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention","title":"<code>ConventionalCommitConvention</code>","text":"<p>         Bases: <code>AngularConvention</code></p> <p>Conventional commit message convention.</p> Source code in <code>git_changelog/commit.py</code> <pre><code>class ConventionalCommitConvention(AngularConvention):\n\"\"\"Conventional commit message convention.\"\"\"\n\n    TYPES: dict[str, str] = AngularConvention.TYPES\n    DEFAULT_RENDER: list[str] = AngularConvention.DEFAULT_RENDER\n    SUBJECT_REGEX: Pattern = re.compile(\n        r\"^(?P&lt;type&gt;(%s))(?:\\((?P&lt;scope&gt;.+)\\))?(?P&lt;breaking&gt;!)?: (?P&lt;subject&gt;.+)$\"  # noqa: WPS323 (%)\n        % (\"|\".join(TYPES.keys()))\n    )\n\n    def parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:  # noqa: D102 (use parent docstring)\n        subject = self.parse_subject(commit.subject)\n        message = \"\\n\".join([commit.subject] + commit.body)\n        is_major = self.is_major(message) or subject.get(\"breaking\") == \"!\"\n        is_minor = not is_major and self.is_minor(subject[\"type\"])\n        is_patch = not any((is_major, is_minor))\n\n        return {\n            \"type\": subject[\"type\"],\n            \"scope\": subject[\"scope\"],\n            \"subject\": subject[\"subject\"],\n            \"is_major\": is_major,\n            \"is_minor\": is_minor,\n            \"is_patch\": is_patch,\n        }\n</code></pre>"},{"location":"reference/git_changelog/providers/","title":"providers","text":"<p>Module containing the parsing utilities for git providers.</p>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub","title":"<code>GitHub</code>","text":"<p>         Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class GitHub(ProviderRefParser):\n\"\"\"A parser for the GitHub references.\"\"\"\n\n    url: str = \"https://github.com\"\n    project_url: str = \"{base_url}/{namespace}/{project}\"\n    tag_url: str = \"{base_url}/{namespace}/{project}/releases/tag/{ref}\"\n\n    commit_min_length = 8\n    commit_max_length = 40\n\n    REF: dict[str, RefDef] = {\n        \"issues\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=\"#\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues/{ref}\",\n        ),\n        \"commits\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit}{ba}\".format(\n                    np=RefRe.NP, commit=RefRe.COMMIT.format(min=commit_min_length, max=commit_max_length), ba=RefRe.BA\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/commit/{ref}\",\n        ),\n        \"commits_ranges\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit_range}\".format(\n                    np=RefRe.NP, commit_range=RefRe.COMMIT_RANGE.format(min=commit_min_length, max=commit_max_length)\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/compare/{ref}\",\n        ),\n        \"mentions\": RefDef(regex=re.compile(RefRe.BB + RefRe.MENTION, re.I), url_string=\"{base_url}/{ref}\"),\n    }\n\n    def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            namespace: The GitHub namespace.\n            project: The GitHub project.\n            url: The GitHub URL.\n        \"\"\"\n        self.namespace: str = namespace\n        self.project: str = project\n        self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n\n    def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:  # noqa: D102 (use parent docstring)\n        match_dict[\"base_url\"] = self.url\n        if not match_dict.get(\"namespace\"):\n            match_dict[\"namespace\"] = self.namespace\n        if not match_dict.get(\"project\"):\n            match_dict[\"project\"] = self.project\n        return super().build_ref_url(ref_type, match_dict)\n\n    def get_tag_url(self, tag: str = \"\") -&gt; str:  # noqa: D102,WPS615\n        return self.tag_url.format(base_url=self.url, namespace=self.namespace, project=self.project, ref=tag)\n\n    def get_compare_url(self, base: str, target: str) -&gt; str:  # noqa: D102 (use parent docstring)\n        return self.build_ref_url(\"commits_ranges\", {\"ref\": f\"{base}...{target}\"})\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.__init__","title":"<code>__init__(namespace, project, url=url)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>The GitHub namespace.</p> required <code>project</code> <code>str</code> <p>The GitHub project.</p> required <code>url</code> <code>str</code> <p>The GitHub URL.</p> <code>url</code> Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        namespace: The GitHub namespace.\n        project: The GitHub project.\n        url: The GitHub URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab","title":"<code>GitLab</code>","text":"<p>         Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class GitLab(ProviderRefParser):\n\"\"\"A parser for the GitLab references.\"\"\"\n\n    url: str = \"https://gitlab.com\"\n    project_url: str = \"{base_url}/{namespace}/{project}\"\n    tag_url: str = \"{base_url}/{namespace}/{project}/tags/{ref}\"\n\n    commit_min_length = 8\n    commit_max_length = 40\n\n    REF: dict[str, RefDef] = {\n        \"issues\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=\"#\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues/{ref}\",\n        ),\n        \"merge_requests\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"!\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/merge_requests/{ref}\",\n        ),\n        \"snippets\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"\\$\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/snippets/{ref}\",\n        ),\n        \"labels_ids\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"~\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",  # no label_id param?\n        ),\n        \"labels_one_word\": RefDef(\n            regex=re.compile(  # also matches label IDs\n                RefRe.BB + RefRe.NP + \"?\" + RefRe.ONE_WORD.format(symbol=r\"~\"), re.I\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",\n        ),\n        \"labels_multi_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.MULTI_WORD.format(symbol=r\"~\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/issues?label_name[]={ref}\",\n        ),\n        \"milestones_ids\": RefDef(\n            regex=re.compile(  # also matches milestones IDs\n                RefRe.BB + RefRe.NP + \"?\" + RefRe.ID.format(symbol=r\"%\"), re.I\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/milestones/{ref}\",\n        ),\n        \"milestones_one_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.ONE_WORD.format(symbol=r\"%\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/milestones\",  # cannot guess ID\n        ),\n        \"milestones_multi_word\": RefDef(\n            regex=re.compile(RefRe.BB + RefRe.NP + \"?\" + RefRe.MULTI_WORD.format(symbol=r\"%\"), re.I),\n            url_string=\"{base_url}/{namespace}/{project}/milestones\",  # cannot guess ID\n        ),\n        \"commits\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit}{ba}\".format(\n                    np=RefRe.NP, commit=RefRe.COMMIT.format(min=commit_min_length, max=commit_max_length), ba=RefRe.BA\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/commit/{ref}\",\n        ),\n        \"commits_ranges\": RefDef(\n            regex=re.compile(\n                RefRe.BB\n                + r\"(?:{np}@)?{commit_range}\".format(\n                    np=RefRe.NP, commit_range=RefRe.COMMIT_RANGE.format(min=commit_min_length, max=commit_max_length)\n                ),\n                re.I,\n            ),\n            url_string=\"{base_url}/{namespace}/{project}/compare/{ref}\",\n        ),\n        \"mentions\": RefDef(regex=re.compile(RefRe.BB + RefRe.MENTION, re.I), url_string=\"{base_url}/{ref}\"),\n    }\n\n    def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            namespace: The GitLab namespace.\n            project: The GitLab project.\n            url: The GitLab URL.\n        \"\"\"\n        self.namespace: str = namespace\n        self.project: str = project\n        self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n\n    def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:  # noqa: D102 (use parent docstring)\n        match_dict[\"base_url\"] = self.url\n        if not match_dict.get(\"namespace\"):\n            match_dict[\"namespace\"] = self.namespace\n        if not match_dict.get(\"project\"):\n            match_dict[\"project\"] = self.project\n        if ref_type.startswith(\"label\"):\n            match_dict[\"ref\"] = match_dict[\"ref\"].replace('\"', \"\").replace(\" \", \"+\")\n        return super().build_ref_url(ref_type, match_dict)\n\n    def get_tag_url(self, tag: str = \"\") -&gt; str:  # noqa: D102,WPS615\n        return self.tag_url.format(base_url=self.url, namespace=self.namespace, project=self.project, ref=tag)\n\n    def get_compare_url(self, base: str, target: str) -&gt; str:  # noqa: D102 (use parent docstring)\n        return self.build_ref_url(\"commits_ranges\", {\"ref\": f\"{base}...{target}\"})\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.__init__","title":"<code>__init__(namespace, project, url=url)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>The GitLab namespace.</p> required <code>project</code> <code>str</code> <p>The GitLab project.</p> required <code>url</code> <code>str</code> <p>The GitLab URL.</p> <code>url</code> Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str = url):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        namespace: The GitLab namespace.\n        project: The GitLab project.\n        url: The GitLab URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url  # noqa: WPS601 (shadowing but uses class' as default)\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser","title":"<code>ProviderRefParser</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A base class for specific providers reference parsers.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class ProviderRefParser(ABC):\n\"\"\"A base class for specific providers reference parsers.\"\"\"\n\n    url: str\n    namespace: str\n    project: str\n    REF: dict[str, RefDef] = {}\n\n    def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n\"\"\"\n        Find all references in the given text.\n\n        Arguments:\n            ref_type: The reference type.\n            text: The text in which to search references.\n\n        Returns:\n            A list of references (instances of [Ref][git_changelog.providers.Ref]).\n        \"\"\"\n        return [\n            Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n            for match in self.parse_refs(ref_type, text)\n        ]\n\n    def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n\"\"\"\n        Parse references in the given text.\n\n        Arguments:\n            ref_type: The reference type.\n            text: The text to parse.\n\n        Returns:\n            A list of regular expressions matches.\n        \"\"\"\n        if ref_type not in self.REF:\n            refs = [key for key in self.REF.keys() if key.startswith(ref_type)]\n            return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n        return list(self.REF[ref_type].regex.finditer(text))\n\n    def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:\n\"\"\"\n        Build the URL for a reference type and a dictionary of matched groups.\n\n        Arguments:\n            ref_type: The reference type.\n            match_dict: The matched groups.\n\n        Returns:\n            The built URL.\n        \"\"\"\n        return self.REF[ref_type].url_string.format(**match_dict)\n\n    @abstractmethod\n    def get_tag_url(self, tag: str) -&gt; str:\n\"\"\"\n        Get the URL for a git tag.\n\n        Arguments:\n            tag: The git tag.\n\n        Returns:\n            The tag URL.\n        \"\"\"  # noqa: DAR202,DAR401\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_compare_url(self, base: str, target: str) -&gt; str:\n\"\"\"\n        Get the URL for a tag comparison.\n\n        Arguments:\n            base: The base tag.\n            target: The target tag.\n\n        Returns:\n            The comparison URL.\n        \"\"\"  # noqa: DAR202,DAR401\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.build_ref_url","title":"<code>build_ref_url(ref_type, match_dict)</code>","text":"<p>Build the URL for a reference type and a dictionary of matched groups.</p> <p>Parameters:</p> Name Type Description Default <code>ref_type</code> <code>str</code> <p>The reference type.</p> required <code>match_dict</code> <code>dict[str, str]</code> <p>The matched groups.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The built URL.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:\n\"\"\"\n    Build the URL for a reference type and a dictionary of matched groups.\n\n    Arguments:\n        ref_type: The reference type.\n        match_dict: The matched groups.\n\n    Returns:\n        The built URL.\n    \"\"\"\n    return self.REF[ref_type].url_string.format(**match_dict)\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_compare_url","title":"<code>get_compare_url(base, target)</code>  <code>abstractmethod</code>","text":"<p>Get the URL for a tag comparison.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str</code> <p>The base tag.</p> required <code>target</code> <code>str</code> <p>The target tag.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comparison URL.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_compare_url(self, base: str, target: str) -&gt; str:\n\"\"\"\n    Get the URL for a tag comparison.\n\n    Arguments:\n        base: The base tag.\n        target: The target tag.\n\n    Returns:\n        The comparison URL.\n    \"\"\"  # noqa: DAR202,DAR401\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_refs","title":"<code>get_refs(ref_type, text)</code>","text":"<p>Find all references in the given text.</p> <p>Parameters:</p> Name Type Description Default <code>ref_type</code> <code>str</code> <p>The reference type.</p> required <code>text</code> <code>str</code> <p>The text in which to search references.</p> required <p>Returns:</p> Type Description <code>list[Ref]</code> <p>A list of references (instances of Ref).</p> Source code in <code>git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n\"\"\"\n    Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_tag_url","title":"<code>get_tag_url(tag)</code>  <code>abstractmethod</code>","text":"<p>Get the URL for a git tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The git tag.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The tag URL.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_tag_url(self, tag: str) -&gt; str:\n\"\"\"\n    Get the URL for a git tag.\n\n    Arguments:\n        tag: The git tag.\n\n    Returns:\n        The tag URL.\n    \"\"\"  # noqa: DAR202,DAR401\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.parse_refs","title":"<code>parse_refs(ref_type, text)</code>","text":"<p>Parse references in the given text.</p> <p>Parameters:</p> Name Type Description Default <code>ref_type</code> <code>str</code> <p>The reference type.</p> required <code>text</code> <code>str</code> <p>The text to parse.</p> required <p>Returns:</p> Type Description <code>list[Match]</code> <p>A list of regular expressions matches.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n\"\"\"\n    Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF.keys() if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref","title":"<code>Ref</code>","text":"<p>A class to represent a reference and its URL.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class Ref:\n\"\"\"A class to represent a reference and its URL.\"\"\"\n\n    def __init__(self, ref: str, url: str) -&gt; None:\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            ref: The reference text.\n            url: The reference URL.\n        \"\"\"\n        self.ref: str = ref\n        self.url: str = url\n\n    def __str__(self):\n        return self.ref + \": \" + self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref.__init__","title":"<code>__init__(ref, url)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference text.</p> required <code>url</code> <code>str</code> <p>The reference URL.</p> required Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, ref: str, url: str) -&gt; None:\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        ref: The reference text.\n        url: The reference URL.\n    \"\"\"\n    self.ref: str = ref\n    self.url: str = url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef","title":"<code>RefDef</code>","text":"<p>A class to store a reference regular expression and URL building string.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class RefDef:\n\"\"\"A class to store a reference regular expression and URL building string.\"\"\"\n\n    def __init__(self, regex: Pattern, url_string: str):\n\"\"\"\n        Initialization method.\n\n        Arguments:\n            regex: The regular expression to match the reference.\n            url_string: The URL string to format using matched groups.\n        \"\"\"\n        self.regex = regex\n        self.url_string = url_string\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef.__init__","title":"<code>__init__(regex, url_string)</code>","text":"<p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>Pattern</code> <p>The regular expression to match the reference.</p> required <code>url_string</code> <code>str</code> <p>The URL string to format using matched groups.</p> required Source code in <code>git_changelog/providers.py</code> <pre><code>def __init__(self, regex: Pattern, url_string: str):\n\"\"\"\n    Initialization method.\n\n    Arguments:\n        regex: The regular expression to match the reference.\n        url_string: The URL string to format using matched groups.\n    \"\"\"\n    self.regex = regex\n    self.url_string = url_string\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefRe","title":"<code>RefRe</code>","text":"<p>An enum helper to store parts of regular expressions for references.</p> Source code in <code>git_changelog/providers.py</code> <pre><code>class RefRe:\n\"\"\"An enum helper to store parts of regular expressions for references.\"\"\"\n\n    BB = r\"(?:^|[\\s,])\"  # blank before\n    BA = r\"(?:[\\s,]|$)\"  # blank after\n    NP = r\"(?:(?P&lt;namespace&gt;[-\\w]+)/)?(?P&lt;project&gt;[-\\w]+)\"  # namespace and project\n    ID = r\"{symbol}(?P&lt;ref&gt;[1-9]\\d*)\"\n    ONE_WORD = r\"{symbol}(?P&lt;ref&gt;\\w*[-a-z_ ][-\\w]*)\"\n    MULTI_WORD = r'{symbol}(?P&lt;ref&gt;\"\\w[- \\w]*\")'\n    COMMIT = r\"(?P&lt;ref&gt;[0-9a-f]{{{min},{max}}})\"\n    COMMIT_RANGE = r\"(?P&lt;ref&gt;[0-9a-f]{{{min},{max}}}\\.\\.\\.[0-9a-f]{{{min},{max}}})\"\n    MENTION = r\"@(?P&lt;ref&gt;\\w[-\\w]*)\"\n</code></pre>"},{"location":"reference/git_changelog/templates/","title":"templates","text":"<p>The subpackage containing the builtin templates.</p>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.configure_env","title":"<code>configure_env(env)</code>","text":"<p>Configure the Jinja environment.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Environment</code> <p>The environment to configure.</p> required Source code in <code>git_changelog/templates/__init__.py</code> <pre><code>def configure_env(env: Environment) -&gt; None:\n\"\"\"Configure the Jinja environment.\n\n    Parameters:\n        env: The environment to configure.\n    \"\"\"\n    env.filters.update({\"is_url\": _filter_is_url})\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_custom_template","title":"<code>get_custom_template(path)</code>","text":"<p>Get a custom template instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the custom template.</p> required <p>Returns:</p> Type Description <code>Template</code> <p>The Jinja template.</p> Source code in <code>git_changelog/templates/__init__.py</code> <pre><code>def get_custom_template(path: str | Path) -&gt; Template:\n\"\"\"Get a custom template instance.\n\n    Arguments:\n        path: Path to the custom template.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(Path(path).read_text())\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_template","title":"<code>get_template(name)</code>","text":"<p>Get a builtin template instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The template name.</p> required <p>Returns:</p> Type Description <code>Template</code> <p>The Jinja template.</p> Source code in <code>git_changelog/templates/__init__.py</code> <pre><code>def get_template(name: str) -&gt; Template:\n\"\"\"Get a builtin template instance.\n\n    Arguments:\n        name: The template name.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(TEMPLATES_PATH.joinpath(f\"{name}.md.jinja\").read_text())\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}