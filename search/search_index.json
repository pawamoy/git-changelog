{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"git-changelog","text":"<p>Automatic Changelog generator using Jinja2 templates. From git logs to change logs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Jinja2 templates!   You get full control over the rendering.   Built-in Keep a Changelog and Angular templates   (also see Conventional Changelog).</li> <li>Commit styles/conventions parsing.   Built-in Angular, Conventional Commit and basic conventions.</li> <li>Git service/provider agnostic,   plus references parsing (issues, commits, etc.).   Built-in GitHub, Gitlab and Bitbucket support.</li> <li>Understands SemVer and PEP 440 versioning schemes.   Guesses next version based on last commits.</li> <li>Parses Git trailers, allowing to reference   issues, PRs, etc., in your commit messages   in a clean, provider-agnostic way.</li> <li> <p>Template context injection,   to furthermore customize how your changelog will be rendered.</p> </li> <li> <p>Todo:</p> <ul> <li>Plugin architecture,   to support more commit conventions and git services.</li> <li>Easy access to \"Breaking Changes\" in the templates.</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>:</p> <pre><code>pip install git-changelog\n</code></pre> <p>With <code>pipx</code>:</p> <pre><code>python3.8 -m pip install --user pipx\npipx install git-changelog\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Simply run <code>git-changelog</code> in your repository to output a changelog on standard output. To show the different options and their descriptions, use <code>git-changelog -h</code>.</p> <ul> <li>See Quick usage   for some command line examples.</li> <li>See Configuration   to learn how to configure git-changelog for your project.</li> <li>See the CLI reference   and the API reference for more information.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#251-2024-04-02","title":"2.5.1 - 2024-04-02","text":"<p>Compare with 2.5.0</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Declare dependency to packaging (29c4fa8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#250-2024-04-02","title":"2.5.0 - 2024-04-02","text":"<p>Compare with 2.4.1</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add CLI and configuration option <code>-n</code>, <code>--versioning</code> to select versioning scheme (f9c91f1 by Timoth\u00e9e Mazzucotelli).</li> <li>Implement SemVer and PEP 440 versioning schemes (f7c8bfa by Timoth\u00e9e Mazzucotelli).</li> <li>Support for additional template variables (58a4d88 by Christian Meffert). Issue-17, PR-73, Co-authored-by: Timoth\u00e9e Mazzucotelli dev@pawamoy.fr</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Deduplicate commits for unreleased version with merged branches (b61199f by Christian Meffert). PR-76</li> <li>Handle no remote gracefully (92f6f94 by Christian Meffert). Issue-24, PR-75</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Ignore tags that are not valid given versioning scheme (5fdc68a by Timoth\u00e9e Mazzucotelli). Co-authored-by: Christian Meffert chme@users.noreply.github.com</li> </ul>"},{"location":"changelog/#241-2024-03-14","title":"2.4.1 - 2024-03-14","text":"<p>Compare with 2.4.0</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Assign commits to versions following their commit graph (follow SemVer) (f191ed7 by Christian Meffert). Issue-70, Issue-42, PR-72, Co-authored-by: Timoth\u00e9e Mazzucotelli dev@pawamoy.fr</li> <li>Ignore bump on new Git repo without unreleased commits (438968c by Christian Meffert). PR-71</li> <li>Use provided version when creating first changelog entry (dd264cc by Christian Meffert). PR-69</li> </ul>"},{"location":"changelog/#240-2023-11-04","title":"2.4.0 - 2023-11-04","text":"<p>Compare with 2.3.2</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add option to enable/disable \"ZeroVer\" behavior (7d0c259 by Mark Minakov). Issue #57, PR #58, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add <code>-F,--filter-commits</code> to filter by revision-range (e016965 by Pedro Brochado). Issue #63, Issue #16, PR #64, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Always output release notes to stdout (1e44bca by Timoth\u00e9e Mazzucotelli). Issue #65</li> </ul>"},{"location":"changelog/#232-2023-10-25","title":"2.3.2 - 2023-10-25","text":"<p>Compare with 2.3.1</p>"},{"location":"changelog/#dependencies_1","title":"Dependencies","text":"<ul> <li>Use tomli instead of toml on Python less than 3.11 (37f7cf1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#231-2023-10-10","title":"2.3.1 - 2023-10-10","text":"<p>Compare with 2.3.0</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Remove any credentials from remote URLs, not just GitHub tokens (5d07e91 by Timoth\u00e9e Mazzucotelli). Issue #61</li> </ul>"},{"location":"changelog/#230-2023-10-08","title":"2.3.0 - 2023-10-08","text":"<p>Compare with 2.2.0</p>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>CLI argument <code>--bump-latest</code> and API parameter <code>bump_latest</code>     are deprecated in favor of <code>--bump=auto</code> and <code>bump=\"auto\"</code>     argument and parameter, respectively.     See \"Understand the relationship with SemVer\".</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Add configuration files (b527ccf by Oscar Esteban). Issue #54, PR #55, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add bump option (CLI, library) allowing to specify an exact version to bump to, as well as <code>auto</code>, <code>major</code>, <code>minor</code> or <code>patch</code> (2c0dbb8 by Th\u00e9o Goudout). Issue #38, PR #41, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add provider CLI option (908531b by Th\u00e9o Goudout). Issue #37, PR #40, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#220-2023-08-17","title":"2.2.0 - 2023-08-17","text":"<p>Compare with 2.1.0</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Add option to omit empty versions from output (b91f777 by Sven Axelsson). PR #52</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Remove broken Atom commit convention (2f33180 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#210-2023-08-04","title":"2.1.0 - 2023-08-04","text":"<p>Compare with 2.0.0</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Add Bitbucket provider (5d793e5 by Sven Axelsson).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Stop using deprecated <code>datetime.utcfromtimestamp</code> (Python 3.12) (1f3ed5d by Sven Axelsson).</li> </ul>"},{"location":"changelog/#200-2023-07-03","title":"2.0.0 - 2023-07-03","text":"<p>Compare with 1.0.1</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Drop support for Python 3.7</li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add option to output release notes (483745a by Timoth\u00e9e Mazzucotelli). Issue #49</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Remove GitHub tokens from remote URL (187e26e by Timoth\u00e9e Mazzucotelli). Issue #50</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Show default for every CLI option (f015830 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove Python 3.7 related code (3295812 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#101-2023-05-10","title":"1.0.1 - 2023-05-10","text":"<p>Compare with 1.0.0</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Check if the latest version tag is already part of the changelog (1fad8a8 by Kevin Squire).</li> <li>Include <code>v</code> prefix in default version regular expression (a50d6a2 by Kevin Squire).</li> </ul>"},{"location":"changelog/#100-2023-02-04","title":"1.0.0 - 2023-02-04","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<p>This version brings a lot of new features, so I took this opportunity to break things, allowing to clean things up, and to bump to version 1.0.0.</p> <ul> <li>New version is not automatically guessed anymore (by bumping latest version).     Enable it again with the <code>--bump-latest</code> CLI option.</li> <li>Provider-specific references are not parsed by default anymore.     Parse them again with the <code>--parse-refs</code> CLI option.</li> <li>The commit convention cannot be passed with the <code>-s</code> CLI option anymore.     This option is now used for declaring sections. Use <code>-c</code> instead.     See usage.</li> <li>Rename Python objects by replacing occurrences of \"style\" by \"convention\" everywhere.</li> </ul>"},{"location":"changelog/#features_6","title":"Features","text":"<p>Lots of new features! Usage is documented here: https://pawamoy.github.io/git-changelog/usage/.</p> <ul> <li>Support updating changelog in-place (18029cd by Timoth\u00e9e Mazzucotelli). Issue #15</li> <li>Better handle single, initial versions (4c6ecf5 by Timoth\u00e9e Mazzucotelli).</li> <li>Use current directory by default (d50d0b1 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow choosing whether to guess new version by bumping latest (85c04fd by Timoth\u00e9e Mazzucotelli).</li> <li>Support Git trailers, render them in Keep A Changelog template (cdf17c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Disable parsing of provider-specific references by default, allow enabling it (cf41a97 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Clean up body to fix parsing trailers (1183c25 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix building commit body (f76bf32 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix spacing in keepachangelog templates (cf5117a by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash when trying to parse the latest tag as SemVer (e90aa2b by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: don't capitalize commit summary (87348ed by Timoth\u00e9e Mazzucotelli).</li> <li>Keep a Changelog template: respect sections order (don't sort) (f645e62 by Timoth\u00e9e Mazzucotelli).</li> <li>Use <code>importlib.metadata</code> instead of <code>pkg_resources</code> to get current version (79109d0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_4","title":"Code Refactoring","text":"<ul> <li>Allow passing sections with <code>-s</code> CLI option (removed from commit convention option) (a1ae778 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename 'style' to 'convention' everywhere (c454481 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>inplace</code> variable to <code>in_place</code> (7a271ef by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI: all flags default to false (9616bdd by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI for better library usage (43ec5d1 by Timoth\u00e9e Mazzucotelli).</li> <li>Make changelog methods private (0b4bbc0 by Timoth\u00e9e Mazzucotelli).</li> <li>Expose <code>Changelog</code> and <code>Commit</code> from <code>git_changelog</code> (d3dca05 by Timoth\u00e9e Mazzucotelli).</li> <li>Detect more commit types (Karma/Angular), rework section titles (f751736 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing datetimes, UTC timestamps as strings, or nothing when creating commit (34460ab by Timoth\u00e9e Mazzucotelli).</li> <li>Build body before instantiating commit (37de53f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#060-2022-10-26","title":"0.6.0 - 2022-10-26","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Add GIT_CHANGELOG_REMOTE variable (9b9b3fc by Luk\u00e1\u0161 Zapletal). PR #35</li> </ul>"},{"location":"changelog/#050-2021-11-14","title":"0.5.0 - 2021-11-14","text":"<p>Compare with 0.4.2</p>"},{"location":"changelog/#dependencies_2","title":"Dependencies","text":"<ul> <li>Accept Jinja2 3.x (9ef3259 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Allow to choose conventional style from CLI (aafa779 by Ivan Gonzalez). PR #32</li> <li>Add ConventionalCommit commit type (3becce8 by Kevin Squire). PR #30</li> </ul>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Properly bump SemVer version (ecc7dd4 by Kevin Squire). References: #31</li> <li>Fix typo in keepachangelog template (fa9b434 by Alexander Schleifer). PR #28</li> </ul>"},{"location":"changelog/#code-refactoring_5","title":"Code Refactoring","text":"<ul> <li>Use SemVer to bump version more reliably (b68a565 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#042-2021-01-06","title":"0.4.2 - 2021-01-06","text":"<p>Compare with 0.4.1</p>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Handle prerelease tags better (4bcc451 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#041-2020-12-21","title":"0.4.1 - 2020-12-21","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Fix wrong version being printed (0ec050f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#040-2020-05-21","title":"0.4.0 - 2020-05-21","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Use actual url for references (46a8790 by Timoth\u00e9e Mazzucotelli).</li> <li>Use style subject if possible (7f2c3ad by Timoth\u00e9e Mazzucotelli).</li> <li>Correctly handle nested subgroups for gitlab repos (8ca990b by Timoth\u00e9e Mazzucotelli).</li> <li>Fix bumping versions starting with \"v\" (44e7644 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_6","title":"Code Refactoring","text":"<ul> <li>Move styles into new commit module to avoid cyclic dependencies (d90bd15 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Improve changelog rendering (e9dd3f4 by Timoth\u00e9e Mazzucotelli).<ul> <li>Use today's date for current version</li> <li>Move \"compare\" link below the heading (better table of contents in documentation)</li> <li>Improve \"compare\" links to handle first and current version</li> <li>Use selected commit types to render sections</li> </ul> </li> <li>Add default commit types to render variable (173392a by Timoth\u00e9e Mazzucotelli).</li> <li>Always use today's date for unreleased version (1c34fa8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#030-2020-03-31","title":"0.3.0 - 2020-03-31","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Fix <code>is_minor</code> method for version (6d08978 by Lo\u00efc Viennois).</li> <li>Fix <code>parse_refs</code> method for <code>ProviderRefParser</code> (dc51589 by Lo\u00efc Viennois).</li> <li>Correctly detect major version, for both angular style and basic style (7385e19 by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#code-refactoring_7","title":"Code Refactoring","text":"<ul> <li>Add type hints to all classes and methods (95276ef by Lo\u00efc Viennois).</li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Update template <code>keepachangelog</code> (ce76ed6) by RainChen:<ul> <li>Capitalize commit subject</li> <li>Show author name for each commit</li> <li>Sort commits by date</li> <li>Unique commit subjects</li> </ul> </li> </ul>"},{"location":"changelog/#020-2019-11-24","title":"0.2.0 - 2019-11-24","text":"<p>Compare with 0.1.1</p> <p>Drop support for Python &lt; 3.6.</p> <p>Use poetry to manage the project!</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix detection of feature (is_minor) for angular style (4fbf0ee).</li> </ul>"},{"location":"changelog/#011-2018-06-27","title":"0.1.1 - 2018-06-27","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix build with MANIFEST.in, add license file (013fb69).</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Improve readability (5e590f6).</li> </ul>"},{"location":"changelog/#010-2018-06-27","title":"0.1.0 - 2018-06-27","text":"<p>Compare with first commit</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add github/github regexes (584fd73).</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix patch bump (8470e69).</li> <li>Fix refs parsing (8c77cb7).</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Continue packaging (#6) (a29af2c).</li> <li>Finish packaging (#6) (e92b492).</li> <li>Implement reference parsing (a9b4a89).</li> <li>Improve angular template, improve style/refs system (5b87d48).</li> <li>Initial commit (83845fe).</li> <li>Package code (#6) (1219eaf).</li> <li>Update changelog for version 0.1.0 (14edcaf).</li> <li>Update changelog for version 0.1.0 (610633d).</li> <li>Update changelog for version 0.1.0 (2eaaa2e).</li> <li>Work in progress (27a60e8).</li> </ul>"},{"location":"cli/","title":"CLI reference","text":""},{"location":"cli/#git-changelog","title":"git-changelog","text":"<p>Automatic Changelog generator using Jinja2 templates.</p> <p>This tool parses your commit messages to extract useful data that is then rendered using Jinja2 templates, for example to a changelog file formatted in Markdown.</p> <p>Each Git tag will be treated as a version of your project. Each version contains a set of commits, and will be an entry in your changelog. Commits in each version will be grouped by sections, depending on the commit convention you follow.</p>"},{"location":"cli/#conventions","title":"Conventions","text":""},{"location":"cli/#basic","title":"Basic","text":"<p>Default sections:</p> <ul> <li>add: Added</li> <li>fix: Fixed</li> <li>change: Changed</li> <li>remove: Removed</li> </ul> <p>Additional sections:</p> <ul> <li>merge: Merged</li> <li>doc: Documented</li> </ul>"},{"location":"cli/#angular","title":"Angular","text":"<p>Default sections:</p> <ul> <li>feat: Features</li> <li>fix: Bug Fixes</li> <li>revert: Reverts</li> <li>ref, refactor: Code Refactoring</li> <li>perf: Performance Improvements</li> </ul> <p>Additional sections:</p> <ul> <li>build: Build</li> <li>chore: Chore</li> <li>ci: Continuous Integration</li> <li>deps: Dependencies</li> <li>doc, docs: Docs</li> <li>style: Style</li> <li>test, tests: Tests</li> </ul>"},{"location":"cli/#conventionalcommit","title":"ConventionalCommit","text":"<p>Default sections:</p> <ul> <li>feat: Features</li> <li>fix: Bug Fixes</li> <li>revert: Reverts</li> <li>ref, refactor: Code Refactoring</li> <li>perf: Performance Improvements</li> </ul> <p>Additional sections:</p> <ul> <li>build: Build</li> <li>chore: Chore</li> <li>ci: Continuous Integration</li> <li>deps: Dependencies</li> <li>doc, docs: Docs</li> <li>style: Style</li> <li>test, tests: Tests</li> </ul>"},{"location":"cli/#positional-arguments","title":"Positional Arguments","text":""},{"location":"cli/#repository","title":"<code>repository</code>","text":"<ul> <li><code>REPOSITORY</code>: The repository path, relative or absolute. Default: current working directory.</li> </ul>"},{"location":"cli/#options","title":"Options","text":""},{"location":"cli/#bump","title":"<code>bump</code>","text":"<p>(docs)</p> <ul> <li><code>-B</code>, <code>--bump</code> <code>VERSION</code>: Specify the bump from latest version for the set of unreleased commits. Can be one of <code>auto</code>, <code>major</code>, <code>minor</code>, <code>patch</code> or a valid SemVer version (eg. 1.2.3). For both SemVer and PEP 440 versioning schemes (see -n), <code>auto</code> will bump the major number if a commit contains breaking changes (or the minor number for 0.x versions, see -Z), else the minor number if there are new features, else the patch number. Default: unset (false).</li> </ul>"},{"location":"cli/#bump_latest","title":"<code>bump_latest</code>","text":"<p>(docs)</p> <ul> <li><code>-b</code>, <code>--bump-latest</code>: Deprecated, use --bump=auto instead. Guess the new latest version by bumping the previous one based on the set of unreleased commits. For example, if a commit contains breaking changes, bump the major number (or the minor number for 0.x versions). Else if there are new features, bump the minor number. Else just bump the patch number. Default: unset (false).</li> </ul>"},{"location":"cli/#config_file","title":"<code>config_file</code>","text":"<p>(docs)</p> <ul> <li><code>--config-file</code> <code>PATH</code>: Configuration file(s).</li> </ul>"},{"location":"cli/#convention","title":"<code>convention</code>","text":"<p>(docs)</p> <ul> <li><code>-c</code>, <code>--convention</code>, <code>--commit-style</code>, <code>--style</code> <code>CONVENTION</code>: The commit convention to match against. Default: <code>basic</code>.</li> </ul>"},{"location":"cli/#debug_info","title":"<code>debug_info</code>","text":"<ul> <li><code>--debug-info</code>: Print debug information.</li> </ul>"},{"location":"cli/#filter_commits","title":"<code>filter_commits</code>","text":"<p>(docs)</p> <ul> <li><code>-F</code>, <code>--filter-commits</code> <code>RANGE</code>: The Git revision-range filter to use (e.g. <code>v1.2.0..</code>). Default: no filter.</li> </ul>"},{"location":"cli/#help","title":"<code>help</code>","text":"<ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit.</li> </ul>"},{"location":"cli/#in_place","title":"<code>in_place</code>","text":"<p>(docs)</p> <ul> <li><code>-i</code>, <code>--in-place</code>: Insert new entries (versions missing from changelog) in-place. An output file must be specified. With custom templates, you can pass two additional arguments: <code>--version-regex</code> and <code>--marker-line</code>. When writing in-place, an <code>in_place</code> variable will be injected in the Jinja context, allowing to adapt the generated contents (for example to skip changelog headers or footers). Default: unset (false).</li> </ul>"},{"location":"cli/#input","title":"<code>input</code>","text":"<p>(docs)</p> <ul> <li><code>-I</code>, <code>--input</code> <code>FILE</code>: Read from given file when creating release notes. Default: <code>CHANGELOG.md</code>.</li> </ul>"},{"location":"cli/#jinja_context","title":"<code>jinja_context</code>","text":"<ul> <li><code>-j</code>, <code>--jinja-context</code> <code>KEY=VALUE</code>: Pass additional key/value pairs to the template. Option can be used multiple times. The key/value pairs are accessible as 'jinja_context' in the template.</li> </ul>"},{"location":"cli/#marker_line","title":"<code>marker_line</code>","text":"<p>(docs)</p> <ul> <li><code>-m</code>, <code>--marker-line</code> <code>MARKER</code>: A marker line at which to insert new entries (versions missing from changelog). If two marker lines are present in the changelog, the contents between those two lines will be overwritten (useful to update an 'Unreleased' entry for example). Default: <code>&lt;!-- insertion marker --&gt;</code>.</li> </ul>"},{"location":"cli/#omit_empty_versions","title":"<code>omit_empty_versions</code>","text":"<p>(docs)</p> <ul> <li><code>-E</code>, <code>--omit-empty-versions</code>: Omit empty versions from the output. Default: unset (false).</li> </ul>"},{"location":"cli/#output","title":"<code>output</code>","text":"<p>(docs)</p> <ul> <li><code>-o</code>, <code>--output</code> <code>FILE</code>: Output to given file. Default: standard output.</li> </ul>"},{"location":"cli/#parse_refs","title":"<code>parse_refs</code>","text":"<p>(docs)</p> <ul> <li><code>-r</code>, <code>--parse-refs</code>: Parse provider-specific references in commit messages (GitHub/GitLab/Bitbucket issues, PRs, etc.). Default: unset (false).</li> </ul>"},{"location":"cli/#parse_trailers","title":"<code>parse_trailers</code>","text":"<p>(docs)</p> <ul> <li><code>-T</code>, <code>--trailers</code>, <code>--git-trailers</code>: Parse Git trailers in the commit message. See https://git-scm.com/docs/git-interpret-trailers. Default: unset (false).</li> </ul>"},{"location":"cli/#provider","title":"<code>provider</code>","text":"<p>(docs)</p> <ul> <li><code>-p</code>, <code>--provider</code> <code>PROVIDER</code>: Explicitly specify the repository provider. Default: unset.</li> </ul>"},{"location":"cli/#release_notes","title":"<code>release_notes</code>","text":"<p>(docs)</p> <ul> <li><code>-R</code>, <code>--release-notes</code>: Output release notes to stdout based on the last entry in the changelog. Default: unset (false).</li> </ul>"},{"location":"cli/#sections","title":"<code>sections</code>","text":"<p>(docs)</p> <ul> <li><code>-s</code>, <code>--sections</code> <code>SECTIONS</code>: A comma-separated list of sections to render. See the available sections for each supported convention in the description. Default: unset (None).</li> </ul>"},{"location":"cli/#template","title":"<code>template</code>","text":"<p>(docs)</p> <ul> <li><code>-t</code>, <code>--template</code> <code>TEMPLATE</code>: The Jinja2 template to use. Prefix it with <code>path:</code> to specify the path to a Jinja templated file. Default: <code>keepachangelog</code>.</li> </ul>"},{"location":"cli/#version","title":"<code>version</code>","text":"<ul> <li><code>-V</code>, <code>--version</code>: Show the current version of the program and exit.</li> </ul>"},{"location":"cli/#version_regex","title":"<code>version_regex</code>","text":"<p>(docs)</p> <ul> <li><code>-g</code>, <code>--version-regex</code> <code>REGEX</code>: A regular expression to match versions in the existing changelog (used to find the latest release) when writing in-place. The regular expression must be a Python regex with a <code>version</code> named group. Default: <code>^## \\[(?P&lt;version&gt;v?[^\\]]+)</code>.</li> </ul>"},{"location":"cli/#versioning","title":"<code>versioning</code>","text":"<p>(docs)</p> <ul> <li><code>-n</code>, <code>--versioning</code> <code>SCHEME</code>: Versioning scheme to use when bumping and comparing versions. The selected scheme will impact the values accepted by the <code>--bump</code> option. Supported: <code>pep440</code>, <code>semver</code>. PEP 440 provides the following bump strategies: <code>auto</code>, <code>epoch</code>, <code>release</code>, <code>major</code>, <code>minor</code>, <code>micro</code>, <code>patch</code>, <code>pre</code>, <code>alpha</code>, <code>beta</code>, <code>candidate</code>, <code>post</code>, <code>dev</code>. Values <code>auto</code>, <code>major</code>, <code>minor</code>, <code>micro</code> can be suffixed with one of <code>+alpha</code>, <code>+beta</code>, <code>+candidate</code>, and/or <code>+dev</code>. Values <code>alpha</code>, <code>beta</code> and <code>candidate</code> can be suffixed with <code>+dev</code>. Examples: <code>auto+alpha</code>, <code>major+beta+dev</code>, <code>micro+dev</code>, <code>candidate+dev</code>, etc.. SemVer provides the following bump strategies: <code>auto</code>, <code>major</code>, <code>minor</code>, <code>patch</code>, <code>release</code>. See the docs for more information. Default: unset (<code>semver</code>).</li> </ul>"},{"location":"cli/#zerover","title":"<code>zerover</code>","text":"<p>(docs)</p> <ul> <li><code>-Z</code>, <code>--no-zerover</code>: By default, breaking changes on a 0.x don't bump the major version, maintaining it at 0. With this option, a breaking change will bump a 0.x version to 1.0. Default: <code>True</code>.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at dev@pawamoy.fr. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd git-changelog\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install uv manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install uv\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv install</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>make run git-changelog [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you run the task directly with <code>make run duty TASK</code>.</p> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-2--credits","title":"Credits","text":"<p>These projects were used to build git-changelog. Thank you!</p> <p>Python | uv | copier-uv</p>"},{"location":"credits/#exec-2--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License Jinja2 A very fast and expressive template engine. <code>&gt;=2.11.1, &gt;=2.10</code> <code>3.1.3</code> BSD-3-Clause MarkupSafe Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0, &gt;=1.1</code> <code>2.1.5</code> BSD-3-Clause appdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=1.4</code> <code>1.4.4</code> MIT packaging Core utilities for Python packages <code>&gt;=24.0</code> <code>24.0</code> Apache Software License + BSD License semver Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.2</code> BSD"},{"location":"credits/#exec-2--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License Babel Internationalization utilities <code>~=2.10</code> <code>2.14.0</code> BSD-3-Clause GitPython GitPython is a Python library used to interact with Git repositories <code>3.1.43</code> BSD-3-Clause Jinja2 A very fast and expressive template engine. <code>&gt;=2.11.1, &gt;=2.10</code> <code>3.1.3</code> BSD-3-Clause Markdown Python implementation of John Gruber's Markdown. <code>&gt;=3.3</code> <code>3.6</code> BSD License MarkupSafe Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0, &gt;=1.1</code> <code>2.1.5</code> BSD-3-Clause PyYAML YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT Pygments Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.17.2</code> BSD-2-Clause SecretStorage Python bindings to FreeDesktop.org Secret Service API <code>&gt;=3.2</code> <code>3.3.3</code> BSD 3-Clause License ansimarkup Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License black The uncompromising code formatter. <code>&gt;=23.9</code> <code>24.3.0</code> MIT blacken-docs Run Black on Python code blocks in documentation files. <code>&gt;=1.16</code> <code>1.16.0</code> MIT build A simple, correct Python build frontend <code>&gt;=1.0</code> <code>1.2.1</code> MIT License certifi Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2024.2.2</code> MPL-2.0 cffi Foreign Function Interface for Python calling C code. <code>&gt;=1.12</code> <code>1.16.0</code> MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&gt;=2, &lt;4</code> <code>3.3.2</code> MIT click Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause colorama Cross-platform colored terminal text. <code>0.4.6</code> BSD License coverage Code coverage measurement for Python <code>&gt;=5.2.1</code> <code>7.4.4</code> Apache-2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. <code>&gt;=2.0</code> <code>42.0.5</code> Apache-2.0 OR BSD-3-Clause csscompressor A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD docutils Docutils -- Python Documentation Utilities <code>&gt;=0.13.1</code> <code>0.20.1</code> public domain, Python, 2-Clause BSD, GPL 3 (see COPYING.txt) dparse A parser for Python dependency files <code>&gt;=0.6.2</code> <code>0.6.3</code> MIT license duty A simple task runner. <code>&gt;=0.10</code> <code>1.2.0</code> ISC execnet execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT failprint Run a command, print its output only if it fails. <code>&gt;=0.11, !=1.0.0</code> <code>1.0.2</code> ISC ghp-import Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License gitdb Git Object Database <code>&gt;=4.0.1, &lt;5</code> <code>4.0.11</code> BSD License griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.40</code> <code>0.42.1.1.2.0</code> ISC htmlmin2 An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD idna Internationalized Domain Names in Applications (IDNA) <code>&gt;=2.5, &lt;4</code> <code>3.6</code> BSD License importlib_metadata Read metadata from Python packages <code>&gt;=4.6</code> <code>7.1.0</code> Apache Software License iniconfig brain-dead simple config-ini parsing <code>2.0.0</code> MIT jaraco.classes Utility functions for Python class constructs <code>3.4.0</code> MIT License jaraco.context Context managers by jaraco <code>4.3.0</code> MIT License jaraco.functools Functools like those found in stdlib <code>4.0.0</code> MIT License jeepney Low-level, pure Python DBus protocol wrapper. <code>&gt;=0.4.2</code> <code>0.8.0</code> MIT License jsmin JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License keyring Store and access your passwords safely. <code>&gt;=15.1</code> <code>25.0.0</code> MIT License markdown-callouts Markdown extension: a classier syntax for admonitions <code>&gt;=0.3</code> <code>0.4.0</code> MIT markdown-exec Utilities to execute code blocks in Markdown files. <code>&gt;=1.7</code> <code>1.7.0.1.0.1</code> ISC markdown-it-py Python port of markdown-it. Markdown parsing, done right! <code>&gt;=2.2.0</code> <code>3.0.0</code> MIT License mdurl Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License mergedeep A deep merge function for \ud83d\udc0d. <code>~=1.3</code> <code>1.3.4</code> MIT License mkdocs Project documentation with Markdown. <code>&gt;=1.5</code> <code>1.5.3</code> BSD-2-Clause mkdocs-autorefs Automatically link across pages in MkDocs. <code>&gt;=0.3.1</code> <code>1.0.1</code> ISC mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=1.0</code> <code>1.0.0</code> ISC mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.5</code> <code>0.5.0</code> MIT mkdocs-git-committers-plugin-2 An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of GitHub or GitLab committers and other useful GIT info such as last modified date <code>&gt;=1.2</code> <code>2.3.0</code> MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.6</code> <code>0.6.1</code> MIT mkdocs-material Documentation that simply works <code>&gt;=9.4</code> <code>9.5.15+insiders.4.53.3</code> MIT mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT mkdocs-minify-plugin An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.7</code> <code>0.8.0</code> MIT mkdocstrings Automatic documentation from sources, for MkDocs. <code>&gt;=0.23</code> <code>0.24.1</code> ISC mkdocstrings-python A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.8.0.1.6.0</code> ISC more-itertools More routines for operating on iterables, beyond itertools <code>10.2.0</code> MIT License mypy Optional static typing for Python <code>&gt;=1.5</code> <code>1.9.0</code> MIT mypy-extensions Type system extensions for programs checked with the mypy type checker. <code>&gt;=1.0.0</code> <code>1.0.0</code> MIT License nh3 Python bindings to the ammonia HTML sanitization library. <code>&gt;=0.2.14</code> <code>0.2.17</code> MIT packaging Core utilities for Python packages <code>&gt;=24.0</code> <code>24.0</code> Apache Software License + BSD License paginate Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.6</code> MIT pathspec Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) pkginfo Query metadata from sdists / bdists / installed packages. <code>&gt;=1.8.1</code> <code>1.10.0</code> MIT platformdirs A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>4.2.0</code> MIT pluggy plugin and hook calling mechanisms for python <code>&gt;=1.4, &lt;2.0</code> <code>1.4.0</code> MIT ptyprocess Run a subprocess in a pseudo terminal <code>~=0.6</code> <code>0.7.0</code> ISC License (ISCL) pycparser C parser in Python <code>2.22</code> BSD-3-Clause pymdown-extensions Extension pack for Python Markdown. <code>&gt;=6.3</code> <code>10.7.1</code> MIT pyproject_hooks Wrappers to call pyproject.toml-based build backend hooks. <code>1.0.0</code> MIT License pytest pytest: simple powerful testing with Python <code>&gt;=7.4</code> <code>8.1.1</code> MIT pytest-cov Pytest plugin for measuring coverage. <code>&gt;=4.1</code> <code>5.0.0</code> MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.15</code> <code>3.15.0</code> MIT pytest-xdist pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=3.3</code> <code>3.5.0</code> MIT python-dateutil Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> BSD License + Apache Software License pyyaml_env_tag A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License readme_renderer readme_renderer is a library for rendering readme descriptions for Warehouse <code>&gt;=35.0</code> <code>43.0</code> Apache License, Version 2.0 regex Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2023.12.25</code> Apache Software License requests Python HTTP for Humans. <code>~=2.26</code> <code>2.31.0</code> Apache 2.0 requests-toolbelt A utility belt for advanced users of python-requests <code>&gt;=0.8.0, !=0.9.0</code> <code>1.0.0</code> Apache 2.0 rfc3986 Validating URI References per RFC 3986 <code>&gt;=1.4.0</code> <code>2.0.0</code> Apache 2.0 rich Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.0.0</code> <code>13.7.1</code> MIT ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order <code>&gt;=0.17.21</code> <code>0.18.6</code> MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml <code>&gt;=0.2.7</code> <code>0.2.8</code> MIT ruff An extremely fast Python linter and code formatter, written in Rust. <code>&gt;=0.0</code> <code>0.3.5</code> MIT safety Checks installed dependencies for known vulnerabilities and licenses. <code>&gt;=2.3</code> <code>2.3.4</code> MIT license setuptools Easily download, build, install, upgrade, and uninstall Python packages <code>&gt;=19.3</code> <code>69.2.0</code> MIT License six Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT smmap A pure Python implementation of a sliding window memory map manager <code>&gt;=3.0.1, &lt;6</code> <code>5.0.1</code> BSD tomli_w A lil' TOML writer <code>&gt;=1.0</code> <code>1.0.0</code> MIT License twine Collection of utilities for publishing packages on PyPI <code>&gt;=5.0</code> <code>5.0.0</code> Apache Software License types-Markdown Typing stubs for Markdown <code>&gt;=3.5</code> <code>3.6.0.20240316</code> Apache-2.0 license types-PyYAML Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.20240311</code> Apache-2.0 license typing_extensions Backported and Experimental Type Hints for Python 3.8+ <code>&gt;=4.1</code> <code>4.10.0</code> Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <code>&gt;=1.21.1, &lt;3</code> <code>2.2.1</code> MIT License watchdog Filesystem events monitoring <code>&gt;=2.0</code> <code>4.0.0</code> Apache-2.0 zipp Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.18.1</code> MIT License <p>More credits from the author</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2018, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>git-changelog parses your commit messages to extract useful data that is then rendered using Jinja2 templates, for example to a changelog file formatted in Markdown.</p> <p>Each Git tag will be treated as a version of your project. Each version contains a set of commits, and will be an entry in your changelog. Commits in each version will be grouped by sections, depending on the commit coonvention you follow.</p>"},{"location":"usage/#quick-usage","title":"Quick usage","text":"<p>Print the changelog on standard output, using the basic convention for commit messages and the Angular template:</p> <pre><code>git-changelog -c basic -t angular\n</code></pre> <p>Update a changelog in-place, overwriting and updating the \"Unreleased\" section, using the Angular commit message convention and the Keep A Changelog template (default):</p> <pre><code>git-changelog -io CHANGELOG.md -c angular\n</code></pre> <p>Same thing, but now you're ready to tag so you tell git-changelog to guess the new version by bumping the latest version based on the semantics of your commits:</p> <pre><code>git-changelog -B auto -io CHANGELOG.md -c angular\n</code></pre> <p>Same thing, but also parse Git trailers and choose the sections to render, and their order (author's favorite!):</p> <pre><code>git-changelog -B auto -Tio CHANGELOG.md -c angular -s build,deps,fix,feat,refactor\n</code></pre> <p>Generate a changelog using a custom template, and parsing provider-specific references (GitHub/GitLab/Bitbucket):</p> <pre><code>git-changelog -rt path:./templates/changelog.md.jinja\n</code></pre> <p>Generate a changelog using a specific provider (GitHub/GitLab/BitBucket):</p> <pre><code>git-changelog --provider github\n</code></pre> <p>Author's favorite, from Python:</p> <pre><code>from git_changelog.cli import build_and_render\n\nbuild_and_render(\n    repository=\".\",\n    output=\"CHANGELOG.md\",\n    convention=\"angular\",\n    provider=\"github\",\n    template=\"keepachangelog\",\n    parse_trailers=True,\n    parse_refs=False,\n    sections=(\"build\", \"deps\", \"feat\", \"fix\", \"refactor\"),\n    versioning=\"pep440\",\n    bump=\"auto\",\n    in_place=True,\n)\n</code></pre> <p>The following sections explain in more details all the features of git-changelog.</p>"},{"location":"usage/#configuration-files","title":"Configuration files","text":"<p>(--config-file)</p> <p>Project-wise, permanent configuration of git-changelog is possible. By default, git-changelog will search for the existence a suitable configuration in the <code>pyproject.toml</code> file or otherwise, the following configuration files  in this particular order:</p> <ul> <li><code>.git-changelog.toml</code></li> <li><code>config/git-changelog.toml</code></li> <li><code>.config/git-changelog.toml</code></li> <li><code>&lt;current-user-config-path&gt;/git-changelog.toml</code></li> </ul> <p>In the last case (<code>&lt;current-user-config-path&gt;/git-changelog.toml</code>), the <code>&lt;current-user-config-path&gt;</code> is platform-dependent and will be automatically inferred from your settings. In Unix systems, this will typically point at <code>$HOME/.config/git-changelog.toml</code>. The use of a configuration file can be disabled or overridden with the <code>--config-file</code> option. To disable the configuration file, pass <code>no</code>, <code>none</code>, <code>false</code>, <code>off</code>, <code>0</code> or empty string (<code>''</code>):</p> <pre><code>git-changelog --config-file no\n</code></pre> <p>To override the configuration file, pass the path to the new file:</p> <pre><code>git-changelog --config-file $HOME/.custom-git-changelog-config\n</code></pre> <p>The configuration file must be written in TOML language, and may take values for most of the command line options:</p> <pre><code>bump = \"auto\"\nconvention = \"basic\"\nin-place = false\nfilter-commits = \"0.5.0..\"\nmarker-line = \"&lt;!-- insertion marker --&gt;\"\noutput = \"output.log\"\nparse-refs = false\nparse-trailers = false\nprovider = \"gitlab\"\nrepository = \".\"\nsections = [\"fix\", \"maint\"]\ntemplate = \"angular\"\nversion-regex = \"^## \\\\\\\\[(?P&lt;version&gt;v?[^\\\\\\\\]]+)\"\nversioning = \"semver\"\nzerover = true\n</code></pre> <p>In the case of configuring git-changelog within <code>pyproject.toml</code>, these settings must be found in the appropriate section:</p> <pre><code>[tool.git-changelog]\nbump = \"minor\"\nconvention = \"conventional\"\nin-place = false\nfilter-commits = \"0.5.0..\"\nmarker-line = \"&lt;!-- insertion marker --&gt;\"\noutput = \"output.log\"\nparse-refs = false\nparse-trailers = false\nprovider = \"gitlab\"\nrepository = \".\"\nsections = \"fix,maint\"\ntemplate = \"keepachangelog\"\nversion-regex = \"^## \\\\\\\\[(?P&lt;version&gt;v?[^\\\\\\\\]]+)\"\nversioning = \"semver\"\nzerover = true\n</code></pre>"},{"location":"usage/#output-a-changelog","title":"Output a changelog","text":"<p>(--output)</p> <p>To output a changelog for the current repository (current directory), simply run:</p> <pre><code>git-changelog\n</code></pre> <p>To output a changelog for another repository (directory), pass the path to that repository:</p> <pre><code>git-changelog /path/to/my/repo\n</code></pre> <p>By default, git-changelog will parse commit messages as if they use the \"basic\" convention, and render a Keep A Changelog-formatted changelog writing to the standard output.</p> <p>To write to a file instead, use the <code>-o</code> or <code>--output</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md\n</code></pre>"},{"location":"usage/#choose-the-commit-message-convention","title":"Choose the commit message convention","text":"<p>(--convention)</p> <p>Different conventions, or styles, are supported by git-changelog. To select a different convention than the default one (basic, see below), use the <code>-c</code> or <code>--convention</code> CLI option:</p> <pre><code>git-changelog --convention angular\n</code></pre>"},{"location":"usage/#basic-convention","title":"Basic convention","text":"<p>The basic convention, as the name implies, is very simple. If a commit message summary (the first line of the message) with a particular word/prefix (case-insensitive), it is added to the corresponding section:</p> Type Section <code>add</code> Added <code>fix</code> Fixed <code>change</code> Changed <code>remove</code> Removed <code>merge</code> Merged <code>doc</code> Documented"},{"location":"usage/#angularkarma-convention","title":"Angular/Karma convention","text":"<p>The Angular/Karma convention initiated the Conventional Commit specification. It expects the following format for commit messages:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>The types and corresponding sections git-changelog recognizes are:</p> Type Section <code>build</code> Build <code>chore</code> Chore <code>ci</code> Continuous Integration <code>deps</code> Dependencies <code>doc(s)</code> Docs <code>feat</code> Features <code>fix</code> Bug Fixes <code>perf</code> Performance Improvements <code>ref(actor)</code> Code Refactoring <code>revert</code> Reverts <code>style</code> Style <code>test(s)</code> Tests <p>Breaking changes are detected by searching for <code>^break(s|ing changes?)?[ :]</code> in the commit message body.</p>"},{"location":"usage/#conventional-commit-convention","title":"Conventional Commit convention","text":"<p>The Conventional Commit specification originates from the Angular commit message convention. It's basically the same thing, but only the <code>feat</code> and <code>fix</code> types are specified, and the rest is up to you. In git-changelog though, it is equivalent to the Angular convention, with an additional thing: it detects breaking changes when <code>!</code> appears right before the colon in the message summary (for example: <code>refactor!: Stuff</code>).</p>"},{"location":"usage/#choose-the-sections-to-render","title":"Choose the sections to render","text":"<p>(--sections)</p> <p>Each commit message convention has a default set of sections that will be rendered in the output. The other sections will be ignored. To override this, you can provide a list of sections to render to git-changelog with the <code>-s</code> or <code>--sections</code> CLI option:</p> <pre><code># with the basic convention\ngit-changelog --sections add,fix,remove,doc\n\n# with the angular/karma/conventionalcommit convention\ngit-changelog --sections build,deps,feat,fix,refactor\n</code></pre> <p>See the previous paragraphs to get the list of available sections for each commit message convetions.</p>"},{"location":"usage/#choose-a-changelog-template","title":"Choose a changelog template","text":"<p>(--template)</p> <p>git-changelog provides two built-in templates: <code>keepachangelog</code> and <code>angular</code>. Both are very similar, they just differ with the formatting a bit. We stronly recommend the <code>keepachangelog</code> format.</p> <p>Use the <code>-t</code>, <code>--template</code> option to specify the template to use:</p> <pre><code>git-changelog --template keepachangelog\n</code></pre> <p>You can also write and use your own changelog templates. Templates are single files written using the Jinja templating engine. You can get inspiration from the source of our built-in templates.</p> <p>Prefix the value passed to the <code>--template</code> option with <code>path:</code> to use a custom template:</p> <pre><code>git-changelog --template path:mytemplate.md\n</code></pre>"},{"location":"usage/#writing-a-changelog-template","title":"Writing a changelog template","text":"<p>To write your own changelog template, we recommend using our keepachangelog built-in template as a starting point.</p> <p>From there, simply modify the different Jinja macros:</p> <ul> <li><code>render_commit()</code>, which accepts a Commit object</li> <li><code>render_section()</code>, which accepts a Section object</li> <li><code>render_version()</code>, which accepts a Version object</li> </ul> <p>Then, also update the template at the end, to change the changelog's header or add a changelog footer for example.</p> <p>The variables available in the template are <code>changelog</code>, which is a Changelog instance, and <code>in_place</code>, which is a boolean, and tells whether the changelog is being updated in-place.</p> <p>How to get spacing right?</p> <p> Although spacing (line jumps) is not super important in Markdown contents (it won't change HTML output), it is best if you get spacing right, as it makes prettier changelog files, and will reduce the noise in diffs when you commit an update to your changelog.</p> <p>To manage spacing (in Jinja terms, control whitespace) Jinja allows to \"eat\" spaces on the left or right of an expression, by adding a dash after/before the percent sign: <code>{%-</code> and <code>-%}</code>. However, spacing is not always easy to get right with Jinja, so here are two tips that we find helpful:</p> <ul> <li> <p>To collapse content up, eat spaces on the left, and add new lines     at the top of the Jinja block:</p> <pre><code>Some text.\n{%- if some_condition %}\n\nSome content.\n{%- endif %}\n</code></pre> <p>If the condition is true, there will be exactly one blank line between \"Some text\" and \"Some content\". If not, there won't be extreanous trailing blank lines </p> </li> <li> <p>To collapse content down, eat spaces on the right, and add new lines     at the bottom of the Jinja block:</p> <pre><code>{% if some_condition -%}\nSome content.\n\n{% endif -%}\nSome text.\n</code></pre> <p>If the condition is true, there will be exactly one blank line between \"Some content\" and \"Some text\". If not, there won't be extreanous leading blank lines </p> </li> </ul>"},{"location":"usage/#extra-jinja-context","title":"Extra Jinja context","text":"<p>(--jinja-context)</p> <p>Your custom changelog templates can support user-provided extra Jinja context. This extra context is available in the <code>jinja_context</code> variable, which is a dictionary, and is passed by users with the <code>-j</code>, <code>--jinja-context</code> CLI option or with the <code>jinja_context</code> configuration option.</p> <p>For example, you could let users specify their own changelog footer by adding this at the end of your template:</p> <pre><code>{% if jinja_context.footer %}\n{{ jinja_context.footer }}\n{% endif %}\n</code></pre> <p>Then users would be able to provide their own footer with the CLI option:</p> <pre><code>git-changelog -t path:changelog.md -j footer=\"Copyright 2024 My Company\"\n</code></pre> <p>...or with the configuration option:</p> <pre><code>template = \"path:changelog.md\"\n\n[jinja_context]\nfooter = \"Copyright 2024 My Company\"\n</code></pre>"},{"location":"usage/#filter-commits","title":"Filter commits","text":"<p>(--filter-commits)</p> <p>Sometimes it may be useful to use a limited set of commits, for example, if your project has migrated to SemVer recently and you want to ignore old non-conventional commits.</p> <p>This is possible through the option <code>-F</code>, <code>--filter-commits</code>, which takes a revision-range to select the commits that will be used in the changelog. This option will pass the revision-range to <code>git log</code>, so it will follow  the rules defined by Git.</p> <p>For example, to use commits from tag <code>0.5.0</code> up to latest:</p> <pre><code>git-changelog --filter-commits \"0.5.0..\"\n</code></pre> <p>Or using the commit hash:</p> <pre><code>git-changelog --filter-commits \"2c0dbb8..\"\n</code></pre>"},{"location":"usage/#understand-the-relationship-with-semver","title":"Understand the relationship with SemVer","text":"<p>(--bump) (--versioning) (--zerover)</p> <p>Although git-changelog supports several versioning schemes, SemVer plays a particular role when managing versions.</p> <p>SemVer, or Semantic Versioning, helps users of tools and libraries understand the impact of version changes. To quote SemVer itself:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards compatible manner</li> <li>PATCH version when you make backwards compatible bug fixes</li> </ol> <p>Thanks to the SemVer specification and the commit message conventions, git-changelog is able to guess the new version your project is supposed to take given a set of untagged commits (commits more recent than the latest tag). An \"Added\" (basic convention) or \"feat\" (Angular/Karma/ConventionalCommit) commit will bump the MINOR part of the latest tag. Other types will bump the PATCH part. Commits containing breaking changes will bump the MAJOR part, unless MAJOR is 0, in which case they'll only bump the MINOR part.</p> <p>To tell git-changelog to try and guess the new version, use the <code>--bump=auto</code> CLI option:</p> <pre><code>git-changelog --bump auto\n</code></pre> <p>You can also specify a version to bump to directly:</p> <pre><code>git-changelog --bump 2.3.1\n</code></pre> <p>Or which part of the version to bump, resetting numbers on its right to 0:</p> <pre><code>git-changelog --bump major  # 1.2.3 -&gt; 2.0.0\ngit-changelog --bump minor  # 1.2.3 -&gt; 1.3.0\ngit-changelog --bump patch  # 1.2.3 -&gt; 1.2.4\n</code></pre> <p>As different schemes have different bumping strategies, the selected scheme will affect the <code>--bump</code> option. See PEP 440 strategies and SemVer strategies.</p>"},{"location":"usage/#zerover","title":"ZeroVer","text":"<p>Note that by default, \"ZeroVer\" mode is activated, which means that a breaking change will only bump the major version if the major version is already at <code>1</code> or more, otherwise it will bump the minor version.</p> <p>While this behavior is described in SemVer's specification, the \"ZeroVer\" name comes from the satyrical ZeroVer (or zer0ver, 0ver) versioning scheme.</p> <p>When you are ready to bump to 1.0.0, just pass this version as value, or use the <code>-Z</code>, <code>--no-zerover</code> flag.</p> <p>Let say we are at version <code>0.1.0</code>, and unreleased commits contain breaking changes:</p> <pre><code>git-changelog --bump auto      # 0.2.0\ngit-changelog --bump auto -Z   # 1.0.0\ngit-changelog --bump major     # 0.2.0\ngit-changelog --bump major -Z  # 1.0.0\n</code></pre> <p>If we are already at version <code>1.0.0</code>, and unreleased commits contain breaking changes again:</p> <pre><code>git-changelog --bump auto      # 2.0.0\ngit-changelog --bump auto -Z   # 2.0.0, same\ngit-changelog --bump major     # 2.0.0\ngit-changelog --bump major -Z  # 2.0.0, same\n</code></pre> <p>If you use git-changelog in CI, to update your changelog automatically, it is recommended to use a configuration file instead of the CLI option. On a fresh project, start by setting <code>zerover = true</code> in one of the supported configuration files. Then, once you are ready to bump to v1, set <code>zerover = false</code> and commit it as a breaking change. Once v1 is released, the setting has no use anymore, and you can remove it from your configuration file.</p>"},{"location":"usage/#choose-a-versioning-scheme","title":"Choose a versioning scheme","text":"<p>(--bump) (--versioning) (--zerover)</p> <p>git-changelog currently supports the following versioning schemes:</p> <ul> <li><code>pep440</code>, see PEP 440</li> <li><code>semver</code>, see SemVer</li> </ul> <p>Versioning schemes are useful to git-changelog when grouping commits from your Git history into versions, and when bumping versions.</p> <p>To choose a specific scheme, use the <code>-n</code>, <code>--versioning</code> CLI option:</p> <pre><code>git-changelog -n pep440\n</code></pre> <p>For backward compatibility reasons, it uses the SemVer scheme by default.</p> <p>As different schemes have different bumping strategies, the selected scheme will affect the <code>--bump</code> option.</p>"},{"location":"usage/#pep-440","title":"PEP 440","text":"<p>The bumping strategies supported by the PEP 440 scheme are described in the table below. Bumping a specific part of the version will remove or reset the parts on its right to 0.</p> Strategy Example Description <code>auto</code> - Guess which of major, minor or micro to bumpthanks to the Git history and commit message conventions. <code>epoch</code> <code>1!1</code> \u2192 <code>2!1</code> Bump epoch, keeping final release only. <code>release</code> <code>1rc2</code> \u2192 <code>1</code> Bump version to a final release. <code>major</code> <code>1.1</code> \u2192 <code>2.0</code> Bump major version. <code>minor</code> <code>1.1.1</code> \u2192 <code>1.2.0</code> Bump minor version. <code>micro</code> (or <code>patch</code>) <code>1.1.1.1</code> \u2192 <code>1.1.2.0</code> Bump micro version. <code>pre</code> <code>1a0</code> \u2192 <code>1a1</code> Bump current pre-release (alpha <code>a</code>, beta <code>b</code> or release candidate <code>rc</code>). <code>alpha</code> <code>1a0</code> \u2192 <code>1a1</code> Bump current alpha pre-release. <code>beta</code> <code>1b0</code> \u2192 <code>1b1</code> Bump current beta pre-release. <code>candidate</code> <code>1rc0</code> \u2192 <code>1rc1</code> Bump current candidate pre-release. <code>post</code> <code>1</code> \u2192 <code>1.post0</code> Bump to a post-release. <code>dev</code> <code>1.dev0</code> \u2192 <code>1.dev1</code> Bump current dev-release. <code>auto+alpha</code> - Guess major/minor/micro bump, and set it to alpha pre-release. <code>auto+beta</code> - Guess major/minor/micro bump, and set it to beta pre-release. <code>auto+candidate</code> - Guess major/minor/micro bump, and set it to candidate pre-release. <code>auto+dev</code> - Guess major/minor/micro bump, and set it to dev-release. <code>auto+alpha+dev</code> - Guess major/minor/micro bump, and set it to alpha pre-release and dev-release. <code>auto+beta+dev</code> - Guess major/minor/micro bump, and set it to beta pre-release and dev-release. <code>auto+candidate+dev</code> - Guess major/minor/micro bump, and set it to candidate pre-release and dev-release. <code>major+alpha</code> <code>1</code> \u2192 <code>2a0</code> Bump major version and set it to alpha pre-release. <code>major+beta</code> <code>1</code> \u2192 <code>2b0</code> Bump major version and set it to beta pre-release. <code>major+candidate</code> <code>1</code> \u2192 <code>2rc0</code> Bump major version and set it to candidate pre-release. <code>major+dev</code> <code>1</code> \u2192 <code>2.dev0</code> Bump major version and set it to dev-release. <code>major+alpha+dev</code> <code>1</code> \u2192 <code>2a0.dev0</code> Bump major version and set it to alpha pre-release and dev-release. <code>major+beta+dev</code> <code>1</code> \u2192 <code>2b0.dev0</code> Bump major version and set it to beta pre-release and dev-release. <code>major+candidate+dev</code> <code>1</code> \u2192 <code>2rc0.dev0</code> Bump major version and set it to candidate pre-release and dev-release. <code>minor+alpha</code> <code>1</code> \u2192 <code>1.1a0</code> Bump minor version and set it to alpha pre-release. <code>minor+beta</code> <code>1</code> \u2192 <code>1.1b0</code> Bump minor version and set it to beta pre-release. <code>minor+candidate</code> <code>1</code> \u2192 <code>1.1rc0</code> Bump minor version and set it to candidate pre-release. <code>minor+dev</code> <code>1</code> \u2192 <code>1.1.dev0</code> Bump minor version and set it to dev-release. <code>minor+alpha+dev</code> <code>1</code> \u2192 <code>1.1a0.dev0</code> Bump minor version and set it to alpha pre-release and dev-release. <code>minor+beta+dev</code> <code>1</code> \u2192 <code>1.1b0.dev0</code> Bump minor version and set it to beta pre-release and dev-release. <code>minor+candidate+dev</code> <code>1</code> \u2192 <code>1.1rc0.dev0</code> Bump minor version and set it to candidate pre-release and dev-release. <code>micro+alpha</code> <code>1</code> \u2192 <code>1.0.1a0</code> Bump micro version and set it to alpha pre-release. <code>micro+beta</code> <code>1</code> \u2192 <code>1.0.1b0</code> Bump micro version and set it to beta pre-release. <code>micro+candidate</code> <code>1</code> \u2192 <code>1.0.1rc0</code> Bump micro version and set it to candidate pre-release. <code>micro+dev</code> <code>1</code> \u2192 <code>1.0.1.dev0</code> Bump micro version and set it to dev-release. <code>micro+alpha+dev</code> <code>1</code> \u2192 <code>1.0.1a0.dev0</code> Bump micro version and set it to alpha pre-release and dev-release. <code>micro+beta+dev</code> <code>1</code> \u2192 <code>1.0.1b0.dev0</code> Bump micro version and set it to beta pre-release and dev-release. <code>micro+candidate+dev</code> <code>1</code> \u2192 <code>1.0.1rc0.dev0</code> Bump micro version and set it to candidate pre-release and dev-release. <code>alpha+dev</code> <code>1a0</code> \u2192 <code>1a1.dev0</code> Bump current alpha pre-release and set it to a dev-release. <code>beta+dev</code> <code>1b0</code> \u2192 <code>1b1.dev0</code> Bump current beta pre-release and set it to a dev-release. <code>candidate+dev</code> <code>1rc0</code> \u2192 <code>1rc1.dev0</code> Bump current candidate pre-release and set it to a dev-release. <p>Try it out:</p> <p> Editor (session: default) Run <pre>from git_changelog.versioning import bump_pep440\n\n# \"auto\" strategies are not directly supported by this function\nprint(bump_pep440(\"1.2.3\", \"minor+alpha\"))</pre> Output Clear <pre><code></code></pre> </p> <p>The <code>v</code> prefix will be preserved when bumping a version: <code>v1</code> -&gt; <code>v2</code>.</p> <p>The bumping strategies for PEP 440 try to make the most sense, allowing you to bump in a semantic way and preventing version downgrade mistakes. Specifically, it is not possible:</p> <ul> <li>to bump from a final release version to a pre-release or a dev-release version</li> <li>to bump from a pre-release version to a lower pre-release version or a dev-version</li> <li>more generally, to bump from any version to any lower version</li> </ul> <p>If you need to \"bump\" to a version that is lower than the latest released one, you must explicitely pass the version to the <code>--bump</code> option:</p> <pre><code># latest release is 1.1\ngit-changelog --bump 1.0\n</code></pre>"},{"location":"usage/#semver","title":"SemVer","text":"<p>The bumping strategies supported by the SemVer scheme are described in the table below. Bumping a specific part of the version will remove or reset the parts on its right to 0.</p> Strategy Example Description <code>auto</code> - Guess which of major, minor or patch to bumpthanks to the Git history and commit message conventions. <code>major</code> <code>1.1.1</code> \u2192 <code>2.0.0</code> Bump major version. <code>minor</code> <code>1.1.1</code> \u2192 <code>1.2.0</code> Bump minor version. <code>patch</code> <code>1.1.1</code> \u2192 <code>1.1.2</code> Bump micro version. <code>release</code> <code>1.1.1-a2</code> \u2192 <code>1.1.1</code> Bump version to a final release (remove pre-release and build metadata). <p>Try it out:</p> <p> Editor (session: default) Run <pre>from git_changelog.versioning import bump_semver\n\n# the \"auto\" strategy is not directly supported by this function\nprint(bump_semver(\"1.2.3\", \"minor\"))</pre> Output Clear <pre><code></code></pre> </p> <p>The <code>v</code> prefix will be preserved when bumping a version: <code>v1.0.0</code> -&gt; <code>v2.0.0</code>.</p> <p>The bumping strategies for SemVer will prevent you from bumping from any version to a lower one. It does not support bump pre-release metadata or build metadata because these are not standardized.</p> <p>If you need to \"bump\" to a version that is lower than the latest released one, or to add pre-release or build metadata, you must explicitely pass the version to the <code>--bump</code> option:</p> <pre><code># downgrade\ngit-changelog --bump 1.1.0\n\n# add pre-release metadata\ngit-changelog --bump 2.0.0-alpha1\n</code></pre>"},{"location":"usage/#parse-additional-information-in-commit-messages","title":"Parse additional information in commit messages","text":"<p>git-changelog is able to parse the body of commit messages to find additional information.</p>"},{"location":"usage/#provider-specific-references","title":"Provider-specific references","text":"<p>(--parse-refs) (--provider)</p> <p>git-changelog will detect when you are using GitHub, GitLab or Bitbucket by checking the <code>origin</code> remote configured in your local clone (or the remote indicated by the value of the <code>GIT_CHANGELOG_REMOTE</code> environment variable).</p> <p>Detecting the provider allows git-changelog to build URLs to specific commits and tags. But it also allows it to parse text references understood by these providers in the commit messages. For example: #18 (issue) or a78bcf2e (commit hash). These references are then available when rendering the changelog template, allowing to add links to issues, pull requests, users, etc.</p> <p>Example of a commit message with GitLab references:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14.\nFollow-up of MR !7.\nPart of milestone %2.\n</code></pre> <p>To enable provider-specific reference parsing, use the <code>-r</code> or <code>--parse-refs</code> CLI option:</p> <pre><code>git-changelog --parse-refs\n</code></pre> <p>Provider-references are a bit limited, difficult to parse and favor vendor lock-in, so for these reasons we do not recommend them. Instead, we recommend using Git trailers.</p>"},{"location":"usage/#git-trailers","title":"Git trailers","text":"<p>(--trailers)</p> <p>Git has an <code>interpret-trailers</code> command that allows to add or parse trailers line to commit messages. Trailers line are located in the footer of commit message: there must be a blank line between the body and the first trailer. Each trailer is a line of the form <code>token: value</code>, for example <code>Co-authored-by: Timoth\u00e9e Mazzucotelli &lt;pawamoy@pm.me&gt;</code>.</p> <p>The tokens are specified not to allow whitespace in them, but git-changelog takes the liberty to lift up this limitation for convenience. It means you can write <code>Issue 18: https://...</code> instead of <code>Issue-18: https://...</code>. The first colon + space (<code>:</code>) delimitate the token and value.</p> <p>Example of a commit message with Git trailers:</p> <pre><code>fix: Fix atrocious bug\n\nFixes issue #14: https://github.com/super/repo/issues/14\nFollow-up of PR #7: https://github.com/super/repo/pull/7\nPart of epic #5: https://agile-software.com/super/project/epics/5\n</code></pre> <p>As you can see, compared to provider-specific references, trailers are written out explicitly, so it's a bit more work, but this ensures your changelog can be rendered correctly anywhere, not just on GitHub, GitLab or Bitbucket, and without pre/post-processing.</p> <p>Trailers are rendered in the Keep A Changelog template. If the value is an URL, a link is created with the token as title. If not, the trailer is written as is.</p> <p>Example of how the previous trailers are rendered:</p> <pre><code>- Fix atrocious bug ([aafa779](https://github.com/super/repo/commit/aafa7793ec02a) by John Doe).\n    [Fixes issue #14](https://github.com/super/repo/issues/14),\n    [Follow-up of PR #7](https://github.com/super/repo/pull/7),\n    [Part of epic #5](https://agile-software.com/super/project/epics/5)\n</code></pre> <ul> <li>Fix atrocious bug (aafa779 by John Doe).     Fixes issue #14,     Follow-up of PR #7,     Part of epic #5</li> </ul> <p>To enable Git trailers parsing, use the <code>-T</code> or <code>--trailers</code> CLI option:</p> <pre><code>git-changelog --trailers\n</code></pre>"},{"location":"usage/#update-changelog-in-place","title":"Update changelog in place","text":"<p>(--in-place) (--marker-line) (--version-regex)</p> <p>Writing the whole generated changelog to a file is nice, but sometimes you need to tweak the entries in your changelog and you don't want to overwrite these slight modifications each time your regenerate your changelog.</p> <p>For this reason, git-changelog is able to update a changelog file in-place. It means that it will only insert new entries at the top of the changelog, without modifying existing ones.</p> <p>To update a changelog in-place, use the <code>-i</code> or <code>--in-place</code> CLI option:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place\n</code></pre> <p>To achieve this, git-changelog searches for versions (entries) already written to the changelog with a regular expression. The verions that are not found in the changelog will be added at the top. To know where to add them exactly, we search for a marker line in the changelog. This marker line is an HTML comment: it is not visible when the changelog is displayed in web pages.</p> <p>To support in-place updates in a custom template, you have two choices:</p> <ol> <li> <p>format versions in your template so they match the default regular expression,     and use the default marker line(s) to tell git-changelog where     to insert new entries. Here are these default values:</p> <pre><code>DEFAULT_VERSION_REGEX = r\"^## \\[(?P&lt;version&gt;v?[^\\]]+)\"\nDEFAULT_MARKER_LINE = \"&lt;!-- insertion marker --&gt;\"\n</code></pre> </li> <li> <p>provide a custom regular expression and marker line,     to match the contents of your custom template,     with the <code>-g</code> or <code>--version-regex</code>, and <code>-m</code> or <code>--marker-line</code> CLI options:</p> <pre><code>git-changelog --output CHANGELOG.md --in-place \\\n    --version-regex '&lt;a href=\"[^\"]+\"&gt;(?P&lt;version&gt;[^&lt;]+)' \\\n    --marker-line '&lt;!-- new entries will be injected here --&gt;'\n</code></pre> </li> </ol> <p>When only one marker line is found in the template, new entries are inserted at this line exactly, overwriting it (but the marker is added again by the new entries themselves).</p> <p>When two marker lines are found, new entries are applied between those two lines, overwriting the previous contents. This is useful when you don't tell git-changelog to bump the latest version: you will have an \"Unreleased\" section that is overwritten and updated each time you update your changelog in-place.</p>"},{"location":"usage/#output-release-notes","title":"Output release notes","text":"<p>(--input) (--release-notes)</p> <p>Some platforms allow to announce releases with additional \"release notes\". git-changelog can help generating release notes too, by simply reading your existing changelog and printing the latest entry. So if you just pushed a tag with an updated changelog, you can use git-changelog in Continuous Integration/Deployment to create a release (specific to your platform, e.g. GitHub) with the latest changelog entry as release notes.</p> <p>For example, on GitHub, with the softprops/action-gh-release action:</p> <pre><code>name: github_release\n\non: push\n\njobs:\n  github_release:\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/')\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n    - name: Setup Python\n      uses: actions/setup-python@v4\n    - name: Install git-changelog\n      run: pip install git-changelog\n    - name: Prepare release notes\n      run: git-changelog --release-notes &gt; release-notes.md\n    - name: Create GitHub release\n      uses: softprops/action-gh-release@v1\n      with:\n        body_path: release-notes.md\n</code></pre> <p>By default git-changelog will try to read release notes from a file named <code>CHANGELOG.md</code>. Use the <code>-i</code>, <code>--input</code> option to specify another file to read from. Other options can be used to help git-changelog retrieving the latest entry from your changelog: <code>--version-regex</code> and <code>--marker-line</code>.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> git_changelog<ul> <li> build</li> <li> cli</li> <li> commit</li> <li> debug</li> <li> providers</li> <li> templates</li> <li> versioning</li> </ul> </li> </ul>"},{"location":"reference/git_changelog/","title":"Index","text":""},{"location":"reference/git_changelog/#git_changelog","title":"git_changelog","text":"<p>git-changelog package.</p> <p>Automatic Changelog generator using Jinja2 templates.</p> <p>Modules:</p> <ul> <li> <code>build</code>         \u2013          <p>The module responsible for building the data.</p> </li> <li> <code>cli</code>         \u2013          <p>Module that contains the command line application.</p> </li> <li> <code>commit</code>         \u2013          <p>Module containing the commit logic.</p> </li> <li> <code>debug</code>         \u2013          <p>Debugging utilities.</p> </li> <li> <code>providers</code>         \u2013          <p>Module containing the parsing utilities for git providers.</p> </li> <li> <code>templates</code>         \u2013          <p>The subpackage containing the builtin templates.</p> </li> <li> <code>versioning</code>         \u2013          <p>Utilities to handle different versioning schemes such as SemVer and PEP 440.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Bitbucket</code>         \u2013          <p>A parser for the Bitbucket references.</p> </li> <li> <code>Changelog</code>         \u2013          <p>The main changelog class.</p> </li> <li> <code>Commit</code>         \u2013          <p>A class to represent a commit.</p> </li> <li> <code>GitHub</code>         \u2013          <p>A parser for the GitHub references.</p> </li> <li> <code>GitLab</code>         \u2013          <p>A parser for the GitLab references.</p> </li> </ul>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket","title":"Bitbucket","text":"<pre><code>Bitbucket(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the Bitbucket references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Bitbucket.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog","title":"Changelog","text":"<pre><code>Changelog(\n    repository: str | Path,\n    *,\n    provider: (\n        ProviderRefParser | type[ProviderRefParser] | None\n    ) = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n    zerover: bool = True,\n    filter_commits: str | None = None,\n    versioning: Literal[\"semver\", \"pep440\"] = \"semver\"\n)\n</code></pre> <p>The main changelog class.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str | Path</code>)         \u2013          <p>The repository (directory) for which to build the changelog.</p> </li> <li> <code>provider</code>             (<code>ProviderRefParser | type[ProviderRefParser] | None</code>, default:                 <code>None</code> )         \u2013          <p>The provider to use (github.com, gitlab.com, etc.).</p> </li> <li> <code>convention</code>             (<code>ConventionType | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit convention to use (angular, etc.).</p> </li> <li> <code>parse_provider_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references in the commit messages.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers in the commit messages.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The sections to render (features, bug fixes, etc.).</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use <code>bump=\"auto\"</code> instead. Whether to try and bump latest version to guess new one.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> <li> <code>zerover</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Keep major version at zero, even for breaking changes.</p> </li> <li> <code>filter_commits</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Git revision-range used to filter commits in git-log (e.g: <code>v1.0.1..</code>).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_log</code>           \u2013            <p>Get the <code>git log</code> output.</p> </li> <li> <code>get_remote_url</code>           \u2013            <p>Get the git remote URL for the repository.</p> </li> <li> <code>parse_commits</code>           \u2013            <p>Parse the output of 'git log' into a list of commits.</p> </li> <li> <code>run_git</code>           \u2013            <p>Run a git command in the chosen repository.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser | type[ProviderRefParser] | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n    zerover: bool = True,\n    filter_commits: str | None = None,\n    versioning: Literal[\"semver\", \"pep440\"] = \"semver\",\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Deprecated, use `bump=\"auto\"` instead. Whether to try and bump latest version to guess new one.\n        bump: Whether to try and bump to a given version.\n        zerover: Keep major version at zero, even for breaking changes.\n        filter_commits: The Git revision-range used to filter commits in git-log (e.g: `v1.0.1..`).\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n    self.zerover: bool = zerover\n    self.filter_commits: str | None = filter_commits\n\n    # set provider\n    if not isinstance(provider, ProviderRefParser):\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if callable(provider):\n            provider = provider(namespace, project, url=provider_url)\n        elif \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        elif \"bitbucket\" in provider_url:\n            provider = Bitbucket(namespace, project, url=provider_url)\n        else:\n            provider = None\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(  # noqa: T201\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    sections = (\n        [self.convention.TYPES[section] for section in sections] if sections else self.convention.DEFAULT_RENDER\n    )\n    self.sections = sections\n\n    # get version parser based on selected versioning scheme\n    self.version_parser, self.version_bumper = {\n        \"semver\": (parse_semver, bump_semver),\n        \"pep440\": (parse_pep440, bump_pep440),\n    }[versioning]\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n    self.tag_commits: list[Commit] = [commit for commit in self.commits[1:] if commit.tag]\n    self.tag_commits.insert(0, self.commits[0])\n\n    # apply dates to commits and group them by version\n    v_list, v_dict = self._group_commits_by_version()\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\n            \"`bump_latest=True` is deprecated in favor of `bump='auto'`\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        if bump is None:\n            bump = \"auto\"\n    if bump:\n        self._bump(bump)\n\n    # fix a single, initial version to the user specified version or 0.1.0 if none is specified\n    self._fix_single_version(bump)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.get_log","title":"get_log","text":"<pre><code>get_log() -&gt; str\n</code></pre> <p>Get the <code>git log</code> output.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The output of the <code>git log</code> command, with a particular format.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n    \"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    if self.filter_commits:\n        try:\n            return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT, self.filter_commits)\n        except CalledProcessError as e:\n            raise ValueError(\n                f\"An error ocurred. Maybe the provided git-log revision-range is not valid: '{self.filter_commits}'\",\n            ) from e\n\n    # No revision-range provided. Call normally\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.get_remote_url","title":"get_remote_url","text":"<pre><code>get_remote_url() -&gt; str\n</code></pre> <p>Get the git remote URL for the repository.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The origin remote URL.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:\n    \"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--default\", \"\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n\n    # Remove credentials from the URL.\n    if git_url.startswith((\"http://\", \"https://\")):\n        # (addressing scheme, network location, path, query, fragment identifier)\n        urlparts = list(urlsplit(git_url))\n        urlparts[1] = urlparts[1].split(\"@\", 1)[-1]\n        git_url = urlunsplit(urlparts)\n\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.parse_commits","title":"parse_commits","text":"<pre><code>parse_commits() -&gt; list[Commit]\n</code></pre> <p>Parse the output of 'git log' into a list of commits.</p> <p>The commits build a Git commit graph by referencing their parent commits. Commits are ordered from newest to oldest.</p> <p>Returns:</p> <ul> <li> <code>list[Commit]</code>         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n    \"\"\"Parse the output of 'git log' into a list of commits.\n\n    The commits build a Git commit graph by referencing their parent commits.\n    Commits are ordered from newest to oldest.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # Don't count last blank line.\n    pos = 0\n\n    commits_map: dict[str, Commit] = {}\n\n    while pos &lt; size:\n        # Build message body.\n        nbl_index = 10\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # Build commit object.\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            parent_hashes=lines[pos + 8],\n            commits_map=commits_map,\n            subject=lines[pos + 9],\n            body=body,\n            parse_trailers=self.parse_trailers,\n            version_parser=self.version_parser,\n        )\n\n        pos += nbl_index + 1\n\n        # Expand commit object with provider parsing.\n        if self.provider:\n            commit.update_with_provider(self.provider, parse_refs=self.parse_provider_refs)\n\n        # Set the commit url based on remote_url (could be wrong).\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # Expand commit object with convention parsing.\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits_map[commit.hash] = commit\n\n    return list(commits_map.values())\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Changelog.run_git","title":"run_git","text":"<pre><code>run_git(*args: str) -&gt; str\n</code></pre> <p>Run a git command in the chosen repository.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>Arguments passed to the git command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The git command output.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n    \"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit","title":"Commit","text":"<pre><code>Commit(\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n    parent_hashes: str | list[str] = \"\",\n    commits_map: dict[str, Commit] | None = None,\n    version_parser: (\n        Callable[[str], tuple[ParsedVersion, str]] | None\n    ) = None\n)\n</code></pre> <p>A class to represent a commit.</p> <p>Parameters:</p> <ul> <li> <code>commit_hash</code>             (<code>str</code>)         \u2013          <p>The commit hash.</p> </li> <li> <code>author_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author name.</p> </li> <li> <code>author_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author email.</p> </li> <li> <code>author_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The authoring date (datetime or UTC timestamp).</p> </li> <li> <code>committer_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer name.</p> </li> <li> <code>committer_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer email.</p> </li> <li> <code>committer_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The committing date (datetime or UTC timestamp).</p> </li> <li> <code>refs</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit refs.</p> </li> <li> <code>subject</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit message subject.</p> </li> <li> <code>body</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit message body.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit URL.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>update_with_convention</code>           \u2013            <p>Apply the convention-parsed data to this commit.</p> </li> <li> <code>update_with_provider</code>           \u2013            <p>Apply the provider-parsed data to this commit.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>parent_commits</code>             (<code>list[Commit]</code>)         \u2013          <p>Parent commits of this commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def __init__(\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n    parent_hashes: str | list[str] = \"\",\n    commits_map: dict[str, Commit] | None = None,\n    version_parser: Callable[[str], tuple[ParsedVersion, str]] | None = None,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(author_date, str):\n        author_date = datetime.fromtimestamp(float(author_date), tz=timezone.utc)\n    if not committer_date:\n        committer_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(committer_date, str):\n        committer_date = datetime.fromtimestamp(float(committer_date), tz=timezone.utc)\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()  # noqa: PLW2901\n        if ref.startswith(\"tag: \"):\n            ref = ref.replace(\"tag: \", \"\")  # noqa: PLW2901\n            if version_parser is None or _is_valid_version(ref, version_parser):\n                tag = ref\n                break\n    self.tag: str = tag\n    self.version: str = tag\n\n    if isinstance(parent_hashes, str):\n        parent_hashes = parent_hashes.split()\n    self.parent_hashes = parent_hashes\n    self._commits_map = commits_map\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit.parent_commits","title":"parent_commits  <code>property</code>","text":"<pre><code>parent_commits: list[Commit]\n</code></pre> <p>Parent commits of this commit.</p>"},{"location":"reference/git_changelog/#git_changelog.Commit.update_with_convention","title":"update_with_convention","text":"<pre><code>update_with_convention(\n    convention: CommitConvention,\n) -&gt; None\n</code></pre> <p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>convention</code>             (<code>CommitConvention</code>)         \u2013          <p>The convention to use.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n    \"\"\"Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.Commit.update_with_provider","title":"update_with_provider","text":"<pre><code>update_with_provider(\n    provider: ProviderRefParser, parse_refs: bool = True\n) -&gt; None\n</code></pre> <p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>provider</code>             (<code>ProviderRefParser</code>)         \u2013          <p>The provider to use.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to parse references for this provider.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_provider(\n    self,\n    provider: ProviderRefParser,\n    parse_refs: bool = True,  # noqa: FBT001,FBT002\n) -&gt; None:\n    \"\"\"Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF:\n            self.text_refs[ref_type] = provider.get_refs(\n                ref_type,\n                \"\\n\".join([self.subject, *self.body]),\n            )\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub","title":"GitHub","text":"<pre><code>GitHub(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitHub.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab","title":"GitLab","text":"<pre><code>GitLab(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/#git_changelog.GitLab.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/build/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> build","text":""},{"location":"reference/git_changelog/build/#git_changelog.build","title":"build","text":"<p>The module responsible for building the data.</p> <p>Classes:</p> <ul> <li> <code>Changelog</code>         \u2013          <p>The main changelog class.</p> </li> <li> <code>Section</code>         \u2013          <p>A list of commits grouped by section_type.</p> </li> <li> <code>Version</code>         \u2013          <p>A class to represent a changelog version.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>bump</code>           \u2013            <p>Bump a version. Deprecated, use <code>bump_semver</code> instead.</p> </li> <li> <code>parse_version</code>           \u2013            <p>Parse a version. Deprecated, use <code>bump_semver</code> instead.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog","title":"Changelog","text":"<pre><code>Changelog(\n    repository: str | Path,\n    *,\n    provider: (\n        ProviderRefParser | type[ProviderRefParser] | None\n    ) = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n    zerover: bool = True,\n    filter_commits: str | None = None,\n    versioning: Literal[\"semver\", \"pep440\"] = \"semver\"\n)\n</code></pre> <p>The main changelog class.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str | Path</code>)         \u2013          <p>The repository (directory) for which to build the changelog.</p> </li> <li> <code>provider</code>             (<code>ProviderRefParser | type[ProviderRefParser] | None</code>, default:                 <code>None</code> )         \u2013          <p>The provider to use (github.com, gitlab.com, etc.).</p> </li> <li> <code>convention</code>             (<code>ConventionType | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit convention to use (angular, etc.).</p> </li> <li> <code>parse_provider_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references in the commit messages.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers in the commit messages.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The sections to render (features, bug fixes, etc.).</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use <code>bump=\"auto\"</code> instead. Whether to try and bump latest version to guess new one.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> <li> <code>zerover</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Keep major version at zero, even for breaking changes.</p> </li> <li> <code>filter_commits</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Git revision-range used to filter commits in git-log (e.g: <code>v1.0.1..</code>).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_log</code>           \u2013            <p>Get the <code>git log</code> output.</p> </li> <li> <code>get_remote_url</code>           \u2013            <p>Get the git remote URL for the repository.</p> </li> <li> <code>parse_commits</code>           \u2013            <p>Parse the output of 'git log' into a list of commits.</p> </li> <li> <code>run_git</code>           \u2013            <p>Run a git command in the chosen repository.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    repository: str | Path,\n    *,\n    provider: ProviderRefParser | type[ProviderRefParser] | None = None,\n    convention: ConventionType | None = None,\n    parse_provider_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    bump_latest: bool = False,\n    bump: str | None = None,\n    zerover: bool = True,\n    filter_commits: str | None = None,\n    versioning: Literal[\"semver\", \"pep440\"] = \"semver\",\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        repository: The repository (directory) for which to build the changelog.\n        provider: The provider to use (github.com, gitlab.com, etc.).\n        convention: The commit convention to use (angular, etc.).\n        parse_provider_refs: Whether to parse provider-specific references in the commit messages.\n        parse_trailers: Whether to parse Git trailers in the commit messages.\n        sections: The sections to render (features, bug fixes, etc.).\n        bump_latest: Deprecated, use `bump=\"auto\"` instead. Whether to try and bump latest version to guess new one.\n        bump: Whether to try and bump to a given version.\n        zerover: Keep major version at zero, even for breaking changes.\n        filter_commits: The Git revision-range used to filter commits in git-log (e.g: `v1.0.1..`).\n    \"\"\"\n    self.repository: str | Path = repository\n    self.parse_provider_refs: bool = parse_provider_refs\n    self.parse_trailers: bool = parse_trailers\n    self.zerover: bool = zerover\n    self.filter_commits: str | None = filter_commits\n\n    # set provider\n    if not isinstance(provider, ProviderRefParser):\n        remote_url = self.get_remote_url()\n        split = remote_url.split(\"/\")\n        provider_url = \"/\".join(split[:3])\n        namespace, project = \"/\".join(split[3:-1]), split[-1]\n        if callable(provider):\n            provider = provider(namespace, project, url=provider_url)\n        elif \"github\" in provider_url:\n            provider = GitHub(namespace, project, url=provider_url)\n        elif \"gitlab\" in provider_url:\n            provider = GitLab(namespace, project, url=provider_url)\n        elif \"bitbucket\" in provider_url:\n            provider = Bitbucket(namespace, project, url=provider_url)\n        else:\n            provider = None\n        self.remote_url: str = remote_url\n    self.provider = provider\n\n    # set convention\n    if isinstance(convention, str):\n        try:\n            convention = self.CONVENTION[convention]()\n        except KeyError:\n            print(  # noqa: T201\n                f\"git-changelog: no such convention available: {convention}, using default convention\",\n                file=sys.stderr,\n            )\n            convention = BasicConvention()\n    elif convention is None:\n        convention = BasicConvention()\n    elif not isinstance(convention, CommitConvention) and issubclass(convention, CommitConvention):\n        convention = convention()\n    self.convention: CommitConvention = convention\n\n    # set sections\n    sections = (\n        [self.convention.TYPES[section] for section in sections] if sections else self.convention.DEFAULT_RENDER\n    )\n    self.sections = sections\n\n    # get version parser based on selected versioning scheme\n    self.version_parser, self.version_bumper = {\n        \"semver\": (parse_semver, bump_semver),\n        \"pep440\": (parse_pep440, bump_pep440),\n    }[versioning]\n\n    # get git log and parse it into list of commits\n    self.raw_log: str = self.get_log()\n    self.commits: list[Commit] = self.parse_commits()\n    self.tag_commits: list[Commit] = [commit for commit in self.commits[1:] if commit.tag]\n    self.tag_commits.insert(0, self.commits[0])\n\n    # apply dates to commits and group them by version\n    v_list, v_dict = self._group_commits_by_version()\n    self.versions_list = v_list\n    self.versions_dict = v_dict\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\n            \"`bump_latest=True` is deprecated in favor of `bump='auto'`\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        if bump is None:\n            bump = \"auto\"\n    if bump:\n        self._bump(bump)\n\n    # fix a single, initial version to the user specified version or 0.1.0 if none is specified\n    self._fix_single_version(bump)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_log","title":"get_log","text":"<pre><code>get_log() -&gt; str\n</code></pre> <p>Get the <code>git log</code> output.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The output of the <code>git log</code> command, with a particular format.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_log(self) -&gt; str:\n    \"\"\"Get the `git log` output.\n\n    Returns:\n        The output of the `git log` command, with a particular format.\n    \"\"\"\n    if self.filter_commits:\n        try:\n            return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT, self.filter_commits)\n        except CalledProcessError as e:\n            raise ValueError(\n                f\"An error ocurred. Maybe the provided git-log revision-range is not valid: '{self.filter_commits}'\",\n            ) from e\n\n    # No revision-range provided. Call normally\n    return self.run_git(\"log\", \"--date=unix\", \"--format=\" + self.FORMAT)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_remote_url","title":"get_remote_url","text":"<pre><code>get_remote_url() -&gt; str\n</code></pre> <p>Get the git remote URL for the repository.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The origin remote URL.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def get_remote_url(self) -&gt; str:\n    \"\"\"Get the git remote URL for the repository.\n\n    Returns:\n        The origin remote URL.\n    \"\"\"\n    remote = \"remote.\" + os.environ.get(\"GIT_CHANGELOG_REMOTE\", \"origin\") + \".url\"\n    git_url = self.run_git(\"config\", \"--default\", \"\", \"--get\", remote).rstrip(\"\\n\")\n    if git_url.startswith(\"git@\"):\n        git_url = git_url.replace(\":\", \"/\", 1).replace(\"git@\", \"https://\", 1)\n    if git_url.endswith(\".git\"):\n        git_url = git_url[:-4]\n\n    # Remove credentials from the URL.\n    if git_url.startswith((\"http://\", \"https://\")):\n        # (addressing scheme, network location, path, query, fragment identifier)\n        urlparts = list(urlsplit(git_url))\n        urlparts[1] = urlparts[1].split(\"@\", 1)[-1]\n        git_url = urlunsplit(urlparts)\n\n    return git_url\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.parse_commits","title":"parse_commits","text":"<pre><code>parse_commits() -&gt; list[Commit]\n</code></pre> <p>Parse the output of 'git log' into a list of commits.</p> <p>The commits build a Git commit graph by referencing their parent commits. Commits are ordered from newest to oldest.</p> <p>Returns:</p> <ul> <li> <code>list[Commit]</code>         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def parse_commits(self) -&gt; list[Commit]:\n    \"\"\"Parse the output of 'git log' into a list of commits.\n\n    The commits build a Git commit graph by referencing their parent commits.\n    Commits are ordered from newest to oldest.\n\n    Returns:\n        The list of commits.\n    \"\"\"\n    lines = self.raw_log.split(\"\\n\")\n    size = len(lines) - 1  # Don't count last blank line.\n    pos = 0\n\n    commits_map: dict[str, Commit] = {}\n\n    while pos &lt; size:\n        # Build message body.\n        nbl_index = 10\n        body = []\n        while lines[pos + nbl_index] != self.MARKER:\n            body.append(lines[pos + nbl_index].strip(\"\\r\"))\n            nbl_index += 1\n\n        # Build commit object.\n        commit = Commit(\n            commit_hash=lines[pos],\n            author_name=lines[pos + 1],\n            author_email=lines[pos + 2],\n            author_date=lines[pos + 3],\n            committer_name=lines[pos + 4],\n            committer_email=lines[pos + 5],\n            committer_date=lines[pos + 6],\n            refs=lines[pos + 7],\n            parent_hashes=lines[pos + 8],\n            commits_map=commits_map,\n            subject=lines[pos + 9],\n            body=body,\n            parse_trailers=self.parse_trailers,\n            version_parser=self.version_parser,\n        )\n\n        pos += nbl_index + 1\n\n        # Expand commit object with provider parsing.\n        if self.provider:\n            commit.update_with_provider(self.provider, parse_refs=self.parse_provider_refs)\n\n        # Set the commit url based on remote_url (could be wrong).\n        elif self.remote_url:\n            commit.url = self.remote_url + \"/commit/\" + commit.hash\n\n        # Expand commit object with convention parsing.\n        if self.convention:\n            commit.update_with_convention(self.convention)\n\n        commits_map[commit.hash] = commit\n\n    return list(commits_map.values())\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.run_git","title":"run_git","text":"<pre><code>run_git(*args: str) -&gt; str\n</code></pre> <p>Run a git command in the chosen repository.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>Arguments passed to the git command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The git command output.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def run_git(self, *args: str) -&gt; str:\n    \"\"\"Run a git command in the chosen repository.\n\n    Arguments:\n        *args: Arguments passed to the git command.\n\n    Returns:\n        The git command output.\n    \"\"\"\n    return check_output([\"git\", *args], cwd=self.repository).decode(\"utf8\")  # noqa: S603,S607\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Section","title":"Section","text":"<pre><code>Section(\n    section_type: str = \"\",\n    commits: list[Commit] | None = None,\n)\n</code></pre> <p>A list of commits grouped by section_type.</p> <p>Parameters:</p> <ul> <li> <code>section_type</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The section section_type.</p> </li> <li> <code>commits</code>             (<code>list[Commit] | None</code>, default:                 <code>None</code> )         \u2013          <p>The list of commits.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(self, section_type: str = \"\", commits: list[Commit] | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        section_type: The section section_type.\n        commits: The list of commits.\n    \"\"\"\n    self.type: str = section_type\n    self.commits: list[Commit] = commits or []\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version","title":"Version","text":"<pre><code>Version(\n    tag: str = \"\",\n    date: date | None = None,\n    sections: list[Section] | None = None,\n    commits: list[Commit] | None = None,\n    url: str = \"\",\n    compare_url: str = \"\",\n)\n</code></pre> <p>A class to represent a changelog version.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version tag.</p> </li> <li> <code>date</code>             (<code>date | None</code>, default:                 <code>None</code> )         \u2013          <p>The version date.</p> </li> <li> <code>sections</code>             (<code>list[Section] | None</code>, default:                 <code>None</code> )         \u2013          <p>The version sections.</p> </li> <li> <code>commits</code>             (<code>list[Commit] | None</code>, default:                 <code>None</code> )         \u2013          <p>The version commits.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version URL.</p> </li> <li> <code>compare_url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The version 'compare' URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_commit</code>           \u2013            <p>Register the given commit and add it to the relevant section based on its message convention.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_major</code>             (<code>bool</code>)         \u2013          <p>Tell if this version is a major one.</p> </li> <li> <code>is_minor</code>             (<code>bool</code>)         \u2013          <p>Tell if this version is a minor one.</p> </li> <li> <code>typed_sections</code>             (<code>list[Section]</code>)         \u2013          <p>Return typed sections only.</p> </li> <li> <code>untyped_section</code>             (<code>Section | None</code>)         \u2013          <p>Return untyped section if any.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"\",\n    date: datetime.date | None = None,\n    sections: list[Section] | None = None,\n    commits: list[Commit] | None = None,\n    url: str = \"\",\n    compare_url: str = \"\",\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        tag: The version tag.\n        date: The version date.\n        sections: The version sections.\n        commits: The version commits.\n        url: The version URL.\n        compare_url: The version 'compare' URL.\n    \"\"\"\n    self.tag = tag\n    self.date = date\n\n    self.sections_list: list[Section] = sections or []\n    self.sections_dict: dict[str, Section] = {section.type: section for section in self.sections_list}\n    self.commits: list[Commit] = commits or []\n    self.url: str = url\n    self.compare_url: str = compare_url\n    self.previous_version: Version | None = None\n    self.next_version: Version | None = None\n    self.planned_tag: str | None = None\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_major","title":"is_major  <code>property</code>","text":"<pre><code>is_major: bool\n</code></pre> <p>Tell if this version is a major one.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether this version is major.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_minor","title":"is_minor  <code>property</code>","text":"<pre><code>is_minor: bool\n</code></pre> <p>Tell if this version is a minor one.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether this version is minor.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.typed_sections","title":"typed_sections  <code>property</code>","text":"<pre><code>typed_sections: list[Section]\n</code></pre> <p>Return typed sections only.</p> <p>Returns:</p> <ul> <li> <code>list[Section]</code>         \u2013          <p>The typed sections.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.untyped_section","title":"untyped_section  <code>property</code>","text":"<pre><code>untyped_section: Section | None\n</code></pre> <p>Return untyped section if any.</p> <p>Returns:</p> <ul> <li> <code>Section | None</code>         \u2013          <p>The untyped section if any.</p> </li> </ul>"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.add_commit","title":"add_commit","text":"<pre><code>add_commit(commit: Commit) -&gt; None\n</code></pre> <p>Register the given commit and add it to the relevant section based on its message convention.</p> <p>Parameters:</p> <ul> <li> <code>commit</code>             (<code>Commit</code>)         \u2013          <p>The git commit.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def add_commit(self, commit: Commit) -&gt; None:\n    \"\"\"Register the given commit and add it to the relevant section based on its message convention.\n\n    Arguments:\n        commit: The git commit.\n    \"\"\"\n    self.commits.append(commit)\n    commit.version = self.tag or \"HEAD\"\n    if commit_type := commit.convention.get(\"type\"):\n        if commit_type not in self.sections_dict:\n            section = Section(section_type=commit_type)\n            self.sections_list.append(section)\n            self.sections_dict[commit_type] = section\n        self.sections_dict[commit_type].commits.append(commit)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.bump","title":"bump","text":"<pre><code>bump(\n    version: str,\n    part: Literal[\"major\", \"minor\", \"patch\"] = \"patch\",\n    *,\n    zerover: bool = True\n) -&gt; str\n</code></pre> <p>Bump a version. Deprecated, use <code>bump_semver</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>The version to bump.</p> </li> <li> <code>part</code>             (<code>Literal['major', 'minor', 'patch']</code>, default:                 <code>'patch'</code> )         \u2013          <p>The part of the version to bump (major, minor, or patch).</p> </li> <li> <code>zerover</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Keep major version at zero, even for breaking changes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The bumped version.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def bump(version: str, part: Literal[\"major\", \"minor\", \"patch\"] = \"patch\", *, zerover: bool = True) -&gt; str:\n    \"\"\"Bump a version. Deprecated, use [`bump_semver`][git_changelog.versioning.bump_semver] instead.\n\n    Arguments:\n        version: The version to bump.\n        part: The part of the version to bump (major, minor, or patch).\n        zerover: Keep major version at zero, even for breaking changes.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    warnings.warn(\n        \"This function is deprecated in favor of `git_changelog.versioning.bump_semver`\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return bump_semver(version, part, zerover=zerover)\n</code></pre>"},{"location":"reference/git_changelog/build/#git_changelog.build.parse_version","title":"parse_version","text":"<pre><code>parse_version(version: str) -&gt; tuple[SemVerVersion, str]\n</code></pre> <p>Parse a version. Deprecated, use <code>bump_semver</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>The version to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>semver_version</code> (            <code>SemVerVersion</code> )        \u2013          <p>The semantic version.</p> </li> <li> <code>prefix</code> (            <code>str</code> )        \u2013          <p>The version prefix.</p> </li> </ul> Source code in <code>src/git_changelog/build.py</code> <pre><code>def parse_version(version: str) -&gt; tuple[SemVerVersion, str]:\n    \"\"\"Parse a version. Deprecated, use [`bump_semver`][git_changelog.versioning.parse_semver] instead.\n\n    Arguments:\n        version: The version to parse.\n\n    Returns:\n        semver_version: The semantic version.\n        prefix: The version prefix.\n    \"\"\"\n    warnings.warn(\n        \"This function is deprecated in favor of `git_changelog.versioning.parse_semver`\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return parse_semver(version)\n</code></pre>"},{"location":"reference/git_changelog/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"reference/git_changelog/cli/#git_changelog.cli","title":"cli","text":"<p>Module that contains the command line application.</p> <p>Classes:</p> <ul> <li> <code>Templates</code>         \u2013          <p>Helper to pick a template on the command line.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>build_and_render</code>           \u2013            <p>Build a changelog and render it.</p> </li> <li> <code>get_parser</code>           \u2013            <p>Return the CLI argument parser.</p> </li> <li> <code>get_release_notes</code>           \u2013            <p>Get release notes from existing changelog.</p> </li> <li> <code>get_version</code>           \u2013            <p>Return the current <code>git-changelog</code> version.</p> </li> <li> <code>main</code>           \u2013            <p>Run the main program.</p> </li> <li> <code>output_release_notes</code>           \u2013            <p>Print release notes from existing changelog.</p> </li> <li> <code>parse_settings</code>           \u2013            <p>Parse arguments and config files to build the final settings set.</p> </li> <li> <code>read_config</code>           \u2013            <p>Find config files and initialize settings with the one of highest priority.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_CONFIG_FILES</code>         \u2013          <p>Default configuration files read by git-changelog.</p> </li> </ul>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.DEFAULT_CONFIG_FILES","title":"DEFAULT_CONFIG_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG_FILES = [\n    \"pyproject.toml\",\n    \".git-changelog.toml\",\n    \"config/git-changelog.toml\",\n    \".config/git-changelog.toml\",\n    str(Path(user_config_dir()) / \"git-changelog.toml\"),\n]\n</code></pre> <p>Default configuration files read by git-changelog.</p>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.Templates","title":"Templates","text":"<p>             Bases: <code>tuple</code></p> <p>Helper to pick a template on the command line.</p>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.build_and_render","title":"build_and_render","text":"<pre><code>build_and_render(\n    repository: str,\n    template: str,\n    convention: str | CommitConvention,\n    parse_refs: bool = False,\n    parse_trailers: bool = False,\n    sections: list[str] | None = None,\n    in_place: bool = False,\n    output: str | TextIO | None = None,\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    bump_latest: bool = False,\n    omit_empty_versions: bool = False,\n    provider: str | None = None,\n    bump: str | None = None,\n    zerover: bool = True,\n    filter_commits: str | None = None,\n    jinja_context: dict[str, Any] | None = None,\n    versioning: Literal[\"pep440\", \"semver\"] = \"semver\",\n) -&gt; tuple[Changelog, str]\n</code></pre> <p>Build a changelog and render it.</p> <p>This function returns the changelog instance and the rendered contents, but also updates the specified output file (side-effect) or writes to stdout.</p> <p>Parameters:</p> <ul> <li> <code>repository</code>             (<code>str</code>)         \u2013          <p>Path to a local repository.</p> </li> <li> <code>template</code>             (<code>str</code>)         \u2013          <p>Name of a builtin template, or path to a custom template (prefixed with <code>path:</code>).</p> </li> <li> <code>convention</code>             (<code>str | CommitConvention</code>)         \u2013          <p>Name of a commit message style/convention.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> <li> <code>sections</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Sections to render (features, bug fixes, etc.).</p> </li> <li> <code>in_place</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to update the changelog in-place.</p> </li> <li> <code>output</code>             (<code>str | TextIO | None</code>, default:                 <code>None</code> )         \u2013          <p>Output/changelog file.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>Regular expression to match versions in an existing changelog file.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>Marker line used to insert contents in an existing changelog.</p> </li> <li> <code>bump_latest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Deprecated, use --bump=auto instead. Whether to try and bump the latest version to guess the new one.</p> </li> <li> <code>omit_empty_versions</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to omit empty versions from the output.</p> </li> <li> <code>provider</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Provider class used by this repository.</p> </li> <li> <code>bump</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and bump to a given version.</p> </li> <li> <code>zerover</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Keep major version at zero, even for breaking changes.</p> </li> <li> <code>filter_commits</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Git revision-range used to filter commits in git-log.</p> </li> <li> <code>jinja_context</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Key/value pairs passed to the Jinja template.</p> </li> <li> <code>versioning</code>             (<code>Literal['pep440', 'semver']</code>, default:                 <code>'semver'</code> )         \u2013          <p>Versioning scheme to use when grouping commits and bumping versions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When some arguments are incompatible or missing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Changelog, str]</code>         \u2013          <p>The built changelog and the rendered contents.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def build_and_render(\n    repository: str,\n    template: str,\n    convention: str | CommitConvention,\n    parse_refs: bool = False,  # noqa: FBT001,FBT002\n    parse_trailers: bool = False,  # noqa: FBT001,FBT002\n    sections: list[str] | None = None,\n    in_place: bool = False,  # noqa: FBT001,FBT002\n    output: str | TextIO | None = None,\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    bump_latest: bool = False,  # noqa: FBT001,FBT002\n    omit_empty_versions: bool = False,  # noqa: FBT001,FBT002\n    provider: str | None = None,\n    bump: str | None = None,\n    zerover: bool = True,  # noqa: FBT001,FBT002\n    filter_commits: str | None = None,\n    jinja_context: dict[str, Any] | None = None,\n    versioning: Literal[\"pep440\", \"semver\"] = \"semver\",\n) -&gt; tuple[Changelog, str]:\n    \"\"\"Build a changelog and render it.\n\n    This function returns the changelog instance and the rendered contents,\n    but also updates the specified output file (side-effect) or writes to stdout.\n\n    Parameters:\n        repository: Path to a local repository.\n        template: Name of a builtin template, or path to a custom template (prefixed with `path:`).\n        convention: Name of a commit message style/convention.\n        parse_refs: Whether to parse provider-specific references (GitHub/GitLab issues, PRs, etc.).\n        parse_trailers: Whether to parse Git trailers.\n        sections: Sections to render (features, bug fixes, etc.).\n        in_place: Whether to update the changelog in-place.\n        output: Output/changelog file.\n        version_regex: Regular expression to match versions in an existing changelog file.\n        marker_line: Marker line used to insert contents in an existing changelog.\n        bump_latest: Deprecated, use --bump=auto instead.\n            Whether to try and bump the latest version to guess the new one.\n        omit_empty_versions: Whether to omit empty versions from the output.\n        provider: Provider class used by this repository.\n        bump: Whether to try and bump to a given version.\n        zerover: Keep major version at zero, even for breaking changes.\n        filter_commits: The Git revision-range used to filter commits in git-log.\n        jinja_context: Key/value pairs passed to the Jinja template.\n        versioning: Versioning scheme to use when grouping commits and bumping versions.\n\n    Raises:\n        ValueError: When some arguments are incompatible or missing.\n\n    Returns:\n        The built changelog and the rendered contents.\n    \"\"\"\n    # get template\n    if template.startswith(\"path:\"):\n        path = template.replace(\"path:\", \"\", 1)\n        try:\n            jinja_template = templates.get_custom_template(path)\n        except TemplateNotFound as error:\n            raise ValueError(f\"No such file: {path}\") from error\n    else:\n        jinja_template = templates.get_template(template)\n\n    if output is None:\n        output = sys.stdout\n\n    # handle misconfiguration early\n    if in_place and output is sys.stdout:\n        raise ValueError(\"Cannot write in-place to stdout\")\n\n    # get provider\n    provider_class = providers[provider] if provider else None\n\n    # TODO: remove at some point\n    if bump_latest:\n        warnings.warn(\"`bump_latest=True` is deprecated in favor of `bump='auto'`\", DeprecationWarning, stacklevel=1)\n        if bump is None:\n            bump = \"auto\"\n\n    # build data\n    changelog = Changelog(\n        repository,\n        provider=provider_class,\n        convention=convention,\n        parse_provider_refs=parse_refs,\n        parse_trailers=parse_trailers,\n        sections=sections,\n        bump=bump,\n        zerover=zerover,\n        filter_commits=filter_commits,\n        versioning=versioning,\n    )\n\n    # remove empty versions from changelog data\n    if omit_empty_versions:\n        section_set = set(changelog.sections)\n        empty_versions = [\n            version for version in changelog.versions_list if section_set.isdisjoint(version.sections_dict.keys())\n        ]\n        for version in empty_versions:\n            changelog.versions_list.remove(version)\n            changelog.versions_dict.pop(version.tag)\n\n    # render new entries in-place\n    if in_place:\n        # read current changelog lines\n        with open(output) as changelog_file:  # type: ignore[arg-type]\n            lines = changelog_file.read().splitlines()\n\n        # prepare version regex and marker line\n        if template in {\"angular\", \"keepachangelog\"}:\n            version_regex = DEFAULT_VERSION_REGEX\n            marker_line = DEFAULT_MARKER_LINE\n\n        # only keep new entries (missing from changelog)\n        last_released = _latest(lines, re.compile(version_regex))\n        if last_released:\n            # check if the latest version is already in the changelog\n            if last_released in [\n                changelog.versions_list[0].tag,\n                changelog.versions_list[0].planned_tag,\n            ]:\n                raise ValueError(f\"Version {last_released} already in changelog\")\n            changelog.versions_list = _unreleased(\n                changelog.versions_list,\n                last_released,\n            )\n\n        # render new entries\n        rendered = (\n            jinja_template.render(\n                changelog=changelog,\n                jinja_context=jinja_context,\n                in_place=True,\n            ).rstrip(\"\\n\")\n            + \"\\n\"\n        )\n\n        # find marker line(s) in current changelog\n        marker = lines.index(marker_line)\n        try:\n            marker2 = lines[marker + 1 :].index(marker_line)\n        except ValueError:\n            # apply new entries at marker line\n            lines[marker] = rendered\n        else:\n            # apply new entries between marker lines\n            lines[marker : marker + marker2 + 2] = [rendered]\n\n        # write back updated changelog lines\n        with open(output, \"w\") as changelog_file:  # type: ignore[arg-type]\n            changelog_file.write(\"\\n\".join(lines).rstrip(\"\\n\") + \"\\n\")\n\n    # overwrite output file\n    else:\n        rendered = jinja_template.render(changelog=changelog, jinja_context=jinja_context)\n\n        # write result in specified output\n        if output is sys.stdout:\n            sys.stdout.write(rendered)\n        else:\n            with open(output, \"w\") as stream:  # type: ignore[arg-type]\n                stream.write(rendered)\n\n    return changelog, rendered\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_parser","title":"get_parser","text":"<pre><code>get_parser() -&gt; ArgumentParser\n</code></pre> <p>Return the CLI argument parser.</p> <p>Returns:</p> <ul> <li> <code>ArgumentParser</code>         \u2013          <p>An argparse parser.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        prog=\"git-changelog\",\n        description=re.sub(\n            r\"\\n *\",\n            \"\\n\",\n            f\"\"\"\n            Automatic Changelog generator using Jinja2 templates.\n\n            This tool parses your commit messages to extract useful data\n            that is then rendered using Jinja2 templates, for example to\n            a changelog file formatted in Markdown.\n\n            Each Git tag will be treated as a version of your project.\n            Each version contains a set of commits, and will be an entry\n            in your changelog. Commits in each version will be grouped\n            by sections, depending on the commit convention you follow.\n\n            ### Conventions\n\n            {BasicConvention._format_sections_help()}\n            {AngularConvention._format_sections_help()}\n            {ConventionalCommitConvention._format_sections_help()}\n            \"\"\",\n        ),\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        \"repository\",\n        metavar=\"REPOSITORY\",\n        nargs=\"?\",\n        help=\"The repository path, relative or absolute. Default: current working directory.\",\n    )\n\n    parser.add_argument(\n        \"--config-file\",\n        metavar=\"PATH\",\n        nargs=\"*\",\n        help=\"Configuration file(s).\",\n    )\n\n    parser.add_argument(\n        \"-b\",\n        \"--bump-latest\",\n        action=\"store_true\",\n        dest=\"bump_latest\",\n        help=\"Deprecated, use --bump=auto instead. \"\n        \"Guess the new latest version by bumping the previous one based on the set of unreleased commits. \"\n        \"For example, if a commit contains breaking changes, bump the major number (or the minor number for 0.x versions). \"\n        \"Else if there are new features, bump the minor number. Else just bump the patch number. \"\n        \"Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-B\",\n        \"--bump\",\n        action=\"store\",\n        dest=\"bump\",\n        metavar=\"VERSION\",\n        help=\"Specify the bump from latest version for the set of unreleased commits. \"\n        \"Can be one of `auto`, `major`, `minor`, `patch` or a valid SemVer version (eg. 1.2.3). \"\n        \"For both SemVer and PEP 440 versioning schemes (see -n), `auto` will bump the major number \"\n        \"if a commit contains breaking changes (or the minor number for 0.x versions, see -Z), \"\n        \"else the minor number if there are new features, else the patch number. \"\n        \"Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-n\",\n        \"--versioning\",\n        action=\"store\",\n        dest=\"versioning\",\n        metavar=\"SCHEME\",\n        help=\"Versioning scheme to use when bumping and comparing versions. \"\n        \"The selected scheme will impact the values accepted by the `--bump` option. \"\n        \"Supported: `pep440`, `semver`. PEP 440 provides the following bump strategies: `auto`, \"\n        f\"`{'`, `'.join(part for part in bump_pep440.strategies if '+' not in part)}`. \"\n        \"Values `auto`, `major`, `minor`, `micro` can be suffixed with one of `+alpha`, `+beta`, `+candidate`, \"\n        \"and/or `+dev`. Values `alpha`, `beta` and `candidate` can be suffixed with `+dev`. \"\n        \"Examples: `auto+alpha`, `major+beta+dev`, `micro+dev`, `candidate+dev`, etc.. \"\n        \"SemVer provides the following bump strategies: `auto`, \"\n        f\"`{'`, `'.join(bump_semver.strategies)}`. \"\n        \"See the docs for more information. Default: unset (`semver`).\",\n    )\n    parser.add_argument(\n        \"-h\",\n        \"--help\",\n        action=\"help\",\n        default=argparse.SUPPRESS,\n        help=\"Show this help message and exit.\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--in-place\",\n        action=\"store_true\",\n        dest=\"in_place\",\n        help=\"Insert new entries (versions missing from changelog) in-place. \"\n        \"An output file must be specified. With custom templates, \"\n        \"you can pass two additional arguments: `--version-regex` and `--marker-line`. \"\n        \"When writing in-place, an `in_place` variable \"\n        \"will be injected in the Jinja context, \"\n        \"allowing to adapt the generated contents \"\n        \"(for example to skip changelog headers or footers). Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-g\",\n        \"--version-regex\",\n        action=\"store\",\n        metavar=\"REGEX\",\n        dest=\"version_regex\",\n        help=\"A regular expression to match versions in the existing changelog \"\n        \"(used to find the latest release) when writing in-place. \"\n        \"The regular expression must be a Python regex with a `version` named group. \"\n        f\"Default: `{DEFAULT_VERSION_REGEX}`.\",\n    )\n\n    parser.add_argument(\n        \"-m\",\n        \"--marker-line\",\n        action=\"store\",\n        metavar=\"MARKER\",\n        dest=\"marker_line\",\n        help=\"A marker line at which to insert new entries \"\n        \"(versions missing from changelog). \"\n        \"If two marker lines are present in the changelog, \"\n        \"the contents between those two lines will be overwritten \"\n        \"(useful to update an 'Unreleased' entry for example). \"\n        f\"Default: `{DEFAULT_MARKER_LINE}`.\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        action=\"store\",\n        metavar=\"FILE\",\n        dest=\"output\",\n        help=\"Output to given file. Default: standard output.\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--provider\",\n        metavar=\"PROVIDER\",\n        dest=\"provider\",\n        choices=providers.keys(),\n        help=\"Explicitly specify the repository provider. Default: unset.\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--parse-refs\",\n        action=\"store_true\",\n        dest=\"parse_refs\",\n        help=\"Parse provider-specific references in commit messages (GitHub/GitLab/Bitbucket \"\n        \"issues, PRs, etc.). Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-R\",\n        \"--release-notes\",\n        action=\"store_true\",\n        dest=\"release_notes\",\n        help=\"Output release notes to stdout based on the last entry in the changelog. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-I\",\n        \"--input\",\n        metavar=\"FILE\",\n        dest=\"input\",\n        help=f\"Read from given file when creating release notes. Default: `{DEFAULT_CHANGELOG_FILE}`.\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--convention\",\n        \"--commit-style\",\n        \"--style\",\n        metavar=\"CONVENTION\",\n        choices=CONVENTIONS,\n        dest=\"convention\",\n        help=f\"The commit convention to match against. Default: `{DEFAULT_SETTINGS['convention']}`.\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--sections\",\n        action=\"store\",\n        type=_comma_separated_list,\n        metavar=\"SECTIONS\",\n        dest=\"sections\",\n        help=\"A comma-separated list of sections to render. \"\n        \"See the available sections for each supported convention in the description. \"\n        \"Default: unset (None).\",\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--template\",\n        choices=Templates((\"angular\", \"keepachangelog\")),\n        metavar=\"TEMPLATE\",\n        dest=\"template\",\n        help=\"The Jinja2 template to use. Prefix it with `path:` to specify the path \"\n        \"to a Jinja templated file. \"\n        f\"Default: `{DEFAULT_SETTINGS['template']}`.\",\n    )\n    parser.add_argument(\n        \"-T\",\n        \"--trailers\",\n        \"--git-trailers\",\n        action=\"store_true\",\n        dest=\"parse_trailers\",\n        help=\"Parse Git trailers in the commit message. \"\n        \"See https://git-scm.com/docs/git-interpret-trailers. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-E\",\n        \"--omit-empty-versions\",\n        action=\"store_true\",\n        dest=\"omit_empty_versions\",\n        help=\"Omit empty versions from the output. Default: unset (false).\",\n    )\n    parser.add_argument(\n        \"-Z\",\n        \"--no-zerover\",\n        action=\"store_false\",\n        dest=\"zerover\",\n        help=\"By default, breaking changes on a 0.x don't bump the major version, maintaining it at 0. \"\n        \"With this option, a breaking change will bump a 0.x version to 1.0.\",\n    )\n    parser.add_argument(\n        \"-F\",\n        \"--filter-commits\",\n        action=\"store\",\n        metavar=\"RANGE\",\n        dest=\"filter_commits\",\n        help=\"The Git revision-range filter to use (e.g. `v1.2.0..`). Default: no filter.\",\n    )\n    parser.add_argument(\n        \"-j\",\n        \"--jinja-context\",\n        action=_ParseDictAction,\n        metavar=\"KEY=VALUE\",\n        dest=\"jinja_context\",\n        help=\"Pass additional key/value pairs to the template. Option can be used multiple times. \"\n        \"The key/value pairs are accessible as 'jinja_context' in the template.\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s {debug.get_version()}\",\n        help=\"Show the current version of the program and exit.\",\n    )\n    parser.add_argument(\"--debug-info\", action=_DebugInfo, help=\"Print debug information.\")\n\n    return parser\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_release_notes","title":"get_release_notes","text":"<pre><code>get_release_notes(\n    input_file: str | Path = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n) -&gt; str\n</code></pre> <p>Get release notes from existing changelog.</p> <p>This will return the latest entry in the changelog.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str | Path</code>, default:                 <code>'CHANGELOG.md'</code> )         \u2013          <p>The changelog to read from.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>A regular expression to match version entries.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>The insertion marker line in the changelog.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The latest changelog entry.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_release_notes(\n    input_file: str | Path = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n) -&gt; str:\n    \"\"\"Get release notes from existing changelog.\n\n    This will return the latest entry in the changelog.\n\n    Parameters:\n        input_file: The changelog to read from.\n        version_regex: A regular expression to match version entries.\n        marker_line: The insertion marker line in the changelog.\n\n    Returns:\n        The latest changelog entry.\n    \"\"\"\n    release_notes = []\n    found_marker = False\n    found_version = False\n    with open(input_file) as changelog:\n        for line in changelog:\n            line = line.strip()  # noqa: PLW2901\n            if not found_marker:\n                if line == marker_line:\n                    found_marker = True\n                continue\n            if re.search(version_regex, line):\n                if found_version:\n                    break\n                found_version = True\n            release_notes.append(line)\n    result = \"\\n\".join(release_notes).strip()\n    if result.endswith(marker_line):\n        result = result[: -len(marker_line)].strip()\n    return result\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str\n</code></pre> <p>Return the current <code>git-changelog</code> version.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The current <code>git-changelog</code> version.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"Return the current `git-changelog` version.\n\n    Returns:\n        The current `git-changelog` version.\n    \"\"\"\n    try:\n        return metadata.version(\"git-changelog\")\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.main","title":"main","text":"<pre><code>main(args: list[str] | None = None) -&gt; int\n</code></pre> <p>Run the main program.</p> <p>This function is executed when you type <code>git-changelog</code> or <code>python -m git_changelog</code>.</p> <p>Parameters:</p> <ul> <li> <code>args</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>An exit code.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n    \"\"\"Run the main program.\n\n    This function is executed when you type `git-changelog` or `python -m git_changelog`.\n\n    Arguments:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    settings = parse_settings(args)\n\n    if settings.pop(\"release_notes\"):\n        output_release_notes(\n            input_file=settings[\"input\"],\n            version_regex=settings[\"version_regex\"],\n            marker_line=settings[\"marker_line\"],\n            output_file=None,  # force writing to stdout\n        )\n        return 0\n\n    # --input is not necessary anymore\n    settings.pop(\"input\", None)\n    try:\n        build_and_render(**settings)\n    except ValueError as error:\n        print(f\"git-changelog: {error}\", file=sys.stderr)\n        return 1\n\n    return 0\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.output_release_notes","title":"output_release_notes","text":"<pre><code>output_release_notes(\n    input_file: str = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    output_file: str | TextIO | None = None,\n) -&gt; None\n</code></pre> <p>Print release notes from existing changelog.</p> <p>This will print the latest entry in the changelog.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str</code>, default:                 <code>'CHANGELOG.md'</code> )         \u2013          <p>The changelog to read from.</p> </li> <li> <code>version_regex</code>             (<code>str</code>, default:                 <code>DEFAULT_VERSION_REGEX</code> )         \u2013          <p>A regular expression to match version entries.</p> </li> <li> <code>marker_line</code>             (<code>str</code>, default:                 <code>DEFAULT_MARKER_LINE</code> )         \u2013          <p>The insertion marker line in the changelog.</p> </li> <li> <code>output_file</code>             (<code>str | TextIO | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to print/write the release notes.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def output_release_notes(\n    input_file: str = \"CHANGELOG.md\",\n    version_regex: str = DEFAULT_VERSION_REGEX,\n    marker_line: str = DEFAULT_MARKER_LINE,\n    output_file: str | TextIO | None = None,\n) -&gt; None:\n    \"\"\"Print release notes from existing changelog.\n\n    This will print the latest entry in the changelog.\n\n    Parameters:\n        input_file: The changelog to read from.\n        version_regex: A regular expression to match version entries.\n        marker_line: The insertion marker line in the changelog.\n        output_file: Where to print/write the release notes.\n    \"\"\"\n    output_file = output_file or sys.stdout\n    release_notes = get_release_notes(input_file, version_regex, marker_line)\n    try:\n        output_file.write(release_notes)  # type: ignore[union-attr]\n    except AttributeError:\n        with open(output_file, \"w\") as file:  # type: ignore[arg-type]\n            file.write(release_notes)\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.parse_settings","title":"parse_settings","text":"<pre><code>parse_settings(args: list[str] | None = None) -&gt; dict\n</code></pre> <p>Parse arguments and config files to build the final settings set.</p> <p>Parameters:</p> <ul> <li> <code>args</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A dictionary with the final settings.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def parse_settings(args: list[str] | None = None) -&gt; dict:\n    \"\"\"Parse arguments and config files to build the final settings set.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        A dictionary with the final settings.\n    \"\"\"\n    parser = get_parser()\n    opts = vars(parser.parse_args(args=args))\n\n    # Determine which arguments were explicitly set with the CLI\n    sentinel = object()\n    sentinel_ns = argparse.Namespace(**{key: sentinel for key in opts})\n    explicit_opts_dict = {\n        key: opts.get(key, None)\n        for key, value in vars(parser.parse_args(namespace=sentinel_ns, args=args)).items()\n        if value is not sentinel\n    }\n\n    config_file = explicit_opts_dict.pop(\"config_file\", DEFAULT_CONFIG_FILES)\n    if str(config_file).strip().lower() in (\"no\", \"none\", \"off\", \"false\", \"0\", \"\"):\n        config_file = None\n    elif str(config_file).strip().lower() in (\"yes\", \"default\", \"on\", \"true\", \"1\"):\n        config_file = DEFAULT_CONFIG_FILES\n\n    jinja_context = explicit_opts_dict.pop(\"jinja_context\", {})\n\n    settings = read_config(config_file)\n\n    # CLI arguments override the config file settings\n    settings.update(explicit_opts_dict)\n\n    # Merge jinja context, CLI values override config file values.\n    settings[\"jinja_context\"].update(jinja_context)\n\n    # TODO: remove at some point\n    if \"bump_latest\" in explicit_opts_dict:\n        warnings.warn(\"`--bump-latest` is deprecated in favor of `--bump=auto`\", FutureWarning, stacklevel=1)\n\n    return settings\n</code></pre>"},{"location":"reference/git_changelog/cli/#git_changelog.cli.read_config","title":"read_config","text":"<pre><code>read_config(\n    config_file: (\n        Sequence[str | Path] | str | Path | None\n    ) = DEFAULT_CONFIG_FILES,\n) -&gt; dict\n</code></pre> <p>Find config files and initialize settings with the one of highest priority.</p> <p>Parameters:</p> <ul> <li> <code>config_file</code>             (<code>Sequence[str | Path] | str | Path | None</code>, default:                 <code>DEFAULT_CONFIG_FILES</code> )         \u2013          <p>A path or list of paths to configuration file(s); or <code>None</code> to disable config file settings. Default: a list of paths given by <code>git_changelog.cli.DEFAULT_CONFIG_FILES</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>A settings dictionary. Default settings if no config file is found or <code>config_file</code> is <code>None</code>.</p> </li> </ul> Source code in <code>src/git_changelog/cli.py</code> <pre><code>def read_config(\n    config_file: Sequence[str | Path] | str | Path | None = DEFAULT_CONFIG_FILES,\n) -&gt; dict:\n    \"\"\"Find config files and initialize settings with the one of highest priority.\n\n    Parameters:\n        config_file: A path or list of paths to configuration file(s); or `None` to\n            disable config file settings. Default: a list of paths given by\n            [`git_changelog.cli.DEFAULT_CONFIG_FILES`][].\n\n    Returns:\n        A settings dictionary. Default settings if no config file is found or `config_file` is `None`.\n\n    \"\"\"\n    project_config = DEFAULT_SETTINGS.copy()\n    if config_file is None:  # Unset config file\n        return project_config\n\n    for filename in config_file if isinstance(config_file, (list, tuple)) else [config_file]:\n        _path = Path(filename)\n\n        if not _path.exists():\n            continue\n\n        with _path.open(\"rb\") as file:\n            new_settings = tomllib.load(file)\n        if _path.name == \"pyproject.toml\":\n            new_settings = new_settings.get(\"tool\", {}).get(\"git-changelog\", {}) or new_settings.get(\n                \"tool.git-changelog\",\n                {},\n            )\n\n            if not new_settings:  # pyproject.toml did not have a git-changelog section\n                continue\n\n        # Settings can have hyphens like in the CLI\n        new_settings = {key.replace(\"-\", \"_\"): value for key, value in new_settings.items()}\n\n        # TODO: remove at some point\n        if \"bump_latest\" in new_settings:\n            _opt_value = new_settings[\"bump_latest\"]\n            _suggestion = (\n                \"remove it from the config file\" if not _opt_value else \"set `bump = 'auto'` in the config file instead\"\n            )\n            warnings.warn(\n                f\"`bump-latest = {str(_opt_value).lower()}` option found \"\n                f\"in config file ({_path.absolute()}). This option will be removed in the future. \"\n                f\"To achieve the same result, please {_suggestion}.\",\n                FutureWarning,\n                stacklevel=1,\n            )\n\n        # Massage found values to meet expectations\n        # Parse sections\n        if \"sections\" in new_settings:\n            # Remove \"sections\" from dict, only restore if the list is valid\n            sections = new_settings.pop(\"sections\", None)\n            if isinstance(sections, str):\n                sections = sections.split(\",\")\n\n            sections = [s.strip() for s in sections if isinstance(s, str) and s.strip()]\n\n            if sections:  # toml doesn't store null/nil\n                new_settings[\"sections\"] = sections\n\n        project_config.update(new_settings)\n        break\n\n    return project_config\n</code></pre>"},{"location":"reference/git_changelog/commit/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> commit","text":""},{"location":"reference/git_changelog/commit/#git_changelog.commit","title":"commit","text":"<p>Module containing the commit logic.</p> <p>Classes:</p> <ul> <li> <code>AngularConvention</code>         \u2013          <p>Angular commit message convention.</p> </li> <li> <code>BasicConvention</code>         \u2013          <p>Basic commit message convention.</p> </li> <li> <code>Commit</code>         \u2013          <p>A class to represent a commit.</p> </li> <li> <code>CommitConvention</code>         \u2013          <p>A base class for a convention of commit messages.</p> </li> <li> <code>ConventionalCommitConvention</code>         \u2013          <p>Conventional commit message convention.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention","title":"AngularConvention","text":"<p>             Bases: <code>CommitConvention</code></p> <p>Angular commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_subject</code>           \u2013            <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"feat\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularConvention.parse_subject","title":"parse_subject","text":"<pre><code>parse_subject(commit_subject: str) -&gt; dict[str, str]\n</code></pre> <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>         \u2013          <p>The parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n    \"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The parsed data.\n    \"\"\"\n    subject_match = self.SUBJECT_REGEX.match(commit_subject)\n    if subject_match:\n        dct = subject_match.groupdict()\n        dct[\"type\"] = self.TYPES[dct[\"type\"]]\n        return dct\n    return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention","title":"BasicConvention","text":"<p>             Bases: <code>CommitConvention</code></p> <p>Basic commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_type</code>           \u2013            <p>Parse the type of the commit given its subject.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"add\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicConvention.parse_type","title":"parse_type","text":"<pre><code>parse_type(commit_subject: str) -&gt; str\n</code></pre> <p>Parse the type of the commit given its subject.</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The commit type.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_type(self, commit_subject: str) -&gt; str:\n    \"\"\"Parse the type of the commit given its subject.\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The commit type.\n    \"\"\"\n    type_match = self.TYPE_REGEX.match(commit_subject)\n    if type_match:\n        return self.TYPES.get(type_match.groupdict()[\"type\"].lower(), \"\")\n    return \"\"\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit","title":"Commit","text":"<pre><code>Commit(\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n    parent_hashes: str | list[str] = \"\",\n    commits_map: dict[str, Commit] | None = None,\n    version_parser: (\n        Callable[[str], tuple[ParsedVersion, str]] | None\n    ) = None\n)\n</code></pre> <p>A class to represent a commit.</p> <p>Parameters:</p> <ul> <li> <code>commit_hash</code>             (<code>str</code>)         \u2013          <p>The commit hash.</p> </li> <li> <code>author_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author name.</p> </li> <li> <code>author_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The author email.</p> </li> <li> <code>author_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The authoring date (datetime or UTC timestamp).</p> </li> <li> <code>committer_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer name.</p> </li> <li> <code>committer_email</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The committer email.</p> </li> <li> <code>committer_date</code>             (<code>str | datetime</code>, default:                 <code>''</code> )         \u2013          <p>The committing date (datetime or UTC timestamp).</p> </li> <li> <code>refs</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit refs.</p> </li> <li> <code>subject</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit message subject.</p> </li> <li> <code>body</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The commit message body.</p> </li> <li> <code>url</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The commit URL.</p> </li> <li> <code>parse_trailers</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse Git trailers.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>update_with_convention</code>           \u2013            <p>Apply the convention-parsed data to this commit.</p> </li> <li> <code>update_with_provider</code>           \u2013            <p>Apply the provider-parsed data to this commit.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>parent_commits</code>             (<code>list[Commit]</code>)         \u2013          <p>Parent commits of this commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def __init__(\n    self,\n    commit_hash: str,\n    author_name: str = \"\",\n    author_email: str = \"\",\n    author_date: str | datetime = \"\",\n    committer_name: str = \"\",\n    committer_email: str = \"\",\n    committer_date: str | datetime = \"\",\n    refs: str = \"\",\n    subject: str = \"\",\n    body: list[str] | None = None,\n    url: str = \"\",\n    *,\n    parse_trailers: bool = False,\n    parent_hashes: str | list[str] = \"\",\n    commits_map: dict[str, Commit] | None = None,\n    version_parser: Callable[[str], tuple[ParsedVersion, str]] | None = None,\n):\n    \"\"\"Initialization method.\n\n    Arguments:\n        commit_hash: The commit hash.\n        author_name: The author name.\n        author_email: The author email.\n        author_date: The authoring date (datetime or UTC timestamp).\n        committer_name: The committer name.\n        committer_email: The committer email.\n        committer_date: The committing date (datetime or UTC timestamp).\n        refs: The commit refs.\n        subject: The commit message subject.\n        body: The commit message body.\n        url: The commit URL.\n        parse_trailers: Whether to parse Git trailers.\n    \"\"\"\n    if not author_date:\n        author_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(author_date, str):\n        author_date = datetime.fromtimestamp(float(author_date), tz=timezone.utc)\n    if not committer_date:\n        committer_date = datetime.now()  # noqa: DTZ005\n    elif isinstance(committer_date, str):\n        committer_date = datetime.fromtimestamp(float(committer_date), tz=timezone.utc)\n\n    self.hash: str = commit_hash\n    self.author_name: str = author_name\n    self.author_email: str = author_email\n    self.author_date: datetime = author_date\n    self.committer_name: str = committer_name\n    self.committer_email: str = committer_email\n    self.committer_date: datetime = committer_date\n    self.subject: str = subject\n    self.body: list[str] = _clean_body(body) if body else []\n    self.url: str = url\n\n    tag = \"\"\n    for ref in refs.split(\",\"):\n        ref = ref.strip()  # noqa: PLW2901\n        if ref.startswith(\"tag: \"):\n            ref = ref.replace(\"tag: \", \"\")  # noqa: PLW2901\n            if version_parser is None or _is_valid_version(ref, version_parser):\n                tag = ref\n                break\n    self.tag: str = tag\n    self.version: str = tag\n\n    if isinstance(parent_hashes, str):\n        parent_hashes = parent_hashes.split()\n    self.parent_hashes = parent_hashes\n    self._commits_map = commits_map\n\n    self.text_refs: dict[str, list[Ref]] = {}\n    self.convention: dict[str, Any] = {}\n\n    self.trailers: dict[str, str] = {}\n    self.body_without_trailers = self.body\n\n    if parse_trailers:\n        self._parse_trailers()\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.parent_commits","title":"parent_commits  <code>property</code>","text":"<pre><code>parent_commits: list[Commit]\n</code></pre> <p>Parent commits of this commit.</p>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_convention","title":"update_with_convention","text":"<pre><code>update_with_convention(\n    convention: CommitConvention,\n) -&gt; None\n</code></pre> <p>Apply the convention-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>convention</code>             (<code>CommitConvention</code>)         \u2013          <p>The convention to use.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_convention(self, convention: CommitConvention) -&gt; None:\n    \"\"\"Apply the convention-parsed data to this commit.\n\n    Arguments:\n        convention: The convention to use.\n    \"\"\"\n    self.convention.update(convention.parse_commit(self))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_provider","title":"update_with_provider","text":"<pre><code>update_with_provider(\n    provider: ProviderRefParser, parse_refs: bool = True\n) -&gt; None\n</code></pre> <p>Apply the provider-parsed data to this commit.</p> <p>Parameters:</p> <ul> <li> <code>provider</code>             (<code>ProviderRefParser</code>)         \u2013          <p>The provider to use.</p> </li> <li> <code>parse_refs</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to parse references for this provider.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def update_with_provider(\n    self,\n    provider: ProviderRefParser,\n    parse_refs: bool = True,  # noqa: FBT001,FBT002\n) -&gt; None:\n    \"\"\"Apply the provider-parsed data to this commit.\n\n    Arguments:\n        provider: The provider to use.\n        parse_refs: Whether to parse references for this provider.\n    \"\"\"\n    # set the commit url based on provider\n    # FIXME: hardcoded 'commits'\n    if \"commits\" in provider.REF:\n        self.url = provider.build_ref_url(\"commits\", {\"ref\": self.hash})\n    else:\n        # use default \"commit\" url (could be wrong)\n        self.url = f\"{provider.url}/{provider.namespace}/{provider.project}/commit/{self.hash}\"\n\n    # build commit text references from its subject and body\n    if parse_refs:\n        for ref_type in provider.REF:\n            self.text_refs[ref_type] = provider.get_refs(\n                ref_type,\n                \"\\n\".join([self.subject, *self.body]),\n            )\n\n        if \"issues\" in self.text_refs:\n            self.text_refs[\"issues_not_in_subject\"] = []\n            for issue in self.text_refs[\"issues\"]:\n                if issue.ref not in self.subject:\n                    self.text_refs[\"issues_not_in_subject\"].append(issue)\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention","title":"CommitConvention","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a convention of commit messages.</p> <p>Methods:</p> <ul> <li> <code>parse_commit</code>           \u2013            <p>Parse the commit to extract information.</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitConvention.parse_commit","title":"parse_commit  <code>abstractmethod</code>","text":"<pre><code>parse_commit(commit: Commit) -&gt; dict[str, str | bool]\n</code></pre> <p>Parse the commit to extract information.</p> <p>Parameters:</p> <ul> <li> <code>commit</code>             (<code>Commit</code>)         \u2013          <p>The commit to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str | bool]</code>         \u2013          <p>A dictionary containing the parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>@abstractmethod\ndef parse_commit(self, commit: Commit) -&gt; dict[str, str | bool]:\n    \"\"\"Parse the commit to extract information.\n\n    Arguments:\n        commit: The commit to parse.\n\n    Returns:\n        A dictionary containing the parsed data.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention","title":"ConventionalCommitConvention","text":"<p>             Bases: <code>AngularConvention</code></p> <p>Conventional commit message convention.</p> <p>Methods:</p> <ul> <li> <code>is_major</code>           \u2013            <p>Tell if this commit is worth a major bump.</p> </li> <li> <code>is_minor</code>           \u2013            <p>Tell if this commit is worth a minor bump.</p> </li> <li> <code>parse_subject</code>           \u2013            <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> </li> </ul>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.is_major","title":"is_major","text":"<pre><code>is_major(commit_message: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a major bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_message</code>             (<code>str</code>)         \u2013          <p>The commit message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a major commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_major(self, commit_message: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a major bump.\n\n    Arguments:\n        commit_message: The commit message.\n\n    Returns:\n        Whether it's a major commit.\n    \"\"\"\n    return bool(self.BREAK_REGEX.search(commit_message))\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.is_minor","title":"is_minor","text":"<pre><code>is_minor(commit_type: str) -&gt; bool\n</code></pre> <p>Tell if this commit is worth a minor bump.</p> <p>Parameters:</p> <ul> <li> <code>commit_type</code>             (<code>str</code>)         \u2013          <p>The commit type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether it's a minor commit.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def is_minor(self, commit_type: str) -&gt; bool:\n    \"\"\"Tell if this commit is worth a minor bump.\n\n    Arguments:\n        commit_type: The commit type.\n\n    Returns:\n        Whether it's a minor commit.\n    \"\"\"\n    return commit_type == self.TYPES[\"feat\"]\n</code></pre>"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitConvention.parse_subject","title":"parse_subject","text":"<pre><code>parse_subject(commit_subject: str) -&gt; dict[str, str]\n</code></pre> <p>Parse the subject of the commit (<code>&lt;type&gt;[(scope)]: Subject</code>).</p> <p>Parameters:</p> <ul> <li> <code>commit_subject</code>             (<code>str</code>)         \u2013          <p>The commit message subject.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>         \u2013          <p>The parsed data.</p> </li> </ul> Source code in <code>src/git_changelog/commit.py</code> <pre><code>def parse_subject(self, commit_subject: str) -&gt; dict[str, str]:\n    \"\"\"Parse the subject of the commit (`&lt;type&gt;[(scope)]: Subject`).\n\n    Arguments:\n        commit_subject: The commit message subject.\n\n    Returns:\n        The parsed data.\n    \"\"\"\n    subject_match = self.SUBJECT_REGEX.match(commit_subject)\n    if subject_match:\n        dct = subject_match.groupdict()\n        dct[\"type\"] = self.TYPES[dct[\"type\"]]\n        return dct\n    return {\"type\": \"\", \"scope\": \"\", \"subject\": commit_subject}\n</code></pre>"},{"location":"reference/git_changelog/debug/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> debug","text":""},{"location":"reference/git_changelog/debug/#git_changelog.debug","title":"debug","text":"<p>Debugging utilities.</p> <p>Classes:</p> <ul> <li> <code>Environment</code>         \u2013          <p>Dataclass to store environment information.</p> </li> <li> <code>Package</code>         \u2013          <p>Dataclass describing a Python package.</p> </li> <li> <code>Variable</code>         \u2013          <p>Dataclass describing an environment variable.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_debug_info</code>           \u2013            <p>Get debug/environment information.</p> </li> <li> <code>get_version</code>           \u2013            <p>Get version of the given distribution.</p> </li> <li> <code>print_debug_info</code>           \u2013            <p>Print debug/environment information.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment","title":"Environment  <code>dataclass</code>","text":"<pre><code>Environment(\n    interpreter_name: str,\n    interpreter_version: str,\n    interpreter_path: str,\n    platform: str,\n    packages: list[Package],\n    variables: list[Variable],\n)\n</code></pre> <p>Dataclass to store environment information.</p> <p>Attributes:</p> <ul> <li> <code>interpreter_name</code>             (<code>str</code>)         \u2013          <p>Python interpreter name.</p> </li> <li> <code>interpreter_path</code>             (<code>str</code>)         \u2013          <p>Path to Python executable.</p> </li> <li> <code>interpreter_version</code>             (<code>str</code>)         \u2013          <p>Python interpreter version.</p> </li> <li> <code>packages</code>             (<code>list[Package]</code>)         \u2013          <p>Installed packages.</p> </li> <li> <code>platform</code>             (<code>str</code>)         \u2013          <p>Operating System.</p> </li> <li> <code>variables</code>             (<code>list[Variable]</code>)         \u2013          <p>Environment variables.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.interpreter_name","title":"interpreter_name  <code>instance-attribute</code>","text":"<pre><code>interpreter_name: str\n</code></pre> <p>Python interpreter name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.interpreter_path","title":"interpreter_path  <code>instance-attribute</code>","text":"<pre><code>interpreter_path: str\n</code></pre> <p>Path to Python executable.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.interpreter_version","title":"interpreter_version  <code>instance-attribute</code>","text":"<pre><code>interpreter_version: str\n</code></pre> <p>Python interpreter version.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package]\n</code></pre> <p>Installed packages.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform: str\n</code></pre> <p>Operating System.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Environment.variables","title":"variables  <code>instance-attribute</code>","text":"<pre><code>variables: list[Variable]\n</code></pre> <p>Environment variables.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package","title":"Package  <code>dataclass</code>","text":"<pre><code>Package(name: str, version: str)\n</code></pre> <p>Dataclass describing a Python package.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Package name.</p> </li> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>Package version.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Package name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Package.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Package version.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable","title":"Variable  <code>dataclass</code>","text":"<pre><code>Variable(name: str, value: str)\n</code></pre> <p>Dataclass describing an environment variable.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Variable name.</p> </li> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>Variable value.</p> </li> </ul>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Variable name.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.Variable.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>Variable value.</p>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.get_debug_info","title":"get_debug_info","text":"<pre><code>get_debug_info() -&gt; Environment\n</code></pre> <p>Get debug/environment information.</p> <p>Returns:</p> <ul> <li> <code>Environment</code>         \u2013          <p>Environment information.</p> </li> </ul> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def get_debug_info() -&gt; Environment:\n    \"\"\"Get debug/environment information.\n\n    Returns:\n        Environment information.\n    \"\"\"\n    py_name, py_version = _interpreter_name_version()\n    packages = [\"git-changelog\"]\n    variables = [\"PYTHONPATH\", *[var for var in os.environ if var.startswith(\"GIT_CHANGELOG\")]]\n    return Environment(\n        interpreter_name=py_name,\n        interpreter_version=py_version,\n        interpreter_path=sys.executable,\n        platform=platform.platform(),\n        variables=[Variable(var, val) for var in variables if (val := os.getenv(var))],\n        packages=[Package(pkg, get_version(pkg)) for pkg in packages],\n    )\n</code></pre>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.get_version","title":"get_version","text":"<pre><code>get_version(dist: str = 'git-changelog') -&gt; str\n</code></pre> <p>Get version of the given distribution.</p> <p>Parameters:</p> <ul> <li> <code>dist</code>             (<code>str</code>, default:                 <code>'git-changelog'</code> )         \u2013          <p>A distribution name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A version number.</p> </li> </ul> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def get_version(dist: str = \"git-changelog\") -&gt; str:\n    \"\"\"Get version of the given distribution.\n\n    Parameters:\n        dist: A distribution name.\n\n    Returns:\n        A version number.\n    \"\"\"\n    try:\n        return metadata.version(dist)\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/git_changelog/debug/#git_changelog.debug.print_debug_info","title":"print_debug_info","text":"<pre><code>print_debug_info() -&gt; None\n</code></pre> <p>Print debug/environment information.</p> Source code in <code>src/git_changelog/debug.py</code> <pre><code>def print_debug_info() -&gt; None:\n    \"\"\"Print debug/environment information.\"\"\"\n    info = get_debug_info()\n    print(f\"- __System__: {info.platform}\")\n    print(f\"- __Python__: {info.interpreter_name} {info.interpreter_version} ({info.interpreter_path})\")\n    print(\"- __Environment variables__:\")\n    for var in info.variables:\n        print(f\"  - `{var.name}`: `{var.value}`\")\n    print(\"- __Installed packages__:\")\n    for pkg in info.packages:\n        print(f\"  - `{pkg.name}` v{pkg.version}\")\n</code></pre>"},{"location":"reference/git_changelog/providers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> providers","text":""},{"location":"reference/git_changelog/providers/#git_changelog.providers","title":"providers","text":"<p>Module containing the parsing utilities for git providers.</p> <p>Classes:</p> <ul> <li> <code>Bitbucket</code>         \u2013          <p>A parser for the Bitbucket references.</p> </li> <li> <code>GitHub</code>         \u2013          <p>A parser for the GitHub references.</p> </li> <li> <code>GitLab</code>         \u2013          <p>A parser for the GitLab references.</p> </li> <li> <code>ProviderRefParser</code>         \u2013          <p>A base class for specific providers reference parsers.</p> </li> <li> <code>Ref</code>         \u2013          <p>A class to represent a reference and its URL.</p> </li> <li> <code>RefDef</code>         \u2013          <p>A class to store a reference regular expression and URL building string.</p> </li> <li> <code>RefRe</code>         \u2013          <p>An enum helper to store parts of regular expressions for references.</p> </li> </ul>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket","title":"Bitbucket","text":"<pre><code>Bitbucket(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the Bitbucket references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Bitbucket.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub","title":"GitHub","text":"<pre><code>GitHub(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitHub references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab","title":"GitLab","text":"<pre><code>GitLab(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ProviderRefParser</code></p> <p>A parser for the GitLab references.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser","title":"ProviderRefParser","text":"<pre><code>ProviderRefParser(\n    namespace: str, project: str, url: str | None = None\n)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>A base class for specific providers reference parsers.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>             (<code>str</code>)         \u2013          <p>The Bitbucket namespace.</p> </li> <li> <code>project</code>             (<code>str</code>)         \u2013          <p>The Bitbucket project.</p> </li> <li> <code>url</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Bitbucket URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>build_ref_url</code>           \u2013            <p>Build the URL for a reference type and a dictionary of matched groups.</p> </li> <li> <code>get_compare_url</code>           \u2013            <p>Get the URL for a tag comparison.</p> </li> <li> <code>get_refs</code>           \u2013            <p>Find all references in the given text.</p> </li> <li> <code>get_tag_url</code>           \u2013            <p>Get the URL for a git tag.</p> </li> <li> <code>parse_refs</code>           \u2013            <p>Parse references in the given text.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, namespace: str, project: str, url: str | None = None):\n    \"\"\"Initialization method.\n\n    Arguments:\n        namespace: The Bitbucket namespace.\n        project: The Bitbucket project.\n        url: The Bitbucket URL.\n    \"\"\"\n    self.namespace: str = namespace\n    self.project: str = project\n    self.url: str = url or self.url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.build_ref_url","title":"build_ref_url","text":"<pre><code>build_ref_url(\n    ref_type: str, match_dict: dict[str, str]\n) -&gt; str\n</code></pre> <p>Build the URL for a reference type and a dictionary of matched groups.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>match_dict</code>             (<code>dict[str, str]</code>)         \u2013          <p>The matched groups.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The built URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def build_ref_url(self, ref_type: str, match_dict: dict[str, str]) -&gt; str:\n    \"\"\"Build the URL for a reference type and a dictionary of matched groups.\n\n    Arguments:\n        ref_type: The reference type.\n        match_dict: The matched groups.\n\n    Returns:\n        The built URL.\n    \"\"\"\n    return self.REF[ref_type].url_string.format(**match_dict)\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_compare_url","title":"get_compare_url  <code>abstractmethod</code>","text":"<pre><code>get_compare_url(base: str, target: str) -&gt; str\n</code></pre> <p>Get the URL for a tag comparison.</p> <p>Parameters:</p> <ul> <li> <code>base</code>             (<code>str</code>)         \u2013          <p>The base tag.</p> </li> <li> <code>target</code>             (<code>str</code>)         \u2013          <p>The target tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The comparison URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_compare_url(self, base: str, target: str) -&gt; str:\n    \"\"\"Get the URL for a tag comparison.\n\n    Arguments:\n        base: The base tag.\n        target: The target tag.\n\n    Returns:\n        The comparison URL.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_refs","title":"get_refs","text":"<pre><code>get_refs(ref_type: str, text: str) -&gt; list[Ref]\n</code></pre> <p>Find all references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text in which to search references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Ref]</code>         \u2013          <p>A list of references (instances of Ref).</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def get_refs(self, ref_type: str, text: str) -&gt; list[Ref]:\n    \"\"\"Find all references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text in which to search references.\n\n    Returns:\n        A list of references (instances of [Ref][git_changelog.providers.Ref]).\n    \"\"\"\n    return [\n        Ref(ref=match.group().strip(), url=self.build_ref_url(ref_type, match.groupdict()))\n        for match in self.parse_refs(ref_type, text)\n    ]\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_tag_url","title":"get_tag_url  <code>abstractmethod</code>","text":"<pre><code>get_tag_url(tag: str) -&gt; str\n</code></pre> <p>Get the URL for a git tag.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>             (<code>str</code>)         \u2013          <p>The git tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The tag URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>@abstractmethod\ndef get_tag_url(self, tag: str) -&gt; str:\n    \"\"\"Get the URL for a git tag.\n\n    Arguments:\n        tag: The git tag.\n\n    Returns:\n        The tag URL.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.parse_refs","title":"parse_refs","text":"<pre><code>parse_refs(ref_type: str, text: str) -&gt; list[Match]\n</code></pre> <p>Parse references in the given text.</p> <p>Parameters:</p> <ul> <li> <code>ref_type</code>             (<code>str</code>)         \u2013          <p>The reference type.</p> </li> <li> <code>text</code>             (<code>str</code>)         \u2013          <p>The text to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Match]</code>         \u2013          <p>A list of regular expressions matches.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def parse_refs(self, ref_type: str, text: str) -&gt; list[Match]:\n    \"\"\"Parse references in the given text.\n\n    Arguments:\n        ref_type: The reference type.\n        text: The text to parse.\n\n    Returns:\n        A list of regular expressions matches.\n    \"\"\"\n    if ref_type not in self.REF:\n        refs = [key for key in self.REF if key.startswith(ref_type)]\n        return [match for ref in refs for match in self.REF[ref].regex.finditer(text)]\n    return list(self.REF[ref_type].regex.finditer(text))\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref","title":"Ref","text":"<pre><code>Ref(ref: str, url: str)\n</code></pre> <p>A class to represent a reference and its URL.</p> <p>Parameters:</p> <ul> <li> <code>ref</code>             (<code>str</code>)         \u2013          <p>The reference text.</p> </li> <li> <code>url</code>             (<code>str</code>)         \u2013          <p>The reference URL.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, ref: str, url: str) -&gt; None:\n    \"\"\"Initialization method.\n\n    Arguments:\n        ref: The reference text.\n        url: The reference URL.\n    \"\"\"\n    self.ref: str = ref\n    self.url: str = url\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef","title":"RefDef","text":"<pre><code>RefDef(regex: Pattern, url_string: str)\n</code></pre> <p>A class to store a reference regular expression and URL building string.</p> <p>Parameters:</p> <ul> <li> <code>regex</code>             (<code>Pattern</code>)         \u2013          <p>The regular expression to match the reference.</p> </li> <li> <code>url_string</code>             (<code>str</code>)         \u2013          <p>The URL string to format using matched groups.</p> </li> </ul> Source code in <code>src/git_changelog/providers.py</code> <pre><code>def __init__(self, regex: Pattern, url_string: str):\n    \"\"\"Initialization method.\n\n    Arguments:\n        regex: The regular expression to match the reference.\n        url_string: The URL string to format using matched groups.\n    \"\"\"\n    self.regex = regex\n    self.url_string = url_string\n</code></pre>"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefRe","title":"RefRe","text":"<p>An enum helper to store parts of regular expressions for references.</p>"},{"location":"reference/git_changelog/versioning/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> versioning","text":""},{"location":"reference/git_changelog/versioning/#git_changelog.versioning","title":"versioning","text":"<p>Utilities to handle different versioning schemes such as SemVer and PEP 440.</p> <p>Classes:</p> <ul> <li> <code>PEP440Bumper</code>         \u2013          <p>PEP 440 version bumper.</p> </li> <li> <code>PEP440Version</code>         \u2013          <p>PEP 440 version.</p> </li> <li> <code>ParsedVersion</code>         \u2013          <p>Base class for versioning schemes.</p> </li> <li> <code>SemVerBumper</code>         \u2013          <p>SemVer version bumper.</p> </li> <li> <code>SemVerVersion</code>         \u2013          <p>SemVer version.</p> </li> <li> <code>VersionBumper</code>         \u2013          <p>Base class for version bumpers.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>parse_pep440</code>           \u2013            <p>Parse a PEP version.</p> </li> <li> <code>parse_semver</code>           \u2013            <p>Parse a SemVer version.</p> </li> <li> <code>version_prefix</code>           \u2013            <p>Return a version and its optional <code>v</code> prefix.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>bump_pep440</code>         \u2013          <p>Bump a PEP 440 version.</p> </li> <li> <code>bump_semver</code>         \u2013          <p>Bump a SemVer version.</p> </li> </ul>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.bump_pep440","title":"bump_pep440  <code>module-attribute</code>","text":"<pre><code>bump_pep440 = PEP440Bumper(__args__)\n</code></pre> <p>Bump a PEP 440 version.</p>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.bump_semver","title":"bump_semver  <code>module-attribute</code>","text":"<pre><code>bump_semver = SemVerBumper(__args__)\n</code></pre> <p>Bump a SemVer version.</p>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Bumper","title":"PEP440Bumper","text":"<pre><code>PEP440Bumper(strategies: tuple[str, ...])\n</code></pre> <p>             Bases: <code>VersionBumper</code></p> <p>PEP 440 version bumper.</p> <p>Parameters:</p> <ul> <li> <code>strategies</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The supported bumping strategies.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def __init__(self, strategies: tuple[str, ...]) -&gt; None:\n    \"\"\"Initialize the bumper.\n\n    Parameters:\n        strategies: The supported bumping strategies.\n    \"\"\"\n    self.strategies = strategies\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version","title":"PEP440Version","text":"<p>             Bases: <code>Version</code>, <code>ParsedVersion</code></p> <p>PEP 440 version.</p> <p>Methods:</p> <ul> <li> <code>bump_alpha</code>           \u2013            <p>Bump alpha-release.</p> </li> <li> <code>bump_beta</code>           \u2013            <p>Bump beta-release.</p> </li> <li> <code>bump_candidate</code>           \u2013            <p>Bump candidate release.</p> </li> <li> <code>bump_dev</code>           \u2013            <p>Bump dev-release.</p> </li> <li> <code>bump_epoch</code>           \u2013            <p>Bump epoch.</p> </li> <li> <code>bump_major</code>           \u2013            <p>Bump major.</p> </li> <li> <code>bump_micro</code>           \u2013            <p>Bump micro.</p> </li> <li> <code>bump_minor</code>           \u2013            <p>Bump minor.</p> </li> <li> <code>bump_post</code>           \u2013            <p>Bump post-release.</p> </li> <li> <code>bump_pre</code>           \u2013            <p>Bump pre-release.</p> </li> <li> <code>bump_release</code>           \u2013            <p>Bump given release level.</p> </li> <li> <code>dent_alpha</code>           \u2013            <p>Dent to alpha-release.</p> </li> <li> <code>dent_beta</code>           \u2013            <p>Dent to beta-release.</p> </li> <li> <code>dent_candidate</code>           \u2013            <p>Dent to candidate release.</p> </li> <li> <code>dent_dev</code>           \u2013            <p>Dent to dev-release.</p> </li> <li> <code>dent_pre</code>           \u2013            <p>Dent to pre-release.</p> </li> <li> <code>from_parts</code>           \u2013            <p>Build a version from its parts.</p> </li> </ul>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_alpha","title":"bump_alpha","text":"<pre><code>bump_alpha() -&gt; PEP440Version\n</code></pre> <p>Bump alpha-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_alpha()\nValueError: Cannot bump from release to alpha pre-release (use `dent_alpha`)\n&gt;&gt;&gt; PEP440Version(\"1a0\").bump_alpha()\n&lt;Version('1a1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").bump_alpha(\"a\")\n&lt;Version('1a1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_alpha()\n&lt;Version('1a1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, bumped alpha pre-release and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_alpha(self) -&gt; PEP440Version:\n    \"\"\"Bump alpha-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_alpha()\n        ValueError: Cannot bump from release to alpha pre-release (use `dent_alpha`)\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_alpha()\n        &lt;Version('1a1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_alpha(\"a\")\n        &lt;Version('1a1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_alpha()\n        &lt;Version('1a1')&gt;\n\n    Returns:\n        Version with same epoch, same release, bumped alpha pre-release and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_pre(\"a\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_beta","title":"bump_beta","text":"<pre><code>bump_beta() -&gt; PEP440Version\n</code></pre> <p>Bump beta-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_beta()\nValueError: Cannot bump from release to beta pre-release (use `dent_beta`)\n&gt;&gt;&gt; PEP440Version(\"1b0\").bump_beta()\n&lt;Version('1b1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b0\").bump_beta()\n&lt;Version('1b1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b0.post0\").bump_beta()\n&lt;Version('1b1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, bumped beta pre-release and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_beta(self) -&gt; PEP440Version:\n    \"\"\"Bump beta-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_beta()\n        ValueError: Cannot bump from release to beta pre-release (use `dent_beta`)\n        &gt;&gt;&gt; PEP440Version(\"1b0\").bump_beta()\n        &lt;Version('1b1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b0\").bump_beta()\n        &lt;Version('1b1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b0.post0\").bump_beta()\n        &lt;Version('1b1')&gt;\n\n    Returns:\n        Version with same epoch, same release, bumped beta pre-release and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_pre(\"b\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_candidate","title":"bump_candidate","text":"<pre><code>bump_candidate() -&gt; PEP440Version\n</code></pre> <p>Bump candidate release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_candidate()\nValueError: Cannot bump from release to candidate pre-release (use `dent_candidate`)\n&gt;&gt;&gt; PEP440Version(\"1c0\").bump_candidate()\n&lt;Version('1rc1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1c0\").bump_candidate()\n&lt;Version('1rc1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1c0.post0\").bump_candidate()\n&lt;Version('1rc1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, bumped candidate pre-release and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_candidate(self) -&gt; PEP440Version:\n    \"\"\"Bump candidate release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_candidate()\n        ValueError: Cannot bump from release to candidate pre-release (use `dent_candidate`)\n        &gt;&gt;&gt; PEP440Version(\"1c0\").bump_candidate()\n        &lt;Version('1rc1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1c0\").bump_candidate()\n        &lt;Version('1rc1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1c0.post0\").bump_candidate()\n        &lt;Version('1rc1')&gt;\n\n    Returns:\n        Version with same epoch, same release, bumped candidate pre-release and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_pre(\"rc\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_dev","title":"bump_dev","text":"<pre><code>bump_dev() -&gt; PEP440Version\n</code></pre> <p>Bump dev-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_dev()\nValueError: Cannot bump from release to dev-release (use `dent_dev`)\n&gt;&gt;&gt; PEP440Version(\"1a0\").bump_dev()\nValueError: Cannot bump from alpha to dev-release (use `dent_dev`)\n&gt;&gt;&gt; PEP440Version(\"1b1\").bump_dev()\nValueError: Cannot bump from beta to dev-release (use `dent_dev`)\n&gt;&gt;&gt; PEP440Version(\"1rc2\").bump_dev()\nValueError: Cannot bump from candidate to dev-release (use `dent_dev`)\n&gt;&gt;&gt; PEP440Version(\"1.post0\").bump_dev()\nValueError: Cannot bump from post to dev-release (use `dent_dev`)\n&gt;&gt;&gt; PEP440Version(\"1a0.dev1\").bump_dev()\n&lt;Version('1a0.dev2')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, same pre-release, same post-release and bumped dev-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_dev(self) -&gt; PEP440Version:\n    \"\"\"Bump dev-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_dev()\n        ValueError: Cannot bump from release to dev-release (use `dent_dev`)\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_dev()\n        ValueError: Cannot bump from alpha to dev-release (use `dent_dev`)\n        &gt;&gt;&gt; PEP440Version(\"1b1\").bump_dev()\n        ValueError: Cannot bump from beta to dev-release (use `dent_dev`)\n        &gt;&gt;&gt; PEP440Version(\"1rc2\").bump_dev()\n        ValueError: Cannot bump from candidate to dev-release (use `dent_dev`)\n        &gt;&gt;&gt; PEP440Version(\"1.post0\").bump_dev()\n        ValueError: Cannot bump from post to dev-release (use `dent_dev`)\n        &gt;&gt;&gt; PEP440Version(\"1a0.dev1\").bump_dev()\n        &lt;Version('1a0.dev2')&gt;\n\n    Returns:\n        Version with same epoch, same release, same pre-release, same post-release and bumped dev-release.\n    \"\"\"\n    if self.dev is None:\n        if self.post is not None:\n            kind = \"p\"\n        elif self.pre is not None:\n            kind = self.pre[0]\n        else:\n            kind = \"z\"\n        raise ValueError(f\"Cannot bump from {_release_kind.get(kind, 'release')} to dev-release (use `dent_dev`)\")\n    return PEP440Version.from_parts(\n        epoch=self.epoch,\n        release=self.release,\n        pre=self.pre,\n        post=self.post,\n        dev=self.dev + 1,\n    )\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_epoch","title":"bump_epoch","text":"<pre><code>bump_epoch() -&gt; PEP440Version\n</code></pre> <p>Bump epoch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1.0\").bump_epoch()\n&lt;Version('1!1.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"0!1.0\").bump_epoch()\n&lt;Version('1!1.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1!1.0\").bump_epoch()\n&lt;Version('2!1.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.0a2.post3\").bump_epoch()\n&lt;Version('2!1.0')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with bumped epoch, same release, and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_epoch(self) -&gt; PEP440Version:\n    \"\"\"Bump epoch.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1.0\").bump_epoch()\n        &lt;Version('1!1.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"0!1.0\").bump_epoch()\n        &lt;Version('1!1.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1!1.0\").bump_epoch()\n        &lt;Version('2!1.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.0a2.post3\").bump_epoch()\n        &lt;Version('2!1.0')&gt;\n\n    Returns:\n        Version with bumped epoch, same release, and the right parts reset to 0 or nothing.\n    \"\"\"\n    return PEP440Version.from_parts(epoch=self.epoch + 1, release=self.release)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_major","title":"bump_major","text":"<pre><code>bump_major(*, trim: bool = False) -&gt; PEP440Version\n</code></pre> <p>Bump major.</p> <p>Parameters:</p> <ul> <li> <code>trim</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to trim all zeroes on the right after bumping.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_major()\n&lt;Version('2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1\").bump_major()\n&lt;Version('2.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_major()\n&lt;Version('2.0.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_major(trim=True)\n&lt;Version('2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_major()\n&lt;Version('2')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, bumped major and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_major(self, *, trim: bool = False) -&gt; PEP440Version:\n    \"\"\"Bump major.\n\n    Parameters:\n        trim: Whether to trim all zeroes on the right after bumping.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_major()\n        &lt;Version('2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1\").bump_major()\n        &lt;Version('2.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_major()\n        &lt;Version('2.0.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_major(trim=True)\n        &lt;Version('2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_major()\n        &lt;Version('2')&gt;\n\n    Returns:\n        Version with same epoch, bumped major and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_release(level=0, trim=trim)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_micro","title":"bump_micro","text":"<pre><code>bump_micro(*, trim: bool = False) -&gt; PEP440Version\n</code></pre> <p>Bump micro.</p> <p>Parameters:</p> <ul> <li> <code>trim</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to trim all zeroes on the right after bumping.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_micro()\n&lt;Version('1.0.1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1\").bump_micro()\n&lt;Version('1.1.1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_micro()\n&lt;Version('1.1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_micro()\n&lt;Version('1.1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1.1\").bump_micro()\n&lt;Version('1.1.2.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1.1\").bump_micro(trim=True)\n&lt;Version('1.1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_micro()\n&lt;Version('1.0.1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same major, same minor, bumped micro and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_micro(self, *, trim: bool = False) -&gt; PEP440Version:\n    \"\"\"Bump micro.\n\n    Parameters:\n        trim: Whether to trim all zeroes on the right after bumping.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_micro()\n        &lt;Version('1.0.1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1\").bump_micro()\n        &lt;Version('1.1.1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_micro()\n        &lt;Version('1.1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_micro()\n        &lt;Version('1.1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1.1\").bump_micro()\n        &lt;Version('1.1.2.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1.1\").bump_micro(trim=True)\n        &lt;Version('1.1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_micro()\n        &lt;Version('1.0.1')&gt;\n\n    Returns:\n        Version with same epoch, same major, same minor, bumped micro and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_release(level=2, trim=trim)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_minor","title":"bump_minor","text":"<pre><code>bump_minor(*, trim: bool = False) -&gt; PEP440Version\n</code></pre> <p>Bump minor.</p> <p>Parameters:</p> <ul> <li> <code>trim</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to trim all zeroes on the right after bumping.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_minor()\n&lt;Version('1.1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1\").bump_minor()\n&lt;Version('1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_minor()\n&lt;Version('1.2.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_minor(trim=True)\n&lt;Version('1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_minor()\n&lt;Version('1.1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same major, bumped minor and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_minor(self, *, trim: bool = False) -&gt; PEP440Version:\n    \"\"\"Bump minor.\n\n    Parameters:\n        trim: Whether to trim all zeroes on the right after bumping.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_minor()\n        &lt;Version('1.1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1\").bump_minor()\n        &lt;Version('1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_minor()\n        &lt;Version('1.2.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_minor(trim=True)\n        &lt;Version('1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_minor()\n        &lt;Version('1.1')&gt;\n\n    Returns:\n        Version with same epoch, same major, bumped minor and the right parts reset to 0 or nothing.\n    \"\"\"\n    return self.bump_release(level=1, trim=trim)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_post","title":"bump_post","text":"<pre><code>bump_post() -&gt; PEP440Version\n</code></pre> <p>Bump post-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_post()\n&lt;Version('1.post0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.post0\").bump_post()\n&lt;Version('1.post1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_post()\n&lt;Version('1a0.post1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.post0.dev1\").bump_post()\n&lt;Version('1.post1')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, same pre-release, bumped post-release and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_post(self) -&gt; PEP440Version:\n    \"\"\"Bump post-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_post()\n        &lt;Version('1.post0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.post0\").bump_post()\n        &lt;Version('1.post1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_post()\n        &lt;Version('1a0.post1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.post0.dev1\").bump_post()\n        &lt;Version('1.post1')&gt;\n\n    Returns:\n        Version with same epoch, same release, same pre-release, bumped post-release and the right parts reset to 0 or nothing.\n    \"\"\"\n    post = 0 if self.post is None else self.post + 1\n    return PEP440Version.from_parts(epoch=self.epoch, release=self.release, pre=self.pre, post=post)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_pre","title":"bump_pre","text":"<pre><code>bump_pre(\n    pre: Literal[\"a\", \"b\", \"c\", \"rc\"] | None = None\n) -&gt; PEP440Version\n</code></pre> <p>Bump pre-release.</p> <p>Parameters:</p> <ul> <li> <code>pre</code>             (<code>Literal['a', 'b', 'c', 'rc'] | None</code>, default:                 <code>None</code> )         \u2013          <p>Kind of pre-release to bump.</p> <ul> <li>a means alpha</li> <li>b means beta</li> <li>c or rc means (release) candidate</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_pre()\nValueError: Cannot bump from release to alpha pre-release (use `dent_pre`)\n&gt;&gt;&gt; PEP440Version(\"1a0\").bump_pre()\n&lt;Version('1a1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").bump_pre(\"a\")\n&lt;Version('1a1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_pre()\n&lt;Version('1a1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"a\")\nValueError: Cannot bump from beta to alpha pre-release (use `dent_alpha`)\n&gt;&gt;&gt; PEP440Version(\"1c2\").bump_pre(\"a\")\nValueError: Cannot bump from candidate to alpha pre-release (use `dent_alpha`)\n</code></pre> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_pre(\"b\")\nValueError: Cannot bump from release to beta pre-release (use `dent_beta`)\n&gt;&gt;&gt; PEP440Version(\"1a2\").bump_pre(\"b\")\n&lt;Version('1b0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"b\")\n&lt;Version('1b3')&gt;\n&gt;&gt;&gt; PEP440Version(\"1c2\").bump_pre(\"b\")\nValueError: Cannot bump from candidate to beta pre-release (use `dent_beta`)\n</code></pre> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_pre(\"c\")\nValueError: Cannot bump from release to candidate pre-release (use `dent_candidate`)\n&gt;&gt;&gt; PEP440Version(\"1a2\").bump_pre(\"c\")\n&lt;Version('1rc0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"rc\")\n&lt;Version('1rc0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1rc2\").bump_pre(\"c\")\n&lt;Version('1rc3')&gt;\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, same release, bumped pre-release and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_pre(self, pre: Literal[\"a\", \"b\", \"c\", \"rc\"] | None = None) -&gt; PEP440Version:\n    \"\"\"Bump pre-release.\n\n    Parameters:\n        pre: Kind of pre-release to bump.\n\n            - a means alpha\n            - b means beta\n            - c or rc means (release) candidate\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_pre()\n        ValueError: Cannot bump from release to alpha pre-release (use `dent_pre`)\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_pre()\n        &lt;Version('1a1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_pre(\"a\")\n        &lt;Version('1a1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0.post0\").bump_pre()\n        &lt;Version('1a1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"a\")\n        ValueError: Cannot bump from beta to alpha pre-release (use `dent_alpha`)\n        &gt;&gt;&gt; PEP440Version(\"1c2\").bump_pre(\"a\")\n        ValueError: Cannot bump from candidate to alpha pre-release (use `dent_alpha`)\n\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_pre(\"b\")\n        ValueError: Cannot bump from release to beta pre-release (use `dent_beta`)\n        &gt;&gt;&gt; PEP440Version(\"1a2\").bump_pre(\"b\")\n        &lt;Version('1b0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"b\")\n        &lt;Version('1b3')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1c2\").bump_pre(\"b\")\n        ValueError: Cannot bump from candidate to beta pre-release (use `dent_beta`)\n\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_pre(\"c\")\n        ValueError: Cannot bump from release to candidate pre-release (use `dent_candidate`)\n        &gt;&gt;&gt; PEP440Version(\"1a2\").bump_pre(\"c\")\n        &lt;Version('1rc0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b2\").bump_pre(\"rc\")\n        &lt;Version('1rc0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1rc2\").bump_pre(\"c\")\n        &lt;Version('1rc3')&gt;\n\n    Returns:\n        Version with same epoch, same release, bumped pre-release and the right parts reset to 0 or nothing.\n    \"\"\"\n    if self.pre is None:\n        kind = _release_kind.get(pre, \"\")  # type: ignore[arg-type]\n        raise ValueError(\n            f\"Cannot bump from release to {kind + ' ' if kind else ''}pre-release (use `dent_{kind or 'pre'}`)\",\n        )\n    current_pre: Literal[\"a\", \"b\", \"c\", \"rc\"]\n    current_pre, number = self.pre  # type: ignore[assignment]\n    if pre is None:\n        pre = current_pre\n    if pre == current_pre:\n        number += 1\n    elif current_pre &lt; pre:\n        number = 0\n    else:\n        raise ValueError(\n            f\"Cannot bump from {_release_kind.get(current_pre, 'release')} to {_release_kind[pre]} pre-release (use `dent_{_release_kind[pre]}`)\",\n        )\n    return PEP440Version.from_parts(epoch=self.epoch, release=self.release, pre=(pre, number))\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.bump_release","title":"bump_release","text":"<pre><code>bump_release(\n    level: int | None = None, *, trim: bool = False\n) -&gt; PEP440Version\n</code></pre> <p>Bump given release level.</p> <p>Parameters:</p> <ul> <li> <code>level</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The release level to bump.</p> <ul> <li>0 means major</li> <li>1 means minor</li> <li>2 means micro (patch)</li> <li>3+ don't have names</li> <li>None means move from pre-release to release (unchanged)</li> </ul> </li> <li> <code>trim</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to trim all zeroes on the right after bumping.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_release(0)\n&lt;Version('2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1\").bump_release(0)\n&lt;Version('2.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(0)\n&lt;Version('2.0.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(0, trim=True)\n&lt;Version('2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_release(0)\n&lt;Version('2')&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").bump_release(1)\n&lt;Version('1.1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1\").bump_release(1)\n&lt;Version('1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(1)\n&lt;Version('1.2.0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(1, trim=True)\n&lt;Version('1.2')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_release(1)\n&lt;Version('1.1')&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; PEP440Version(\"1a0\").bump_release()\n&lt;Version('1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b1\").bump_release()\n&lt;Version('1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1rc2\").bump_release()\n&lt;Version('1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a2.dev0\").bump_release()\n&lt;Version('1')&gt;\n&gt;&gt;&gt; PEP440Version(\"1post0\").bump_release()\nValueError: Cannot bump from post-release to release\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch, bumped release level, and the right parts reset to 0 or nothing.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_release(self, level: int | None = None, *, trim: bool = False) -&gt; PEP440Version:\n    \"\"\"Bump given release level.\n\n    Parameters:\n        level: The release level to bump.\n\n            - 0 means major\n            - 1 means minor\n            - 2 means micro (patch)\n            - 3+ don't have names\n            - None means move from pre-release to release (unchanged)\n        trim: Whether to trim all zeroes on the right after bumping.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_release(0)\n        &lt;Version('2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1\").bump_release(0)\n        &lt;Version('2.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(0)\n        &lt;Version('2.0.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(0, trim=True)\n        &lt;Version('2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_release(0)\n        &lt;Version('2')&gt;\n\n        &gt;&gt;&gt; PEP440Version(\"1\").bump_release(1)\n        &lt;Version('1.1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1\").bump_release(1)\n        &lt;Version('1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(1)\n        &lt;Version('1.2.0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.1.1\").bump_release(1, trim=True)\n        &lt;Version('1.2')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.post3\").bump_release(1)\n        &lt;Version('1.1')&gt;\n\n        &gt;&gt;&gt; PEP440Version(\"1a0\").bump_release()\n        &lt;Version('1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b1\").bump_release()\n        &lt;Version('1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1rc2\").bump_release()\n        &lt;Version('1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a2.dev0\").bump_release()\n        &lt;Version('1')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1post0\").bump_release()\n        ValueError: Cannot bump from post-release to release\n\n    Returns:\n        Version with same epoch, bumped release level, and the right parts reset to 0 or nothing.\n    \"\"\"\n    release = list(self.release)\n\n    # When level is not specified, user wants to bump the version\n    # as a \"release\", going out of alpha/beta/candidate phase.\n    # So we simply keep the release part as it is, optionally trimming it.\n    if level is None:\n        # However if this is a post-release, this is an error:\n        # we can't bump from a post-release to the same, regular release.\n        if self.post is not None:\n            raise ValueError(\"Cannot bump from post-release to release\")\n        if trim:\n            while release[-1] == 0:\n                release.pop()\n\n    # When level is specified, we bump the specified level.\n    # If the given level is higher that the number of release parts,\n    # we insert the missing parts as 0.\n    else:\n        try:\n            release[level] += 1\n        except IndexError:\n            while len(release) &lt; level:\n                release.append(0)\n            release.append(1)\n        if trim:\n            release = release[: level + 1]\n        else:\n            for index in range(level + 1, len(release)):\n                release[index] = 0\n\n    # We rebuild the version with same epoch, updated release,\n    # and pre/post/dev parts dropped.\n    return PEP440Version.from_parts(epoch=self.epoch, release=tuple(release))\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.dent_alpha","title":"dent_alpha","text":"<pre><code>dent_alpha() -&gt; PEP440Version\n</code></pre> <p>Dent to alpha-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").dent_alpha()\n&lt;Version('1a0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").dent_alpha()\nValueError: Cannot dent alpha pre-releases\n&gt;&gt;&gt; PEP440Version(\"1b0\").dent_alpha()\nValueError: Cannot dent beta pre-releases\n&gt;&gt;&gt; PEP440Version(\"1rc0\").dent_alpha()\nValueError: Cannot dent candidate pre-releases\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch and release dented to alpha pre-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def dent_alpha(self) -&gt; PEP440Version:\n    \"\"\"Dent to alpha-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_alpha()\n        &lt;Version('1a0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").dent_alpha()\n        ValueError: Cannot dent alpha pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1b0\").dent_alpha()\n        ValueError: Cannot dent beta pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1rc0\").dent_alpha()\n        ValueError: Cannot dent candidate pre-releases\n\n    Returns:\n        Version with same epoch and release dented to alpha pre-release.\n    \"\"\"\n    return self.dent_pre(\"a\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.dent_beta","title":"dent_beta","text":"<pre><code>dent_beta() -&gt; PEP440Version\n</code></pre> <p>Dent to beta-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").dent_beta()\n&lt;Version('1b0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").dent_beta()\nValueError: Cannot dent alpha pre-releases\n&gt;&gt;&gt; PEP440Version(\"1b0\").dent_beta()\nValueError: Cannot dent beta pre-releases\n&gt;&gt;&gt; PEP440Version(\"1rc0\").dent_beta()\nValueError: Cannot dent candidate pre-releases\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch and release dented to beta pre-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def dent_beta(self) -&gt; PEP440Version:\n    \"\"\"Dent to beta-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_beta()\n        &lt;Version('1b0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").dent_beta()\n        ValueError: Cannot dent alpha pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1b0\").dent_beta()\n        ValueError: Cannot dent beta pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1rc0\").dent_beta()\n        ValueError: Cannot dent candidate pre-releases\n\n    Returns:\n        Version with same epoch and release dented to beta pre-release.\n    \"\"\"\n    return self.dent_pre(\"b\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.dent_candidate","title":"dent_candidate","text":"<pre><code>dent_candidate() -&gt; PEP440Version\n</code></pre> <p>Dent to candidate release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").dent_candidate()\n&lt;Version('1rc0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").dent_candidate()\nValueError: Cannot dent alpha pre-releases\n&gt;&gt;&gt; PEP440Version(\"1b0\").dent_candidate()\nValueError: Cannot dent beta pre-releases\n&gt;&gt;&gt; PEP440Version(\"1rc0\").dent_candidate()\nValueError: Cannot dent candidate pre-releases\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch and release dented to candidate pre-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def dent_candidate(self) -&gt; PEP440Version:\n    \"\"\"Dent to candidate release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_candidate()\n        &lt;Version('1rc0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").dent_candidate()\n        ValueError: Cannot dent alpha pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1b0\").dent_candidate()\n        ValueError: Cannot dent beta pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1rc0\").dent_candidate()\n        ValueError: Cannot dent candidate pre-releases\n\n    Returns:\n        Version with same epoch and release dented to candidate pre-release.\n    \"\"\"\n    return self.dent_pre(\"rc\")\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.dent_dev","title":"dent_dev","text":"<pre><code>dent_dev() -&gt; PEP440Version\n</code></pre> <p>Dent to dev-release.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").dent_dev()\n&lt;Version('1.dev0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").dent_dev()\n&lt;Version('1a0.dev0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b1\").dent_dev()\n&lt;Version('1b1.dev0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1c2\").dent_dev()\n&lt;Version('1rc2.dev0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1.post0\").dent_dev()\n&lt;Version('1.post0.dev0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0.dev1\").dent_dev()\nValueError: Cannot dent dev-releases\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch and release dented to dev-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def dent_dev(self) -&gt; PEP440Version:\n    \"\"\"Dent to dev-release.\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_dev()\n        &lt;Version('1.dev0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").dent_dev()\n        &lt;Version('1a0.dev0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b1\").dent_dev()\n        &lt;Version('1b1.dev0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1c2\").dent_dev()\n        &lt;Version('1rc2.dev0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1.post0\").dent_dev()\n        &lt;Version('1.post0.dev0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0.dev1\").dent_dev()\n        ValueError: Cannot dent dev-releases\n\n    Returns:\n        Version with same epoch and release dented to dev-release.\n    \"\"\"\n    if self.dev is not None:\n        raise ValueError(\"Cannot dent dev-releases\")\n    return PEP440Version.from_parts(epoch=self.epoch, release=self.release, pre=self.pre, post=self.post, dev=0)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.dent_pre","title":"dent_pre","text":"<pre><code>dent_pre(\n    pre: Literal[\"a\", \"b\", \"c\", \"rc\"] | None = None\n) -&gt; PEP440Version\n</code></pre> <p>Dent to pre-release.</p> <p>This method dents a release down to an alpha, beta or candidate pre-release.</p> <p>Parameters:</p> <ul> <li> <code>pre</code>             (<code>Literal['a', 'b', 'c', 'rc'] | None</code>, default:                 <code>None</code> )         \u2013          <p>Kind of pre-release to bump.</p> <ul> <li>a means alpha</li> <li>b means beta</li> <li>c or rc means (release) candidate</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PEP440Version(\"1\").dent_pre()\n&lt;Version('1a0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"a\")\n&lt;Version('1a0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1a0\").dent_pre(\"a\")\nValueError: Cannot dent alpha pre-releases\n&gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"b\")\n&lt;Version('1b0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1b0\").dent_pre(\"b\")\nValueError: Cannot dent beta pre-releases\n&gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"c\")\n&lt;Version('1rc0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"rc\")\n&lt;Version('1rc0')&gt;\n&gt;&gt;&gt; PEP440Version(\"1rc0\").dent_pre(\"c\")\nValueError: Cannot dent candidate pre-releases\n</code></pre> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>Version with same epoch and release dented to pre-release.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def dent_pre(self, pre: Literal[\"a\", \"b\", \"c\", \"rc\"] | None = None) -&gt; PEP440Version:\n    \"\"\"Dent to pre-release.\n\n    This method dents a release down to an alpha, beta or candidate pre-release.\n\n    Parameters:\n        pre: Kind of pre-release to bump.\n\n            - a means alpha\n            - b means beta\n            - c or rc means (release) candidate\n\n    Examples:\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_pre()\n        &lt;Version('1a0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"a\")\n        &lt;Version('1a0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1a0\").dent_pre(\"a\")\n        ValueError: Cannot dent alpha pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"b\")\n        &lt;Version('1b0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1b0\").dent_pre(\"b\")\n        ValueError: Cannot dent beta pre-releases\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"c\")\n        &lt;Version('1rc0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1\").dent_pre(\"rc\")\n        &lt;Version('1rc0')&gt;\n        &gt;&gt;&gt; PEP440Version(\"1rc0\").dent_pre(\"c\")\n        ValueError: Cannot dent candidate pre-releases\n\n    Returns:\n        Version with same epoch and release dented to pre-release.\n    \"\"\"\n    if self.pre is not None:\n        raise ValueError(f\"Cannot dent {_release_kind[self.pre[0]]} pre-releases\")\n    if pre is None:\n        pre = \"a\"\n    return PEP440Version.from_parts(epoch=self.epoch, release=self.release, pre=(pre, 0))\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.PEP440Version.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\n    epoch: int | None = None,\n    release: tuple[int, ...] | None = None,\n    pre: tuple[str, int] | None = None,\n    post: int | None = None,\n    dev: int | None = None,\n) -&gt; PEP440Version\n</code></pre> <p>Build a version from its parts.</p> <p>Parameters:</p> <ul> <li> <code>epoch</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Version's epoch number.</p> </li> <li> <code>release</code>             (<code>tuple[int, ...] | None</code>, default:                 <code>None</code> )         \u2013          <p>Version's release numbers.</p> </li> <li> <code>pre</code>             (<code>tuple[str, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Version's prerelease kind and number.</p> </li> <li> <code>post</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Version's post number.</p> </li> <li> <code>dev</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Version's dev number.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PEP440Version</code>         \u2013          <p>A PEP 440 version.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>@classmethod\ndef from_parts(\n    cls,\n    epoch: int | None = None,\n    release: tuple[int, ...] | None = None,\n    pre: tuple[str, int] | None = None,\n    post: int | None = None,\n    dev: int | None = None,\n) -&gt; PEP440Version:\n    \"\"\"Build a version from its parts.\n\n    Parameters:\n        epoch: Version's epoch number.\n        release: Version's release numbers.\n        pre: Version's prerelease kind and number.\n        post: Version's post number.\n        dev: Version's dev number.\n\n    Returns:\n        A PEP 440 version.\n    \"\"\"\n    # Since the original class only allows instantiating a version\n    # by passing a string, we first create a dummy version \"1\"\n    # and then re-assign its internal `_version` with the real one.\n    version = cls(\"1\")\n    version._version = packaging_version._Version(\n        epoch=epoch or 0,\n        release=release or (),\n        pre=pre,\n        post=None if post is None else (\"post\", post),\n        dev=None if dev is None else (\"dev\", dev),\n        local=None,\n    )\n\n    # We also have to update its `_key` attribute.\n    # This is a hack and I would prefer that such functionality\n    # is exposed directly in the original class.\n    version._key = packaging_version._cmpkey(\n        version._version.epoch,\n        version._version.release,\n        version._version.pre,\n        version._version.post,\n        version._version.dev,\n        version._version.local,\n    )\n\n    return version\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.ParsedVersion","title":"ParsedVersion","text":"<p>             Bases: <code>Protocol</code></p> <p>Base class for versioning schemes.</p>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.SemVerBumper","title":"SemVerBumper","text":"<pre><code>SemVerBumper(strategies: tuple[str, ...])\n</code></pre> <p>             Bases: <code>VersionBumper</code></p> <p>SemVer version bumper.</p> <p>Parameters:</p> <ul> <li> <code>strategies</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The supported bumping strategies.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def __init__(self, strategies: tuple[str, ...]) -&gt; None:\n    \"\"\"Initialize the bumper.\n\n    Parameters:\n        strategies: The supported bumping strategies.\n    \"\"\"\n    self.strategies = strategies\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.SemVerVersion","title":"SemVerVersion","text":"<p>             Bases: <code>Version</code>, <code>ParsedVersion</code></p> <p>SemVer version.</p> <p>Methods:</p> <ul> <li> <code>bump_release</code>           \u2013            <p>Bump from a pre-release to the same, regular release.</p> </li> </ul>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.SemVerVersion.bump_release","title":"bump_release","text":"<pre><code>bump_release() -&gt; SemVerVersion\n</code></pre> <p>Bump from a pre-release to the same, regular release.</p> <p>Returns:</p> <ul> <li> <code>SemVerVersion</code>         \u2013          <p>The same version, without pre-release or build metadata.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def bump_release(self) -&gt; SemVerVersion:\n    \"\"\"Bump from a pre-release to the same, regular release.\n\n    Returns:\n        The same version, without pre-release or build metadata.\n    \"\"\"\n    return SemVerVersion(self.major, self.minor, self.patch)\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.VersionBumper","title":"VersionBumper","text":"<pre><code>VersionBumper(strategies: tuple[str, ...])\n</code></pre> <p>Base class for version bumpers.</p> <p>Parameters:</p> <ul> <li> <code>strategies</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The supported bumping strategies.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def __init__(self, strategies: tuple[str, ...]) -&gt; None:\n    \"\"\"Initialize the bumper.\n\n    Parameters:\n        strategies: The supported bumping strategies.\n    \"\"\"\n    self.strategies = strategies\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.parse_pep440","title":"parse_pep440","text":"<pre><code>parse_pep440(version: str) -&gt; tuple[PEP440Version, str]\n</code></pre> <p>Parse a PEP version.</p> <p>Returns:</p> <ul> <li> <code>tuple[PEP440Version, str]</code>         \u2013          <p>A PEP 440 version instance with useful methods.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def parse_pep440(version: str) -&gt; tuple[PEP440Version, str]:\n    \"\"\"Parse a PEP version.\n\n    Returns:\n        A PEP 440 version instance with useful methods.\n    \"\"\"\n    version, prefix = version_prefix(version)\n    return PEP440Version(version), prefix\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.parse_semver","title":"parse_semver","text":"<pre><code>parse_semver(version: str) -&gt; tuple[SemVerVersion, str]\n</code></pre> <p>Parse a SemVer version.</p> <p>Returns:</p> <ul> <li> <code>tuple[SemVerVersion, str]</code>         \u2013          <p>A semver version instance with useful methods.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def parse_semver(version: str) -&gt; tuple[SemVerVersion, str]:\n    \"\"\"Parse a SemVer version.\n\n    Returns:\n        A semver version instance with useful methods.\n    \"\"\"\n    version, prefix = version_prefix(version)\n    return SemVerVersion.parse(version), prefix\n</code></pre>"},{"location":"reference/git_changelog/versioning/#git_changelog.versioning.version_prefix","title":"version_prefix","text":"<pre><code>version_prefix(version: str) -&gt; tuple[str, str]\n</code></pre> <p>Return a version and its optional <code>v</code> prefix.</p> <p>Parameters:</p> <ul> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>The full version.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>version</code> (            <code>str</code> )        \u2013          <p>The version without its prefix.</p> </li> <li> <code>prefix</code> (            <code>str</code> )        \u2013          <p>The version prefix.</p> </li> </ul> Source code in <code>src/git_changelog/versioning.py</code> <pre><code>def version_prefix(version: str) -&gt; tuple[str, str]:\n    \"\"\"Return a version and its optional `v` prefix.\n\n    Arguments:\n        version: The full version.\n\n    Returns:\n        version: The version without its prefix.\n        prefix: The version prefix.\n    \"\"\"\n    prefix = \"\"\n    if version[0] == \"v\":\n        prefix = \"v\"\n        version = version[1:]\n    return version, prefix\n</code></pre>"},{"location":"reference/git_changelog/templates/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> templates","text":""},{"location":"reference/git_changelog/templates/#git_changelog.templates","title":"templates","text":"<p>The subpackage containing the builtin templates.</p> <p>Functions:</p> <ul> <li> <code>configure_env</code>           \u2013            <p>Configure the Jinja environment.</p> </li> <li> <code>get_custom_template</code>           \u2013            <p>Get a custom template instance.</p> </li> <li> <code>get_template</code>           \u2013            <p>Get a builtin template instance.</p> </li> </ul>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.configure_env","title":"configure_env","text":"<pre><code>configure_env(env: Environment) -&gt; None\n</code></pre> <p>Configure the Jinja environment.</p> <p>Parameters:</p> <ul> <li> <code>env</code>             (<code>Environment</code>)         \u2013          <p>The environment to configure.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def configure_env(env: Environment) -&gt; None:\n    \"\"\"Configure the Jinja environment.\n\n    Parameters:\n        env: The environment to configure.\n    \"\"\"\n    env.filters.update({\"is_url\": _filter_is_url})\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_custom_template","title":"get_custom_template","text":"<pre><code>get_custom_template(path: str | Path) -&gt; Template\n</code></pre> <p>Get a custom template instance.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the custom template.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Template</code>         \u2013          <p>The Jinja template.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def get_custom_template(path: str | Path) -&gt; Template:\n    \"\"\"Get a custom template instance.\n\n    Arguments:\n        path: Path to the custom template.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(Path(path).read_text())\n</code></pre>"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_template","title":"get_template","text":"<pre><code>get_template(name: str) -&gt; Template\n</code></pre> <p>Get a builtin template instance.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The template name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Template</code>         \u2013          <p>The Jinja template.</p> </li> </ul> Source code in <code>src/git_changelog/templates/__init__.py</code> <pre><code>def get_template(name: str) -&gt; Template:\n    \"\"\"Get a builtin template instance.\n\n    Arguments:\n        name: The template name.\n\n    Returns:\n        The Jinja template.\n    \"\"\"\n    return JINJA_ENV.from_string(TEMPLATES_PATH.joinpath(f\"{name}.md.jinja\").read_text())\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}