{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"git-changelog \u00a4 Automatic Changelog generator using Jinja2 templates. From git logs to change logs. Features \u00a4 Jinja2 templates! You get full control over the rendering. Built-in Keep a Changelog and Angular templates (also see Conventional Changelog ). Commit styles/conventions parsing. Built-in Angular , Conventional Commit , Atom and basic styles. Git service/provider agnostic, plus references parsing (issues, commits, etc.). Built-in GitHub and Gitlab support. Understands Semantic Versioning : major/minor/patch for versions and commits. Guesses next version based on last commits. Todo: Plugin architecture , to support more commit styles and git services. Template context injection , to furthermore customize how your changelog will be rendered. Easy access to \"Breaking Changes\" in the templates. Update changelog in-place , paired with commits/dates/versions range limitation ability . Installation \u00a4 With pip : pip install git-changelog With pipx : python3.7 -m pip install --user pipx pipx install git-changelog Usage (command-line) \u00a4 usage: git-changelog [-h] [-o OUTPUT] [-s {angular,atom,basic}] [-t {angular,keepachangelog}] [-v] REPOSITORY Command line tool for git-changelog Python package. positional arguments: REPOSITORY The repository path, relative or absolute. optional arguments: -h, --help Show this help message and exit. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -s {angular,atom,basic}, --style {angular,atom,basic} The commit style to match against. -t {angular,keepachangelog}, --template {angular,keepachangelog} The Jinja2 template to use. Prefix with \"path:\" to specify the path to a directory containing a file named \"changelog.md\". -v, --version Show the current version of the program and exit.","title":"Overview"},{"location":"#git-changelog","text":"Automatic Changelog generator using Jinja2 templates. From git logs to change logs.","title":"git-changelog"},{"location":"#features","text":"Jinja2 templates! You get full control over the rendering. Built-in Keep a Changelog and Angular templates (also see Conventional Changelog ). Commit styles/conventions parsing. Built-in Angular , Conventional Commit , Atom and basic styles. Git service/provider agnostic, plus references parsing (issues, commits, etc.). Built-in GitHub and Gitlab support. Understands Semantic Versioning : major/minor/patch for versions and commits. Guesses next version based on last commits. Todo: Plugin architecture , to support more commit styles and git services. Template context injection , to furthermore customize how your changelog will be rendered. Easy access to \"Breaking Changes\" in the templates. Update changelog in-place , paired with commits/dates/versions range limitation ability .","title":"Features"},{"location":"#installation","text":"With pip : pip install git-changelog With pipx : python3.7 -m pip install --user pipx pipx install git-changelog","title":"Installation"},{"location":"#usage-command-line","text":"usage: git-changelog [-h] [-o OUTPUT] [-s {angular,atom,basic}] [-t {angular,keepachangelog}] [-v] REPOSITORY Command line tool for git-changelog Python package. positional arguments: REPOSITORY The repository path, relative or absolute. optional arguments: -h, --help Show this help message and exit. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -s {angular,atom,basic}, --style {angular,atom,basic} The commit style to match against. -t {angular,keepachangelog}, --template {angular,keepachangelog} The Jinja2 template to use. Prefix with \"path:\" to specify the path to a directory containing a file named \"changelog.md\". -v, --version Show the current version of the program and exit.","title":"Usage (command-line)"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.6.0 - 2022-10-26 \u00a4 Compare with 0.5.0 Features \u00a4 Add GIT_CHANGELOG_REMOTE variable ( 9b9b3fc by Luk\u00e1\u0161 Zapletal). PR #35 0.5.0 - 2021-11-14 \u00a4 Compare with 0.4.2 Dependencies \u00a4 Accept Jinja2 3.x ( 9ef3259 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Allow to choose conventional style from CLI ( aafa779 by Ivan Gonzalez). PR #32 Add ConventionalCommit commit type ( 3becce8 by Kevin Squire). PR #30 Bug Fixes \u00a4 Properly bump semver version ( ecc7dd4 by Kevin Squire). References: #31 Fix typo in keepachangelog template ( fa9b434 by Alexander Schleifer). PR #28 Code Refactoring \u00a4 Use semver to bump version more reliably ( b68a565 by Timoth\u00e9e Mazzucotelli). 0.4.2 - 2021-01-06 \u00a4 Compare with 0.4.1 Bug Fixes \u00a4 Handle prerelease tags better ( 4bcc451 by Timoth\u00e9e Mazzucotelli). 0.4.1 - 2020-12-21 \u00a4 Compare with 0.4.0 Bug Fixes \u00a4 Fix wrong version being printed ( 0ec050f by Timoth\u00e9e Mazzucotelli). 0.4.0 - 2020-05-21 \u00a4 Compare with 0.3.0 Bug Fixes \u00a4 Use actual url for references ( 46a8790 by Timoth\u00e9e Mazzucotelli). Use style subject if possible ( 7f2c3ad by Timoth\u00e9e Mazzucotelli). Correctly handle nested subgroups for gitlab repos ( 8ca990b by Timoth\u00e9e Mazzucotelli). Fix bumping versions starting with \"v\" ( 44e7644 by Timoth\u00e9e Mazzucotelli). Code Refactoring \u00a4 Move styles into new commit module to avoid cyclic dependencies ( d90bd15 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Improve changelog rendering ( e9dd3f4 by Timoth\u00e9e Mazzucotelli). Use today's date for current version Move \"compare\" link below the heading (better table of contents in documentation) Improve \"compare\" links to handle first and current version Use selected commit types to render sections Add default commit types to render variable ( 173392a by Timoth\u00e9e Mazzucotelli). Always use today's date for unreleased version ( 1c34fa8 by Timoth\u00e9e Mazzucotelli). 0.3.0 - 2020-03-31 \u00a4 Compare with 0.2.0 Bug Fixes \u00a4 Fix is_minor method for version ( 6d08978 by Lo\u00efc Viennois). Fix parse_refs method for ProviderRefParser ( dc51589 by Lo\u00efc Viennois). Correctly detect major version, for both angular style and basic style ( 7385e19 by Lo\u00efc Viennois). Code Refactoring \u00a4 Add type hints to all classes and methods ( 95276ef by Lo\u00efc Viennois). Features \u00a4 Update template keepachangelog ( ce76ed6 ) by RainChen: Capitalize commit subject Show author name for each commit Sort commits by date Unique commit subjects 0.2.0 - 2019-11-24 \u00a4 Compare with 0.1.1 Drop support for Python < 3.6. Use poetry to manage the project! Fixed \u00a4 Fix detection of feature (is_minor) for angular style ( 4fbf0ee ). 0.1.1 - 2018-06-27 \u00a4 Compare with 0.1.0 Fixed \u00a4 Fix build with MANIFEST.in, add license file ( 013fb69 ). Misc \u00a4 Improve readability ( 5e590f6 ). 0.1.0 - 2018-06-27 \u00a4 Compare with first commit Added \u00a4 Add github/github regexes ( 584fd73 ). Fixed \u00a4 Fix patch bump ( 8470e69 ). Fix refs parsing ( 8c77cb7 ). Misc \u00a4 Continue packaging (#6) ( a29af2c ). Finish packaging (#6) ( e92b492 ). Implement reference parsing ( a9b4a89 ). Improve angular template, improve style/refs system ( 5b87d48 ). Initial commit ( 83845fe ). Package code (#6) ( 1219eaf ). Update changelog for version 0.1.0 ( 14edcaf ). Update changelog for version 0.1.0 ( 610633d ). Update changelog for version 0.1.0 ( 2eaaa2e ). Work in progress ( 27a60e8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#060-2022-10-26","text":"Compare with 0.5.0","title":"0.6.0 - 2022-10-26"},{"location":"changelog/#features","text":"Add GIT_CHANGELOG_REMOTE variable ( 9b9b3fc by Luk\u00e1\u0161 Zapletal). PR #35","title":"Features"},{"location":"changelog/#050-2021-11-14","text":"Compare with 0.4.2","title":"0.5.0 - 2021-11-14"},{"location":"changelog/#dependencies","text":"Accept Jinja2 3.x ( 9ef3259 by Timoth\u00e9e Mazzucotelli).","title":"Dependencies"},{"location":"changelog/#features_1","text":"Allow to choose conventional style from CLI ( aafa779 by Ivan Gonzalez). PR #32 Add ConventionalCommit commit type ( 3becce8 by Kevin Squire). PR #30","title":"Features"},{"location":"changelog/#bug-fixes","text":"Properly bump semver version ( ecc7dd4 by Kevin Squire). References: #31 Fix typo in keepachangelog template ( fa9b434 by Alexander Schleifer). PR #28","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Use semver to bump version more reliably ( b68a565 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#042-2021-01-06","text":"Compare with 0.4.1","title":"0.4.2 - 2021-01-06"},{"location":"changelog/#bug-fixes_1","text":"Handle prerelease tags better ( 4bcc451 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#041-2020-12-21","text":"Compare with 0.4.0","title":"0.4.1 - 2020-12-21"},{"location":"changelog/#bug-fixes_2","text":"Fix wrong version being printed ( 0ec050f by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#040-2020-05-21","text":"Compare with 0.3.0","title":"0.4.0 - 2020-05-21"},{"location":"changelog/#bug-fixes_3","text":"Use actual url for references ( 46a8790 by Timoth\u00e9e Mazzucotelli). Use style subject if possible ( 7f2c3ad by Timoth\u00e9e Mazzucotelli). Correctly handle nested subgroups for gitlab repos ( 8ca990b by Timoth\u00e9e Mazzucotelli). Fix bumping versions starting with \"v\" ( 44e7644 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Move styles into new commit module to avoid cyclic dependencies ( d90bd15 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_2","text":"Improve changelog rendering ( e9dd3f4 by Timoth\u00e9e Mazzucotelli). Use today's date for current version Move \"compare\" link below the heading (better table of contents in documentation) Improve \"compare\" links to handle first and current version Use selected commit types to render sections Add default commit types to render variable ( 173392a by Timoth\u00e9e Mazzucotelli). Always use today's date for unreleased version ( 1c34fa8 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#030-2020-03-31","text":"Compare with 0.2.0","title":"0.3.0 - 2020-03-31"},{"location":"changelog/#bug-fixes_4","text":"Fix is_minor method for version ( 6d08978 by Lo\u00efc Viennois). Fix parse_refs method for ProviderRefParser ( dc51589 by Lo\u00efc Viennois). Correctly detect major version, for both angular style and basic style ( 7385e19 by Lo\u00efc Viennois).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"Add type hints to all classes and methods ( 95276ef by Lo\u00efc Viennois).","title":"Code Refactoring"},{"location":"changelog/#features_3","text":"Update template keepachangelog ( ce76ed6 ) by RainChen: Capitalize commit subject Show author name for each commit Sort commits by date Unique commit subjects","title":"Features"},{"location":"changelog/#020-2019-11-24","text":"Compare with 0.1.1 Drop support for Python < 3.6. Use poetry to manage the project!","title":"0.2.0 - 2019-11-24"},{"location":"changelog/#fixed","text":"Fix detection of feature (is_minor) for angular style ( 4fbf0ee ).","title":"Fixed"},{"location":"changelog/#011-2018-06-27","text":"Compare with 0.1.0","title":"0.1.1 - 2018-06-27"},{"location":"changelog/#fixed_1","text":"Fix build with MANIFEST.in, add license file ( 013fb69 ).","title":"Fixed"},{"location":"changelog/#misc","text":"Improve readability ( 5e590f6 ).","title":"Misc"},{"location":"changelog/#010-2018-06-27","text":"Compare with first commit","title":"0.1.0 - 2018-06-27"},{"location":"changelog/#added","text":"Add github/github regexes ( 584fd73 ).","title":"Added"},{"location":"changelog/#fixed_2","text":"Fix patch bump ( 8470e69 ). Fix refs parsing ( 8c77cb7 ).","title":"Fixed"},{"location":"changelog/#misc_1","text":"Continue packaging (#6) ( a29af2c ). Finish packaging (#6) ( e92b492 ). Implement reference parsing ( a9b4a89 ). Improve angular template, improve style/refs system ( 5b87d48 ). Initial commit ( 83845fe ). Package code (#6) ( 1219eaf ). Update changelog for version 0.1.0 ( 14edcaf ). Update changelog for version 0.1.0 ( 610633d ). Update changelog for version 0.1.0 ( 2eaaa2e ). Work in progress ( 27a60e8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd git-changelog make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run git-changelog [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd git-changelog make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run git-changelog [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"These projects were used to build git-changelog . Thank you! python | pdm | copier-pdm Runtime dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License jinja2 A very fast and expressive template engine. >=2.10,<4 3.1.2 BSD-3-Clause markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD Development dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause attrs Classes Without Boilerplate >=19.2.0 22.1.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.7.7 MIT bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=21.10b0 22.10.0 MIT License cached-property A decorator for caching properties in classes. ~=1.5; python_version < \"3.8\" 1.5.2 BSD certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.9.24 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit >=8.0.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.6 BSD License coverage Code coverage measurement for Python [toml]>=5.2.1 6.5.0 Apache 2.0 darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.6.2 0.6.2 MIT license duty A simple task runner. >=0.7 0.7.0 ISC exceptiongroup Backport of PEP 654 (exception groups) >=1.0.0rc8; python_version < \"3.11\" 1.0.0rc9 MIT License execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 ISC flake8 the modular source code checker: pep8 pyflakes and co >=4; python_version >= '3.8' 5.0.4 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 4.1.1 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.3 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.10.25 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 2.0.0 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins >=1.0.2 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License gitdb Git Object Database <5,>=4.0.1 4.0.9 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.29 BSD griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.11.1 0.22.2 ISC idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.4 BSD License importlib-metadata Read metadata from Python packages <5; python_version < '3.8' 4.13.0 Apache Software License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause markdown Python implementation of Markdown. <4.0.0,>=3.3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.3.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 0.7.2 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.8.0,>=0.7.0 0.7.0 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.4.1 BSD License mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.5 ISC License (ISCL) mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.4.0 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.5.0 MIT mkdocs-material Documentation that simply works >=7.3 8.5.7 MIT License mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. >=1.0.3 1.1 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.18 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.7.1 ISC mypy Optional static typing for Python >=0.910 0.982 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.10.1 MPL 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.11.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.2 Expat license platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.2 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ISC License (ISCL) pycodestyle Python style guide checker <2.10.0,>=2.9.0 2.9.1 Expat license pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs >=1.1.0 2.5.0 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.13.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.7 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.2.0 MIT pytest-cov Pytest plugin for measuring coverage. >=3.0 4.0.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 3.0.2 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pyyaml YAML parser and emitter for Python >=5.1 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License requests Python HTTP for Humans. >=2.26 2.28.1 Apache 2.0 ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order >=0.17.21 0.17.21 MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml >=0.2.6; platform_python_implementation == \"CPython\" and python_version < \"3.11\" 0.2.7 MIT safety Checks installed dependencies for known vulnerabilities and licenses. >=2 2.3.1 MIT license setuptools Easily download, build, install, upgrade, and uninstall Python packages >=19.3 65.5.0 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications >=1.20.0 3.5.2 Apache Software License toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=2.0.1; python_version < \"3.11\" 2.0.1 MIT License typed-ast a fork of Python 2 and 3 ast modules with type comment support >=1.4.2; python_version < \"3.8\" and implementation_name == \"cpython\" 1.5.4 Apache License 2.0 types-markdown Typing stubs for Markdown >=3.3 3.4.2.1 Apache-2.0 license types-setuptools Typing stubs for setuptools >=65.5.0.2 65.5.0.2 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.8 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.7+ >=3.10.0.0; python_version < \"3.10\" 4.4.0 Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.12 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT zipp Backport of pathlib-compatible object wrapper for zip files >=0.5 3.10.0 MIT License More credits from the author","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2018, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"git_changelog build cli commit providers templates","title":"SUMMARY"},{"location":"reference/git_changelog/","text":"git-changelog package. Automatic Changelog generator using Jinja2 templates. GitHub \u00a4 Bases: ProviderRefParser A parser for the GitHub references. Source code in git_changelog/providers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class GitHub ( ProviderRefParser ): \"\"\"A parser for the GitHub references.\"\"\" url : str = \"https://github.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /releases/tag/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" }) __init__ ( namespace , project , url = url ) \u00a4 Initialization method. Parameters: Name Type Description Default namespace str The GitHub namespace. required project str The GitHub project. required url str The GitHub URL. url Source code in git_changelog/providers.py 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) GitLab \u00a4 Bases: ProviderRefParser A parser for the GitLab references. Source code in git_changelog/providers.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class GitLab ( ProviderRefParser ): \"\"\"A parser for the GitLab references.\"\"\" url : str = \"https://gitlab.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /tags/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"merge_requests\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"!\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /merge_requests/ {ref} \" , ), \"snippets\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"\\$\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /snippets/ {ref} \" , ), \"labels_ids\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , # no label_id param? ), \"labels_one_word\" : RefDef ( regex = re . compile ( # also matches label IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"labels_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"milestones_ids\" : RefDef ( regex = re . compile ( # also matches milestones IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones/ {ref} \" , ), \"milestones_one_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"milestones_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project if ref_type . startswith ( \"label\" ): match_dict [ \"ref\" ] = match_dict [ \"ref\" ] . replace ( '\"' , \"\" ) . replace ( \" \" , \"+\" ) return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" }) __init__ ( namespace , project , url = url ) \u00a4 Initialization method. Parameters: Name Type Description Default namespace str The GitLab namespace. required project str The GitLab project. required url str The GitLab URL. url Source code in git_changelog/providers.py 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default)","title":"git_changelog"},{"location":"reference/git_changelog/#git_changelog.GitHub","text":"Bases: ProviderRefParser A parser for the GitHub references. Source code in git_changelog/providers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class GitHub ( ProviderRefParser ): \"\"\"A parser for the GitHub references.\"\"\" url : str = \"https://github.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /releases/tag/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" })","title":"GitHub"},{"location":"reference/git_changelog/#git_changelog.providers.GitHub.__init__","text":"Initialization method. Parameters: Name Type Description Default namespace str The GitHub namespace. required project str The GitHub project. required url str The GitHub URL. url Source code in git_changelog/providers.py 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default)","title":"__init__()"},{"location":"reference/git_changelog/#git_changelog.GitLab","text":"Bases: ProviderRefParser A parser for the GitLab references. Source code in git_changelog/providers.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class GitLab ( ProviderRefParser ): \"\"\"A parser for the GitLab references.\"\"\" url : str = \"https://gitlab.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /tags/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"merge_requests\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"!\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /merge_requests/ {ref} \" , ), \"snippets\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"\\$\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /snippets/ {ref} \" , ), \"labels_ids\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , # no label_id param? ), \"labels_one_word\" : RefDef ( regex = re . compile ( # also matches label IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"labels_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"milestones_ids\" : RefDef ( regex = re . compile ( # also matches milestones IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones/ {ref} \" , ), \"milestones_one_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"milestones_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project if ref_type . startswith ( \"label\" ): match_dict [ \"ref\" ] = match_dict [ \"ref\" ] . replace ( '\"' , \"\" ) . replace ( \" \" , \"+\" ) return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" })","title":"GitLab"},{"location":"reference/git_changelog/#git_changelog.providers.GitLab.__init__","text":"Initialization method. Parameters: Name Type Description Default namespace str The GitLab namespace. required project str The GitLab project. required url str The GitLab URL. url Source code in git_changelog/providers.py 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default)","title":"__init__()"},{"location":"reference/git_changelog/build/","text":"The module responsible for building the data. Changelog \u00a4 The main changelog class. Source code in git_changelog/build.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class Changelog : \"\"\"The main changelog class.\"\"\" MARKER : str = \"--GIT-CHANGELOG MARKER--\" FORMAT : str = ( r \"%H%n\" # commit commit_hash # noqa: WPS323 r \" %a n%n\" # author name r \" %a e%n\" # author email r \" %a d%n\" # author date r \" %c n%n\" # committer name r \" %c e%n\" # committer email r \" %c d%n\" # committer date r \"%D%n\" # tag r \" %s %n\" # subject r \"%b%n\" + MARKER # body ) STYLE : Dict [ str , Type [ CommitStyle ]] = { \"basic\" : BasicStyle , \"angular\" : AngularStyle , \"atom\" : AtomStyle , \"conventional\" : ConventionalCommitStyle , } def __init__ ( # noqa: WPS231 self , repository : str , provider : Optional [ ProviderRefParser ] = None , style : StyleType = None , ): \"\"\" Initialization method. Arguments: repository: The repository (directory) for which to build the changelog. provider: The provider to use (github.com, gitlab.com, etc.). style: The commit style to use (angular, atom, etc.). \"\"\" self . repository : str = repository # set provider if not provider : remote_url = self . get_remote_url () split = remote_url . split ( \"/\" ) provider_url = \"/\" . join ( split [: 3 ]) namespace , project = \"/\" . join ( split [ 3 : - 1 ]), split [ - 1 ] if \"github\" in provider_url : provider = GitHub ( namespace , project , url = provider_url ) elif \"gitlab\" in provider_url : provider = GitLab ( namespace , project , url = provider_url ) self . remote_url : str = remote_url self . provider = provider # set style if isinstance ( style , str ): try : style = self . STYLE [ style ]() except KeyError : print ( f \"git-changelog: no such style available: { style } , using default style\" , file = sys . stderr ) style = BasicStyle () elif style is None : style = BasicStyle () elif not isinstance ( style , CommitStyle ) and issubclass ( style , CommitStyle ): style = style () self . style : CommitStyle = style # get git log and parse it into list of commits self . raw_log : str = self . get_log () self . commits : List [ Commit ] = self . parse_commits () # apply dates to commits and group them by version dates = self . apply_versions_to_commits () v_list , v_dict = self . group_commits_by_version ( dates ) self . versions_list = v_list self . versions_dict = v_dict # guess the next version number based on last version and recent commits last_version = self . versions_list [ 0 ] if not last_version . tag and last_version . previous_version : last_tag = last_version . previous_version . tag major = minor = False # noqa: WPS429 for commit in last_version . commits : if commit . style [ \"is_major\" ]: major = True break elif commit . style [ \"is_minor\" ]: minor = True if major : planned_tag = bump ( last_tag , \"major\" ) elif minor : planned_tag = bump ( last_tag , \"minor\" ) else : planned_tag = bump ( last_tag , \"patch\" ) last_version . planned_tag = planned_tag if self . provider : last_version . url = self . provider . get_tag_url ( tag = planned_tag ) last_version . compare_url = self . provider . get_compare_url ( base = last_version . previous_version . tag , target = last_version . planned_tag ) def run_git ( self , * args : str ) -> str : \"\"\"Run a git command in the chosen repository. Arguments: *args: Arguments passed to the git command. Returns: The git command output. \"\"\" return check_output ([ \"git\" , * args ], cwd = self . repository ) . decode ( \"utf8\" ) # noqa: S603,S607 def get_remote_url ( self ) -> str : # noqa: WPS615 \"\"\"Get the git remote URL for the repository. Returns: The origin remote URL. \"\"\" remote = \"remote.\" + os . environ . get ( \"GIT_CHANGELOG_REMOTE\" , \"origin\" ) + \".url\" git_url = self . run_git ( \"config\" , \"--get\" , remote ) . rstrip ( \" \\n \" ) if git_url . startswith ( \"git@\" ): git_url = git_url . replace ( \":\" , \"/\" , 1 ) . replace ( \"git@\" , \"https://\" , 1 ) if git_url . endswith ( \".git\" ): git_url = git_url [: - 4 ] return git_url def get_log ( self ) -> str : \"\"\"Get the `git log` output. Returns: The output of the `git log` command, with a particular format. \"\"\" return self . run_git ( \"log\" , \"--date=unix\" , \"--format=\" + self . FORMAT ) def parse_commits ( self ) -> List [ Commit ]: \"\"\"Parse the output of 'git log' into a list of commits. Returns: The list of commits. \"\"\" lines = self . raw_log . split ( \" \\n \" ) size = len ( lines ) - 1 # don't count last blank line commits = [] pos = 0 while pos < size : commit = Commit ( commit_hash = lines [ pos ], author_name = lines [ pos + 1 ], author_email = lines [ pos + 2 ], author_date = lines [ pos + 3 ], committer_name = lines [ pos + 4 ], committer_email = lines [ pos + 5 ], committer_date = lines [ pos + 6 ], refs = lines [ pos + 7 ], subject = lines [ pos + 8 ], body = [ lines [ pos + 9 ]], ) # append body lines nbl_index = 10 while lines [ pos + nbl_index ] != self . MARKER : commit . body . append ( lines [ pos + nbl_index ]) nbl_index += 1 pos += nbl_index + 1 # expand commit object with provider parsing if self . provider : commit . update_with_provider ( self . provider ) elif self . remote_url : # set the commit url based on remote_url (could be wrong) commit . url = self . remote_url + \"/commit/\" + commit . hash # expand commit object with style parsing if self . style : commit . update_with_style ( self . style ) commits . append ( commit ) return commits def apply_versions_to_commits ( self ) -> Dict [ str , datetime . date ]: \"\"\"Iterate on the commits to apply them a date. Returns: A dictionary with versions as keys and dates as values. \"\"\" versions_dates = { \"\" : datetime . date . today ()} version = None for commit in self . commits : if commit . version : version = commit . version versions_dates [ version ] = commit . committer_date . date () elif version : commit . version = version return versions_dates def group_commits_by_version ( # noqa: WPS231 self , dates : Dict [ str , datetime . date ] ) -> Tuple [ List [ Version ], Dict [ str , Version ]]: \"\"\"Iterate on commits to group them by version. Arguments: dates: A dictionary with versions as keys and their dates as values. Returns: A tuple containing the versions as a list and the versions as a dictionary. \"\"\" versions_list = [] versions_dict = {} versions_types_dict : Dict [ str , Dict [ str , Section ]] = {} next_version = None for commit in self . commits : if commit . version not in versions_dict : version = Version ( tag = commit . version , date = dates [ commit . version ]) versions_dict [ commit . version ] = version if self . provider : version . url = self . provider . get_tag_url ( tag = commit . version ) if next_version : version . next_version = next_version next_version . previous_version = version if self . provider : next_version . compare_url = self . provider . get_compare_url ( base = version . tag , target = next_version . tag or \"HEAD\" ) next_version = version versions_list . append ( version ) versions_types_dict [ commit . version ] = {} versions_dict [ commit . version ] . commits . append ( commit ) if \"type\" in commit . style and commit . style [ \"type\" ] not in versions_types_dict [ commit . version ]: section = Section ( section_type = commit . style [ \"type\" ]) versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] = section versions_dict [ commit . version ] . sections_list . append ( section ) versions_dict [ commit . version ] . sections_dict = versions_types_dict [ commit . version ] versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] . commits . append ( commit ) if next_version is not None and self . provider : next_version . compare_url = self . provider . get_compare_url ( base = versions_list [ - 1 ] . commits [ - 1 ] . hash , target = next_version . tag or \"HEAD\" ) return versions_list , versions_dict __init__ ( repository , provider = None , style = None ) \u00a4 Initialization method. Parameters: Name Type Description Default repository str The repository (directory) for which to build the changelog. required provider Optional [ ProviderRefParser ] The provider to use (github.com, gitlab.com, etc.). None style StyleType The commit style to use (angular, atom, etc.). None Source code in git_changelog/build.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def __init__ ( # noqa: WPS231 self , repository : str , provider : Optional [ ProviderRefParser ] = None , style : StyleType = None , ): \"\"\" Initialization method. Arguments: repository: The repository (directory) for which to build the changelog. provider: The provider to use (github.com, gitlab.com, etc.). style: The commit style to use (angular, atom, etc.). \"\"\" self . repository : str = repository # set provider if not provider : remote_url = self . get_remote_url () split = remote_url . split ( \"/\" ) provider_url = \"/\" . join ( split [: 3 ]) namespace , project = \"/\" . join ( split [ 3 : - 1 ]), split [ - 1 ] if \"github\" in provider_url : provider = GitHub ( namespace , project , url = provider_url ) elif \"gitlab\" in provider_url : provider = GitLab ( namespace , project , url = provider_url ) self . remote_url : str = remote_url self . provider = provider # set style if isinstance ( style , str ): try : style = self . STYLE [ style ]() except KeyError : print ( f \"git-changelog: no such style available: { style } , using default style\" , file = sys . stderr ) style = BasicStyle () elif style is None : style = BasicStyle () elif not isinstance ( style , CommitStyle ) and issubclass ( style , CommitStyle ): style = style () self . style : CommitStyle = style # get git log and parse it into list of commits self . raw_log : str = self . get_log () self . commits : List [ Commit ] = self . parse_commits () # apply dates to commits and group them by version dates = self . apply_versions_to_commits () v_list , v_dict = self . group_commits_by_version ( dates ) self . versions_list = v_list self . versions_dict = v_dict # guess the next version number based on last version and recent commits last_version = self . versions_list [ 0 ] if not last_version . tag and last_version . previous_version : last_tag = last_version . previous_version . tag major = minor = False # noqa: WPS429 for commit in last_version . commits : if commit . style [ \"is_major\" ]: major = True break elif commit . style [ \"is_minor\" ]: minor = True if major : planned_tag = bump ( last_tag , \"major\" ) elif minor : planned_tag = bump ( last_tag , \"minor\" ) else : planned_tag = bump ( last_tag , \"patch\" ) last_version . planned_tag = planned_tag if self . provider : last_version . url = self . provider . get_tag_url ( tag = planned_tag ) last_version . compare_url = self . provider . get_compare_url ( base = last_version . previous_version . tag , target = last_version . planned_tag ) apply_versions_to_commits () \u00a4 Iterate on the commits to apply them a date. Returns: Type Description Dict [ str , datetime . date ] A dictionary with versions as keys and dates as values. Source code in git_changelog/build.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def apply_versions_to_commits ( self ) -> Dict [ str , datetime . date ]: \"\"\"Iterate on the commits to apply them a date. Returns: A dictionary with versions as keys and dates as values. \"\"\" versions_dates = { \"\" : datetime . date . today ()} version = None for commit in self . commits : if commit . version : version = commit . version versions_dates [ version ] = commit . committer_date . date () elif version : commit . version = version return versions_dates get_log () \u00a4 Get the git log output. Returns: Type Description str The output of the git log command, with a particular format. Source code in git_changelog/build.py 254 255 256 257 258 259 260 def get_log ( self ) -> str : \"\"\"Get the `git log` output. Returns: The output of the `git log` command, with a particular format. \"\"\" return self . run_git ( \"log\" , \"--date=unix\" , \"--format=\" + self . FORMAT ) get_remote_url () \u00a4 Get the git remote URL for the repository. Returns: Type Description str The origin remote URL. Source code in git_changelog/build.py 240 241 242 243 244 245 246 247 248 249 250 251 252 def get_remote_url ( self ) -> str : # noqa: WPS615 \"\"\"Get the git remote URL for the repository. Returns: The origin remote URL. \"\"\" remote = \"remote.\" + os . environ . get ( \"GIT_CHANGELOG_REMOTE\" , \"origin\" ) + \".url\" git_url = self . run_git ( \"config\" , \"--get\" , remote ) . rstrip ( \" \\n \" ) if git_url . startswith ( \"git@\" ): git_url = git_url . replace ( \":\" , \"/\" , 1 ) . replace ( \"git@\" , \"https://\" , 1 ) if git_url . endswith ( \".git\" ): git_url = git_url [: - 4 ] return git_url group_commits_by_version ( dates ) \u00a4 Iterate on commits to group them by version. Parameters: Name Type Description Default dates Dict [ str , datetime . date ] A dictionary with versions as keys and their dates as values. required Returns: Type Description Tuple [ List [ Version ], Dict [ str , Version ]] A tuple containing the versions as a list and the versions as a dictionary. Source code in git_changelog/build.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def group_commits_by_version ( # noqa: WPS231 self , dates : Dict [ str , datetime . date ] ) -> Tuple [ List [ Version ], Dict [ str , Version ]]: \"\"\"Iterate on commits to group them by version. Arguments: dates: A dictionary with versions as keys and their dates as values. Returns: A tuple containing the versions as a list and the versions as a dictionary. \"\"\" versions_list = [] versions_dict = {} versions_types_dict : Dict [ str , Dict [ str , Section ]] = {} next_version = None for commit in self . commits : if commit . version not in versions_dict : version = Version ( tag = commit . version , date = dates [ commit . version ]) versions_dict [ commit . version ] = version if self . provider : version . url = self . provider . get_tag_url ( tag = commit . version ) if next_version : version . next_version = next_version next_version . previous_version = version if self . provider : next_version . compare_url = self . provider . get_compare_url ( base = version . tag , target = next_version . tag or \"HEAD\" ) next_version = version versions_list . append ( version ) versions_types_dict [ commit . version ] = {} versions_dict [ commit . version ] . commits . append ( commit ) if \"type\" in commit . style and commit . style [ \"type\" ] not in versions_types_dict [ commit . version ]: section = Section ( section_type = commit . style [ \"type\" ]) versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] = section versions_dict [ commit . version ] . sections_list . append ( section ) versions_dict [ commit . version ] . sections_dict = versions_types_dict [ commit . version ] versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] . commits . append ( commit ) if next_version is not None and self . provider : next_version . compare_url = self . provider . get_compare_url ( base = versions_list [ - 1 ] . commits [ - 1 ] . hash , target = next_version . tag or \"HEAD\" ) return versions_list , versions_dict parse_commits () \u00a4 Parse the output of 'git log' into a list of commits. Returns: Type Description List [ Commit ] The list of commits. Source code in git_changelog/build.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_commits ( self ) -> List [ Commit ]: \"\"\"Parse the output of 'git log' into a list of commits. Returns: The list of commits. \"\"\" lines = self . raw_log . split ( \" \\n \" ) size = len ( lines ) - 1 # don't count last blank line commits = [] pos = 0 while pos < size : commit = Commit ( commit_hash = lines [ pos ], author_name = lines [ pos + 1 ], author_email = lines [ pos + 2 ], author_date = lines [ pos + 3 ], committer_name = lines [ pos + 4 ], committer_email = lines [ pos + 5 ], committer_date = lines [ pos + 6 ], refs = lines [ pos + 7 ], subject = lines [ pos + 8 ], body = [ lines [ pos + 9 ]], ) # append body lines nbl_index = 10 while lines [ pos + nbl_index ] != self . MARKER : commit . body . append ( lines [ pos + nbl_index ]) nbl_index += 1 pos += nbl_index + 1 # expand commit object with provider parsing if self . provider : commit . update_with_provider ( self . provider ) elif self . remote_url : # set the commit url based on remote_url (could be wrong) commit . url = self . remote_url + \"/commit/\" + commit . hash # expand commit object with style parsing if self . style : commit . update_with_style ( self . style ) commits . append ( commit ) return commits run_git ( * args ) \u00a4 Run a git command in the chosen repository. Parameters: Name Type Description Default *args str Arguments passed to the git command. () Returns: Type Description str The git command output. Source code in git_changelog/build.py 229 230 231 232 233 234 235 236 237 238 def run_git ( self , * args : str ) -> str : \"\"\"Run a git command in the chosen repository. Arguments: *args: Arguments passed to the git command. Returns: The git command output. \"\"\" return check_output ([ \"git\" , * args ], cwd = self . repository ) . decode ( \"utf8\" ) # noqa: S603,S607 Section \u00a4 A list of commits grouped by section_type. Source code in git_changelog/build.py 43 44 45 46 47 48 49 50 51 52 53 54 55 class Section : \"\"\"A list of commits grouped by section_type.\"\"\" def __init__ ( self , section_type : str = \"\" , commits : List [ Commit ] = None ): \"\"\" Initialization method. Arguments: section_type: The section section_type. commits: The list of commits. \"\"\" self . type : str = section_type self . commits : List [ Commit ] = commits or [] __init__ ( section_type = '' , commits = None ) \u00a4 Initialization method. Parameters: Name Type Description Default section_type str The section section_type. '' commits List [ Commit ] The list of commits. None Source code in git_changelog/build.py 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , section_type : str = \"\" , commits : List [ Commit ] = None ): \"\"\" Initialization method. Arguments: section_type: The section section_type. commits: The list of commits. \"\"\" self . type : str = section_type self . commits : List [ Commit ] = commits or [] Version \u00a4 A class to represent a changelog version. Source code in git_changelog/build.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class Version : \"\"\"A class to represent a changelog version.\"\"\" def __init__ ( self , tag : str = \"\" , date : Optional [ datetime . date ] = None , sections : List [ Section ] = None , commits : List [ Commit ] = None , url : str = \"\" , compare_url : str = \"\" , ): \"\"\" Initialization method. Arguments: tag: The version tag. date: The version date. sections: The version sections. commits: The version commits. url: The version URL. compare_url: The version 'compare' URL. \"\"\" self . tag = tag self . date = date self . sections_list : List [ Section ] = sections or [] self . sections_dict : Dict [ str , Section ] = { section . type : section for section in self . sections_list } self . commits : List [ Commit ] = commits or [] self . url : str = url self . compare_url : str = compare_url self . previous_version : Union [ Version , None ] = None self . next_version : Union [ Version , None ] = None self . planned_tag : Optional [ str ] = None @property def typed_sections ( self ) -> List [ Section ]: \"\"\"Return typed sections only. Returns: The typed sections. \"\"\" return [ section for section in self . sections_list if section . type ] @property def untyped_section ( self ) -> Optional [ Section ]: \"\"\"Return untyped section if any. Returns: The untyped section if any. \"\"\" return self . sections_dict . get ( \"\" , None ) @property def is_major ( self ) -> bool : \"\"\"Tell if this version is a major one. Returns: Whether this version is major. \"\"\" return self . tag . split ( \".\" , 1 )[ 1 ] . startswith ( \"0.0\" ) @property def is_minor ( self ) -> bool : \"\"\"Tell if this version is a minor one. Returns: Whether this version is minor. \"\"\" return bool ( self . tag . split ( \".\" , 2 )[ 2 ]) __init__ ( tag = '' , date = None , sections = None , commits = None , url = '' , compare_url = '' ) \u00a4 Initialization method. Parameters: Name Type Description Default tag str The version tag. '' date Optional [ datetime . date ] The version date. None sections List [ Section ] The version sections. None commits List [ Commit ] The version commits. None url str The version URL. '' compare_url str The version 'compare' URL. '' Source code in git_changelog/build.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , tag : str = \"\" , date : Optional [ datetime . date ] = None , sections : List [ Section ] = None , commits : List [ Commit ] = None , url : str = \"\" , compare_url : str = \"\" , ): \"\"\" Initialization method. Arguments: tag: The version tag. date: The version date. sections: The version sections. commits: The version commits. url: The version URL. compare_url: The version 'compare' URL. \"\"\" self . tag = tag self . date = date self . sections_list : List [ Section ] = sections or [] self . sections_dict : Dict [ str , Section ] = { section . type : section for section in self . sections_list } self . commits : List [ Commit ] = commits or [] self . url : str = url self . compare_url : str = compare_url self . previous_version : Union [ Version , None ] = None self . next_version : Union [ Version , None ] = None self . planned_tag : Optional [ str ] = None is_major () property \u00a4 Tell if this version is a major one. Returns: Type Description bool Whether this version is major. Source code in git_changelog/build.py 111 112 113 114 115 116 117 118 @property def is_major ( self ) -> bool : \"\"\"Tell if this version is a major one. Returns: Whether this version is major. \"\"\" return self . tag . split ( \".\" , 1 )[ 1 ] . startswith ( \"0.0\" ) is_minor () property \u00a4 Tell if this version is a minor one. Returns: Type Description bool Whether this version is minor. Source code in git_changelog/build.py 120 121 122 123 124 125 126 127 @property def is_minor ( self ) -> bool : \"\"\"Tell if this version is a minor one. Returns: Whether this version is minor. \"\"\" return bool ( self . tag . split ( \".\" , 2 )[ 2 ]) typed_sections () property \u00a4 Return typed sections only. Returns: Type Description List [ Section ] The typed sections. Source code in git_changelog/build.py 93 94 95 96 97 98 99 100 @property def typed_sections ( self ) -> List [ Section ]: \"\"\"Return typed sections only. Returns: The typed sections. \"\"\" return [ section for section in self . sections_list if section . type ] untyped_section () property \u00a4 Return untyped section if any. Returns: Type Description Optional [ Section ] The untyped section if any. Source code in git_changelog/build.py 102 103 104 105 106 107 108 109 @property def untyped_section ( self ) -> Optional [ Section ]: \"\"\"Return untyped section if any. Returns: The untyped section if any. \"\"\" return self . sections_dict . get ( \"\" , None ) bump ( version , part = 'patch' ) \u00a4 Bump a version. Parameters: Name Type Description Default version str The version to bump. required part str The part of the version to bump (major, minor, or patch). 'patch' Returns: Type Description str The bumped version. Source code in git_changelog/build.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def bump ( version : str , part : str = \"patch\" ) -> str : # noqa: WPS231 \"\"\" Bump a version. Arguments: version: The version to bump. part: The part of the version to bump (major, minor, or patch). Returns: The bumped version. \"\"\" prefix = \"\" if version [ 0 ] == \"v\" : prefix = \"v\" version = version [ 1 :] semver_version = VersionInfo . parse ( version ) if part == \"major\" and semver_version . major != 0 : semver_version = semver_version . bump_major () elif part == \"minor\" or ( part == \"major\" and semver_version . major == 0 ): semver_version = semver_version . bump_minor () elif part == \"patch\" and not semver_version . prerelease : semver_version = semver_version . bump_patch () return prefix + str ( semver_version )","title":"build"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog","text":"The main changelog class. Source code in git_changelog/build.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class Changelog : \"\"\"The main changelog class.\"\"\" MARKER : str = \"--GIT-CHANGELOG MARKER--\" FORMAT : str = ( r \"%H%n\" # commit commit_hash # noqa: WPS323 r \" %a n%n\" # author name r \" %a e%n\" # author email r \" %a d%n\" # author date r \" %c n%n\" # committer name r \" %c e%n\" # committer email r \" %c d%n\" # committer date r \"%D%n\" # tag r \" %s %n\" # subject r \"%b%n\" + MARKER # body ) STYLE : Dict [ str , Type [ CommitStyle ]] = { \"basic\" : BasicStyle , \"angular\" : AngularStyle , \"atom\" : AtomStyle , \"conventional\" : ConventionalCommitStyle , } def __init__ ( # noqa: WPS231 self , repository : str , provider : Optional [ ProviderRefParser ] = None , style : StyleType = None , ): \"\"\" Initialization method. Arguments: repository: The repository (directory) for which to build the changelog. provider: The provider to use (github.com, gitlab.com, etc.). style: The commit style to use (angular, atom, etc.). \"\"\" self . repository : str = repository # set provider if not provider : remote_url = self . get_remote_url () split = remote_url . split ( \"/\" ) provider_url = \"/\" . join ( split [: 3 ]) namespace , project = \"/\" . join ( split [ 3 : - 1 ]), split [ - 1 ] if \"github\" in provider_url : provider = GitHub ( namespace , project , url = provider_url ) elif \"gitlab\" in provider_url : provider = GitLab ( namespace , project , url = provider_url ) self . remote_url : str = remote_url self . provider = provider # set style if isinstance ( style , str ): try : style = self . STYLE [ style ]() except KeyError : print ( f \"git-changelog: no such style available: { style } , using default style\" , file = sys . stderr ) style = BasicStyle () elif style is None : style = BasicStyle () elif not isinstance ( style , CommitStyle ) and issubclass ( style , CommitStyle ): style = style () self . style : CommitStyle = style # get git log and parse it into list of commits self . raw_log : str = self . get_log () self . commits : List [ Commit ] = self . parse_commits () # apply dates to commits and group them by version dates = self . apply_versions_to_commits () v_list , v_dict = self . group_commits_by_version ( dates ) self . versions_list = v_list self . versions_dict = v_dict # guess the next version number based on last version and recent commits last_version = self . versions_list [ 0 ] if not last_version . tag and last_version . previous_version : last_tag = last_version . previous_version . tag major = minor = False # noqa: WPS429 for commit in last_version . commits : if commit . style [ \"is_major\" ]: major = True break elif commit . style [ \"is_minor\" ]: minor = True if major : planned_tag = bump ( last_tag , \"major\" ) elif minor : planned_tag = bump ( last_tag , \"minor\" ) else : planned_tag = bump ( last_tag , \"patch\" ) last_version . planned_tag = planned_tag if self . provider : last_version . url = self . provider . get_tag_url ( tag = planned_tag ) last_version . compare_url = self . provider . get_compare_url ( base = last_version . previous_version . tag , target = last_version . planned_tag ) def run_git ( self , * args : str ) -> str : \"\"\"Run a git command in the chosen repository. Arguments: *args: Arguments passed to the git command. Returns: The git command output. \"\"\" return check_output ([ \"git\" , * args ], cwd = self . repository ) . decode ( \"utf8\" ) # noqa: S603,S607 def get_remote_url ( self ) -> str : # noqa: WPS615 \"\"\"Get the git remote URL for the repository. Returns: The origin remote URL. \"\"\" remote = \"remote.\" + os . environ . get ( \"GIT_CHANGELOG_REMOTE\" , \"origin\" ) + \".url\" git_url = self . run_git ( \"config\" , \"--get\" , remote ) . rstrip ( \" \\n \" ) if git_url . startswith ( \"git@\" ): git_url = git_url . replace ( \":\" , \"/\" , 1 ) . replace ( \"git@\" , \"https://\" , 1 ) if git_url . endswith ( \".git\" ): git_url = git_url [: - 4 ] return git_url def get_log ( self ) -> str : \"\"\"Get the `git log` output. Returns: The output of the `git log` command, with a particular format. \"\"\" return self . run_git ( \"log\" , \"--date=unix\" , \"--format=\" + self . FORMAT ) def parse_commits ( self ) -> List [ Commit ]: \"\"\"Parse the output of 'git log' into a list of commits. Returns: The list of commits. \"\"\" lines = self . raw_log . split ( \" \\n \" ) size = len ( lines ) - 1 # don't count last blank line commits = [] pos = 0 while pos < size : commit = Commit ( commit_hash = lines [ pos ], author_name = lines [ pos + 1 ], author_email = lines [ pos + 2 ], author_date = lines [ pos + 3 ], committer_name = lines [ pos + 4 ], committer_email = lines [ pos + 5 ], committer_date = lines [ pos + 6 ], refs = lines [ pos + 7 ], subject = lines [ pos + 8 ], body = [ lines [ pos + 9 ]], ) # append body lines nbl_index = 10 while lines [ pos + nbl_index ] != self . MARKER : commit . body . append ( lines [ pos + nbl_index ]) nbl_index += 1 pos += nbl_index + 1 # expand commit object with provider parsing if self . provider : commit . update_with_provider ( self . provider ) elif self . remote_url : # set the commit url based on remote_url (could be wrong) commit . url = self . remote_url + \"/commit/\" + commit . hash # expand commit object with style parsing if self . style : commit . update_with_style ( self . style ) commits . append ( commit ) return commits def apply_versions_to_commits ( self ) -> Dict [ str , datetime . date ]: \"\"\"Iterate on the commits to apply them a date. Returns: A dictionary with versions as keys and dates as values. \"\"\" versions_dates = { \"\" : datetime . date . today ()} version = None for commit in self . commits : if commit . version : version = commit . version versions_dates [ version ] = commit . committer_date . date () elif version : commit . version = version return versions_dates def group_commits_by_version ( # noqa: WPS231 self , dates : Dict [ str , datetime . date ] ) -> Tuple [ List [ Version ], Dict [ str , Version ]]: \"\"\"Iterate on commits to group them by version. Arguments: dates: A dictionary with versions as keys and their dates as values. Returns: A tuple containing the versions as a list and the versions as a dictionary. \"\"\" versions_list = [] versions_dict = {} versions_types_dict : Dict [ str , Dict [ str , Section ]] = {} next_version = None for commit in self . commits : if commit . version not in versions_dict : version = Version ( tag = commit . version , date = dates [ commit . version ]) versions_dict [ commit . version ] = version if self . provider : version . url = self . provider . get_tag_url ( tag = commit . version ) if next_version : version . next_version = next_version next_version . previous_version = version if self . provider : next_version . compare_url = self . provider . get_compare_url ( base = version . tag , target = next_version . tag or \"HEAD\" ) next_version = version versions_list . append ( version ) versions_types_dict [ commit . version ] = {} versions_dict [ commit . version ] . commits . append ( commit ) if \"type\" in commit . style and commit . style [ \"type\" ] not in versions_types_dict [ commit . version ]: section = Section ( section_type = commit . style [ \"type\" ]) versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] = section versions_dict [ commit . version ] . sections_list . append ( section ) versions_dict [ commit . version ] . sections_dict = versions_types_dict [ commit . version ] versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] . commits . append ( commit ) if next_version is not None and self . provider : next_version . compare_url = self . provider . get_compare_url ( base = versions_list [ - 1 ] . commits [ - 1 ] . hash , target = next_version . tag or \"HEAD\" ) return versions_list , versions_dict","title":"Changelog"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.__init__","text":"Initialization method. Parameters: Name Type Description Default repository str The repository (directory) for which to build the changelog. required provider Optional [ ProviderRefParser ] The provider to use (github.com, gitlab.com, etc.). None style StyleType The commit style to use (angular, atom, etc.). None Source code in git_changelog/build.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def __init__ ( # noqa: WPS231 self , repository : str , provider : Optional [ ProviderRefParser ] = None , style : StyleType = None , ): \"\"\" Initialization method. Arguments: repository: The repository (directory) for which to build the changelog. provider: The provider to use (github.com, gitlab.com, etc.). style: The commit style to use (angular, atom, etc.). \"\"\" self . repository : str = repository # set provider if not provider : remote_url = self . get_remote_url () split = remote_url . split ( \"/\" ) provider_url = \"/\" . join ( split [: 3 ]) namespace , project = \"/\" . join ( split [ 3 : - 1 ]), split [ - 1 ] if \"github\" in provider_url : provider = GitHub ( namespace , project , url = provider_url ) elif \"gitlab\" in provider_url : provider = GitLab ( namespace , project , url = provider_url ) self . remote_url : str = remote_url self . provider = provider # set style if isinstance ( style , str ): try : style = self . STYLE [ style ]() except KeyError : print ( f \"git-changelog: no such style available: { style } , using default style\" , file = sys . stderr ) style = BasicStyle () elif style is None : style = BasicStyle () elif not isinstance ( style , CommitStyle ) and issubclass ( style , CommitStyle ): style = style () self . style : CommitStyle = style # get git log and parse it into list of commits self . raw_log : str = self . get_log () self . commits : List [ Commit ] = self . parse_commits () # apply dates to commits and group them by version dates = self . apply_versions_to_commits () v_list , v_dict = self . group_commits_by_version ( dates ) self . versions_list = v_list self . versions_dict = v_dict # guess the next version number based on last version and recent commits last_version = self . versions_list [ 0 ] if not last_version . tag and last_version . previous_version : last_tag = last_version . previous_version . tag major = minor = False # noqa: WPS429 for commit in last_version . commits : if commit . style [ \"is_major\" ]: major = True break elif commit . style [ \"is_minor\" ]: minor = True if major : planned_tag = bump ( last_tag , \"major\" ) elif minor : planned_tag = bump ( last_tag , \"minor\" ) else : planned_tag = bump ( last_tag , \"patch\" ) last_version . planned_tag = planned_tag if self . provider : last_version . url = self . provider . get_tag_url ( tag = planned_tag ) last_version . compare_url = self . provider . get_compare_url ( base = last_version . previous_version . tag , target = last_version . planned_tag )","title":"__init__()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.apply_versions_to_commits","text":"Iterate on the commits to apply them a date. Returns: Type Description Dict [ str , datetime . date ] A dictionary with versions as keys and dates as values. Source code in git_changelog/build.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def apply_versions_to_commits ( self ) -> Dict [ str , datetime . date ]: \"\"\"Iterate on the commits to apply them a date. Returns: A dictionary with versions as keys and dates as values. \"\"\" versions_dates = { \"\" : datetime . date . today ()} version = None for commit in self . commits : if commit . version : version = commit . version versions_dates [ version ] = commit . committer_date . date () elif version : commit . version = version return versions_dates","title":"apply_versions_to_commits()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_log","text":"Get the git log output. Returns: Type Description str The output of the git log command, with a particular format. Source code in git_changelog/build.py 254 255 256 257 258 259 260 def get_log ( self ) -> str : \"\"\"Get the `git log` output. Returns: The output of the `git log` command, with a particular format. \"\"\" return self . run_git ( \"log\" , \"--date=unix\" , \"--format=\" + self . FORMAT )","title":"get_log()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.get_remote_url","text":"Get the git remote URL for the repository. Returns: Type Description str The origin remote URL. Source code in git_changelog/build.py 240 241 242 243 244 245 246 247 248 249 250 251 252 def get_remote_url ( self ) -> str : # noqa: WPS615 \"\"\"Get the git remote URL for the repository. Returns: The origin remote URL. \"\"\" remote = \"remote.\" + os . environ . get ( \"GIT_CHANGELOG_REMOTE\" , \"origin\" ) + \".url\" git_url = self . run_git ( \"config\" , \"--get\" , remote ) . rstrip ( \" \\n \" ) if git_url . startswith ( \"git@\" ): git_url = git_url . replace ( \":\" , \"/\" , 1 ) . replace ( \"git@\" , \"https://\" , 1 ) if git_url . endswith ( \".git\" ): git_url = git_url [: - 4 ] return git_url","title":"get_remote_url()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.group_commits_by_version","text":"Iterate on commits to group them by version. Parameters: Name Type Description Default dates Dict [ str , datetime . date ] A dictionary with versions as keys and their dates as values. required Returns: Type Description Tuple [ List [ Version ], Dict [ str , Version ]] A tuple containing the versions as a list and the versions as a dictionary. Source code in git_changelog/build.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def group_commits_by_version ( # noqa: WPS231 self , dates : Dict [ str , datetime . date ] ) -> Tuple [ List [ Version ], Dict [ str , Version ]]: \"\"\"Iterate on commits to group them by version. Arguments: dates: A dictionary with versions as keys and their dates as values. Returns: A tuple containing the versions as a list and the versions as a dictionary. \"\"\" versions_list = [] versions_dict = {} versions_types_dict : Dict [ str , Dict [ str , Section ]] = {} next_version = None for commit in self . commits : if commit . version not in versions_dict : version = Version ( tag = commit . version , date = dates [ commit . version ]) versions_dict [ commit . version ] = version if self . provider : version . url = self . provider . get_tag_url ( tag = commit . version ) if next_version : version . next_version = next_version next_version . previous_version = version if self . provider : next_version . compare_url = self . provider . get_compare_url ( base = version . tag , target = next_version . tag or \"HEAD\" ) next_version = version versions_list . append ( version ) versions_types_dict [ commit . version ] = {} versions_dict [ commit . version ] . commits . append ( commit ) if \"type\" in commit . style and commit . style [ \"type\" ] not in versions_types_dict [ commit . version ]: section = Section ( section_type = commit . style [ \"type\" ]) versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] = section versions_dict [ commit . version ] . sections_list . append ( section ) versions_dict [ commit . version ] . sections_dict = versions_types_dict [ commit . version ] versions_types_dict [ commit . version ][ commit . style [ \"type\" ]] . commits . append ( commit ) if next_version is not None and self . provider : next_version . compare_url = self . provider . get_compare_url ( base = versions_list [ - 1 ] . commits [ - 1 ] . hash , target = next_version . tag or \"HEAD\" ) return versions_list , versions_dict","title":"group_commits_by_version()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.parse_commits","text":"Parse the output of 'git log' into a list of commits. Returns: Type Description List [ Commit ] The list of commits. Source code in git_changelog/build.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_commits ( self ) -> List [ Commit ]: \"\"\"Parse the output of 'git log' into a list of commits. Returns: The list of commits. \"\"\" lines = self . raw_log . split ( \" \\n \" ) size = len ( lines ) - 1 # don't count last blank line commits = [] pos = 0 while pos < size : commit = Commit ( commit_hash = lines [ pos ], author_name = lines [ pos + 1 ], author_email = lines [ pos + 2 ], author_date = lines [ pos + 3 ], committer_name = lines [ pos + 4 ], committer_email = lines [ pos + 5 ], committer_date = lines [ pos + 6 ], refs = lines [ pos + 7 ], subject = lines [ pos + 8 ], body = [ lines [ pos + 9 ]], ) # append body lines nbl_index = 10 while lines [ pos + nbl_index ] != self . MARKER : commit . body . append ( lines [ pos + nbl_index ]) nbl_index += 1 pos += nbl_index + 1 # expand commit object with provider parsing if self . provider : commit . update_with_provider ( self . provider ) elif self . remote_url : # set the commit url based on remote_url (could be wrong) commit . url = self . remote_url + \"/commit/\" + commit . hash # expand commit object with style parsing if self . style : commit . update_with_style ( self . style ) commits . append ( commit ) return commits","title":"parse_commits()"},{"location":"reference/git_changelog/build/#git_changelog.build.Changelog.run_git","text":"Run a git command in the chosen repository. Parameters: Name Type Description Default *args str Arguments passed to the git command. () Returns: Type Description str The git command output. Source code in git_changelog/build.py 229 230 231 232 233 234 235 236 237 238 def run_git ( self , * args : str ) -> str : \"\"\"Run a git command in the chosen repository. Arguments: *args: Arguments passed to the git command. Returns: The git command output. \"\"\" return check_output ([ \"git\" , * args ], cwd = self . repository ) . decode ( \"utf8\" ) # noqa: S603,S607","title":"run_git()"},{"location":"reference/git_changelog/build/#git_changelog.build.Section","text":"A list of commits grouped by section_type. Source code in git_changelog/build.py 43 44 45 46 47 48 49 50 51 52 53 54 55 class Section : \"\"\"A list of commits grouped by section_type.\"\"\" def __init__ ( self , section_type : str = \"\" , commits : List [ Commit ] = None ): \"\"\" Initialization method. Arguments: section_type: The section section_type. commits: The list of commits. \"\"\" self . type : str = section_type self . commits : List [ Commit ] = commits or []","title":"Section"},{"location":"reference/git_changelog/build/#git_changelog.build.Section.__init__","text":"Initialization method. Parameters: Name Type Description Default section_type str The section section_type. '' commits List [ Commit ] The list of commits. None Source code in git_changelog/build.py 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , section_type : str = \"\" , commits : List [ Commit ] = None ): \"\"\" Initialization method. Arguments: section_type: The section section_type. commits: The list of commits. \"\"\" self . type : str = section_type self . commits : List [ Commit ] = commits or []","title":"__init__()"},{"location":"reference/git_changelog/build/#git_changelog.build.Version","text":"A class to represent a changelog version. Source code in git_changelog/build.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class Version : \"\"\"A class to represent a changelog version.\"\"\" def __init__ ( self , tag : str = \"\" , date : Optional [ datetime . date ] = None , sections : List [ Section ] = None , commits : List [ Commit ] = None , url : str = \"\" , compare_url : str = \"\" , ): \"\"\" Initialization method. Arguments: tag: The version tag. date: The version date. sections: The version sections. commits: The version commits. url: The version URL. compare_url: The version 'compare' URL. \"\"\" self . tag = tag self . date = date self . sections_list : List [ Section ] = sections or [] self . sections_dict : Dict [ str , Section ] = { section . type : section for section in self . sections_list } self . commits : List [ Commit ] = commits or [] self . url : str = url self . compare_url : str = compare_url self . previous_version : Union [ Version , None ] = None self . next_version : Union [ Version , None ] = None self . planned_tag : Optional [ str ] = None @property def typed_sections ( self ) -> List [ Section ]: \"\"\"Return typed sections only. Returns: The typed sections. \"\"\" return [ section for section in self . sections_list if section . type ] @property def untyped_section ( self ) -> Optional [ Section ]: \"\"\"Return untyped section if any. Returns: The untyped section if any. \"\"\" return self . sections_dict . get ( \"\" , None ) @property def is_major ( self ) -> bool : \"\"\"Tell if this version is a major one. Returns: Whether this version is major. \"\"\" return self . tag . split ( \".\" , 1 )[ 1 ] . startswith ( \"0.0\" ) @property def is_minor ( self ) -> bool : \"\"\"Tell if this version is a minor one. Returns: Whether this version is minor. \"\"\" return bool ( self . tag . split ( \".\" , 2 )[ 2 ])","title":"Version"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.__init__","text":"Initialization method. Parameters: Name Type Description Default tag str The version tag. '' date Optional [ datetime . date ] The version date. None sections List [ Section ] The version sections. None commits List [ Commit ] The version commits. None url str The version URL. '' compare_url str The version 'compare' URL. '' Source code in git_changelog/build.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , tag : str = \"\" , date : Optional [ datetime . date ] = None , sections : List [ Section ] = None , commits : List [ Commit ] = None , url : str = \"\" , compare_url : str = \"\" , ): \"\"\" Initialization method. Arguments: tag: The version tag. date: The version date. sections: The version sections. commits: The version commits. url: The version URL. compare_url: The version 'compare' URL. \"\"\" self . tag = tag self . date = date self . sections_list : List [ Section ] = sections or [] self . sections_dict : Dict [ str , Section ] = { section . type : section for section in self . sections_list } self . commits : List [ Commit ] = commits or [] self . url : str = url self . compare_url : str = compare_url self . previous_version : Union [ Version , None ] = None self . next_version : Union [ Version , None ] = None self . planned_tag : Optional [ str ] = None","title":"__init__()"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_major","text":"Tell if this version is a major one. Returns: Type Description bool Whether this version is major. Source code in git_changelog/build.py 111 112 113 114 115 116 117 118 @property def is_major ( self ) -> bool : \"\"\"Tell if this version is a major one. Returns: Whether this version is major. \"\"\" return self . tag . split ( \".\" , 1 )[ 1 ] . startswith ( \"0.0\" )","title":"is_major()"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.is_minor","text":"Tell if this version is a minor one. Returns: Type Description bool Whether this version is minor. Source code in git_changelog/build.py 120 121 122 123 124 125 126 127 @property def is_minor ( self ) -> bool : \"\"\"Tell if this version is a minor one. Returns: Whether this version is minor. \"\"\" return bool ( self . tag . split ( \".\" , 2 )[ 2 ])","title":"is_minor()"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.typed_sections","text":"Return typed sections only. Returns: Type Description List [ Section ] The typed sections. Source code in git_changelog/build.py 93 94 95 96 97 98 99 100 @property def typed_sections ( self ) -> List [ Section ]: \"\"\"Return typed sections only. Returns: The typed sections. \"\"\" return [ section for section in self . sections_list if section . type ]","title":"typed_sections()"},{"location":"reference/git_changelog/build/#git_changelog.build.Version.untyped_section","text":"Return untyped section if any. Returns: Type Description Optional [ Section ] The untyped section if any. Source code in git_changelog/build.py 102 103 104 105 106 107 108 109 @property def untyped_section ( self ) -> Optional [ Section ]: \"\"\"Return untyped section if any. Returns: The untyped section if any. \"\"\" return self . sections_dict . get ( \"\" , None )","title":"untyped_section()"},{"location":"reference/git_changelog/build/#git_changelog.build.bump","text":"Bump a version. Parameters: Name Type Description Default version str The version to bump. required part str The part of the version to bump (major, minor, or patch). 'patch' Returns: Type Description str The bumped version. Source code in git_changelog/build.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def bump ( version : str , part : str = \"patch\" ) -> str : # noqa: WPS231 \"\"\" Bump a version. Arguments: version: The version to bump. part: The part of the version to bump (major, minor, or patch). Returns: The bumped version. \"\"\" prefix = \"\" if version [ 0 ] == \"v\" : prefix = \"v\" version = version [ 1 :] semver_version = VersionInfo . parse ( version ) if part == \"major\" and semver_version . major != 0 : semver_version = semver_version . bump_major () elif part == \"minor\" or ( part == \"major\" and semver_version . major == 0 ): semver_version = semver_version . bump_minor () elif part == \"patch\" and not semver_version . prerelease : semver_version = semver_version . bump_patch () return prefix + str ( semver_version )","title":"bump()"},{"location":"reference/git_changelog/cli/","text":"Module that contains the command line application. Templates \u00a4 Bases: tuple Helper to pick a template on the command line. Source code in git_changelog/cli.py 27 28 29 30 31 32 33 class Templates ( tuple ): # noqa: WPS600 (subclassing tuple) \"\"\"Helper to pick a template on the command line.\"\"\" def __contains__ ( self , item : object ) -> bool : if isinstance ( item , str ): return item . startswith ( \"path:\" ) or super () . __contains__ ( item ) return False get_parser () \u00a4 Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in git_changelog/cli.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( add_help = False , prog = \"git-changelog\" , description = \"Command line tool for git-changelog Python package.\" ) parser . add_argument ( \"repository\" , metavar = \"REPOSITORY\" , help = \"The repository path, relative or absolute.\" ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) parser . add_argument ( \"-s\" , \"--style\" , choices = STYLES , default = \"basic\" , dest = \"style\" , help = \"The commit style to match against.\" ) parser . add_argument ( \"-t\" , \"--template\" , choices = Templates (( \"angular\" , \"keepachangelog\" )), default = \"keepachangelog\" , dest = \"template\" , help = 'The Jinja2 template to use. Prefix with \"path:\" to specify the path ' 'to a directory containing a file named \"changelog.md\".' , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s \" + get_version (), # noqa: WPS323 (%) help = \"Show the current version of the program and exit.\" , ) return parser get_version () \u00a4 Return the current git-changelog version. Returns: Type Description str The current git-changelog version. Source code in git_changelog/cli.py 36 37 38 39 40 41 42 43 44 45 46 47 def get_version () -> str : \"\"\" Return the current `git-changelog` version. Returns: The current `git-changelog` version. \"\"\" try : distribution = pkg_resources . get_distribution ( \"git-changelog\" ) except pkg_resources . DistributionNotFound : return \"0.0.0\" return distribution . version main ( args = None ) \u00a4 Run the main program. This function is executed when you type git-changelog or python -m git_changelog . Parameters: Name Type Description Default args Optional [ List [ str ]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in git_changelog/cli.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `git-changelog` or `python -m git_changelog`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) # get template if opts . template . startswith ( \"path:\" ): path = opts . template . replace ( \"path:\" , \"\" , 1 ) try : template = templates . get_custom_template ( path ) except TemplateNotFound : print ( f \"git-changelog: no such directory, or missing changelog.md: { path } \" , file = sys . stderr ) return 1 else : template = templates . get_template ( opts . template ) # build data changelog = Changelog ( opts . repository , style = opts . style ) # get rendered contents rendered = template . render ( changelog = changelog ) # write result in specified output if opts . output is sys . stdout : sys . stdout . write ( rendered ) else : with open ( opts . output , \"w\" ) as stream : stream . write ( rendered ) return 0","title":"cli"},{"location":"reference/git_changelog/cli/#git_changelog.cli.Templates","text":"Bases: tuple Helper to pick a template on the command line. Source code in git_changelog/cli.py 27 28 29 30 31 32 33 class Templates ( tuple ): # noqa: WPS600 (subclassing tuple) \"\"\"Helper to pick a template on the command line.\"\"\" def __contains__ ( self , item : object ) -> bool : if isinstance ( item , str ): return item . startswith ( \"path:\" ) or super () . __contains__ ( item ) return False","title":"Templates"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in git_changelog/cli.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( add_help = False , prog = \"git-changelog\" , description = \"Command line tool for git-changelog Python package.\" ) parser . add_argument ( \"repository\" , metavar = \"REPOSITORY\" , help = \"The repository path, relative or absolute.\" ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) parser . add_argument ( \"-s\" , \"--style\" , choices = STYLES , default = \"basic\" , dest = \"style\" , help = \"The commit style to match against.\" ) parser . add_argument ( \"-t\" , \"--template\" , choices = Templates (( \"angular\" , \"keepachangelog\" )), default = \"keepachangelog\" , dest = \"template\" , help = 'The Jinja2 template to use. Prefix with \"path:\" to specify the path ' 'to a directory containing a file named \"changelog.md\".' , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s \" + get_version (), # noqa: WPS323 (%) help = \"Show the current version of the program and exit.\" , ) return parser","title":"get_parser()"},{"location":"reference/git_changelog/cli/#git_changelog.cli.get_version","text":"Return the current git-changelog version. Returns: Type Description str The current git-changelog version. Source code in git_changelog/cli.py 36 37 38 39 40 41 42 43 44 45 46 47 def get_version () -> str : \"\"\" Return the current `git-changelog` version. Returns: The current `git-changelog` version. \"\"\" try : distribution = pkg_resources . get_distribution ( \"git-changelog\" ) except pkg_resources . DistributionNotFound : return \"0.0.0\" return distribution . version","title":"get_version()"},{"location":"reference/git_changelog/cli/#git_changelog.cli.main","text":"Run the main program. This function is executed when you type git-changelog or python -m git_changelog . Parameters: Name Type Description Default args Optional [ List [ str ]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in git_changelog/cli.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `git-changelog` or `python -m git_changelog`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) # get template if opts . template . startswith ( \"path:\" ): path = opts . template . replace ( \"path:\" , \"\" , 1 ) try : template = templates . get_custom_template ( path ) except TemplateNotFound : print ( f \"git-changelog: no such directory, or missing changelog.md: { path } \" , file = sys . stderr ) return 1 else : template = templates . get_template ( opts . template ) # build data changelog = Changelog ( opts . repository , style = opts . style ) # get rendered contents rendered = template . render ( changelog = changelog ) # write result in specified output if opts . output is sys . stdout : sys . stdout . write ( rendered ) else : with open ( opts . output , \"w\" ) as stream : stream . write ( rendered ) return 0","title":"main()"},{"location":"reference/git_changelog/commit/","text":"Module containing the commit logic. AngularStyle \u00a4 Bases: CommitStyle Angular commit message style. Source code in git_changelog/commit.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class AngularStyle ( CommitStyle ): \"\"\"Angular commit message style.\"\"\" TYPES : Dict [ str , str ] = { \"build\" : \"Build\" , \"ci\" : \"CI\" , \"perf\" : \"Performance Improvements\" , \"feat\" : \"Features\" , \"fix\" : \"Bug Fixes\" , \"revert\" : \"Reverts\" , \"docs\" : \"Docs\" , \"style\" : \"Style\" , \"refactor\" : \"Code Refactoring\" , \"test\" : \"Tests\" , \"chore\" : \"Chore\" , } SUBJECT_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))(?:\\((?P<scope>.+)\\))?: (?P<subject>.+)$\" % ( \"|\" . join ( TYPES . keys ())) # noqa: WPS323 (%) ) BREAK_REGEX : Pattern = re . compile ( r \"^break(s|ing changes?)?[ :].+$\" , re . I | re . MULTILINE ) DEFAULT_RENDER = [ TYPES [ \"feat\" ], TYPES [ \"fix\" ], TYPES [ \"revert\" ], TYPES [ \"refactor\" ], TYPES [ \"perf\" ]] def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) subject = self . parse_subject ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) is_minor = not is_major and self . is_minor ( subject [ \"type\" ]) is_patch = not any (( is_major , is_minor )) return { \"type\" : subject [ \"type\" ], \"scope\" : subject [ \"scope\" ], \"subject\" : subject [ \"subject\" ], \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch , } def parse_subject ( self , commit_subject : str ) -> Dict [ str , str ]: \"\"\"Parse the subject of the commit (`<type>[(scope)]: Subject`). Arguments: commit_subject: The commit message subject. Returns: The parsed data. \"\"\" subject_match = self . SUBJECT_REGEX . match ( commit_subject ) if subject_match : dct = subject_match . groupdict () dct [ \"type\" ] = self . TYPES [ dct [ \"type\" ]] return dct return { \"type\" : \"\" , \"scope\" : \"\" , \"subject\" : commit_subject } def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"feat\" ] def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message )) is_major ( commit_message ) \u00a4 Tell if this commit is worth a major bump. Parameters: Name Type Description Default commit_message str The commit message. required Returns: Type Description bool Whether it's a major commit. Source code in git_changelog/commit.py 250 251 252 253 254 255 256 257 258 259 def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message )) is_minor ( commit_type ) \u00a4 Tell if this commit is worth a minor bump. Parameters: Name Type Description Default commit_type str The commit type. required Returns: Type Description bool Whether it's a minor commit. Source code in git_changelog/commit.py 239 240 241 242 243 244 245 246 247 248 def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"feat\" ] parse_subject ( commit_subject ) \u00a4 Parse the subject of the commit ( <type>[(scope)]: Subject ). Parameters: Name Type Description Default commit_subject str The commit message subject. required Returns: Type Description Dict [ str , str ] The parsed data. Source code in git_changelog/commit.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def parse_subject ( self , commit_subject : str ) -> Dict [ str , str ]: \"\"\"Parse the subject of the commit (`<type>[(scope)]: Subject`). Arguments: commit_subject: The commit message subject. Returns: The parsed data. \"\"\" subject_match = self . SUBJECT_REGEX . match ( commit_subject ) if subject_match : dct = subject_match . groupdict () dct [ \"type\" ] = self . TYPES [ dct [ \"type\" ]] return dct return { \"type\" : \"\" , \"scope\" : \"\" , \"subject\" : commit_subject } AtomStyle \u00a4 Bases: CommitStyle Atom commit message style. Source code in git_changelog/commit.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 class AtomStyle ( CommitStyle ): \"\"\"Atom commit message style.\"\"\" TYPES : Dict [ str , str ] = { \":art:\" : \"\" , # when improving the format/structure of the code \":racehorse:\" : \"\" , # when improving performance \":non-potable_water:\" : \"\" , # when plugging memory leaks \":memo:\" : \"\" , # when writing docs \":penguin:\" : \"\" , # when fixing something on Linux \":apple:\" : \"\" , # when fixing something on Mac OS \":checkered_flag:\" : \"\" , # when fixing something on Windows \":bug:\" : \"\" , # when fixing a bug \":fire:\" : \"\" , # when removing code or files \":green_heart:\" : \"\" , # when fixing the CI build \":white_check_mark:\" : \"\" , # when adding tests \":lock:\" : \"\" , # when dealing with security \":arrow_up:\" : \"\" , # when upgrading dependencies \":arrow_down:\" : \"\" , # when downgrading dependencies \":shirt:\" : \"\" , # when removing linter warnings } BasicStyle \u00a4 Bases: CommitStyle Basic commit message style. Source code in git_changelog/commit.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class BasicStyle ( CommitStyle ): \"\"\"Basic commit message style.\"\"\" TYPES : Dict [ str , str ] = { \"add\" : \"Added\" , \"fix\" : \"Fixed\" , \"change\" : \"Changed\" , \"remove\" : \"Removed\" , \"merge\" : \"Merged\" , \"doc\" : \"Documented\" , } TYPE_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))\" % \"|\" . join ( TYPES . keys ()), re . I ) # noqa: WPS323 BREAK_REGEX : Pattern = re . compile ( r \"^break(s|ing changes?)?[ :].+$\" , re . I | re . MULTILINE ) DEFAULT_RENDER = [ TYPES [ \"add\" ], TYPES [ \"fix\" ], TYPES [ \"change\" ], TYPES [ \"remove\" ]] def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) commit_type = self . parse_type ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) is_minor = not is_major and self . is_minor ( commit_type ) is_patch = not any (( is_major , is_minor )) return { \"type\" : commit_type , \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch } def parse_type ( self , commit_subject : str ) -> str : \"\"\"Parse the type of the commit given its subject. Arguments: commit_subject: The commit message subject. Returns: The commit type. \"\"\" type_match = self . TYPE_REGEX . match ( commit_subject ) if type_match : return self . TYPES . get ( type_match . groupdict ()[ \"type\" ] . lower (), \"\" ) return \"\" def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"add\" ] def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message )) is_major ( commit_message ) \u00a4 Tell if this commit is worth a major bump. Parameters: Name Type Description Default commit_message str The commit message. required Returns: Type Description bool Whether it's a major commit. Source code in git_changelog/commit.py 173 174 175 176 177 178 179 180 181 182 def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message )) is_minor ( commit_type ) \u00a4 Tell if this commit is worth a minor bump. Parameters: Name Type Description Default commit_type str The commit type. required Returns: Type Description bool Whether it's a minor commit. Source code in git_changelog/commit.py 162 163 164 165 166 167 168 169 170 171 def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"add\" ] parse_type ( commit_subject ) \u00a4 Parse the type of the commit given its subject. Parameters: Name Type Description Default commit_subject str The commit message subject. required Returns: Type Description str The commit type. Source code in git_changelog/commit.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def parse_type ( self , commit_subject : str ) -> str : \"\"\"Parse the type of the commit given its subject. Arguments: commit_subject: The commit message subject. Returns: The commit type. \"\"\" type_match = self . TYPE_REGEX . match ( commit_subject ) if type_match : return self . TYPES . get ( type_match . groupdict ()[ \"type\" ] . lower (), \"\" ) return \"\" Commit \u00a4 A class to represent a commit. Source code in git_changelog/commit.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Commit : \"\"\"A class to represent a commit.\"\"\" def __init__ ( self , commit_hash : str , author_name : str = \"\" , author_email : str = \"\" , author_date : str = \"\" , committer_name : str = \"\" , committer_email : str = \"\" , committer_date : str = \"\" , refs : str = \"\" , subject : str = \"\" , body : List [ str ] = None , url : str = \"\" , ): \"\"\" Initialization method. Arguments: commit_hash: The commit hash. author_name: The author name. author_email: The author email. author_date: The authoring date. committer_name: The committer name. committer_email: The committer email. committer_date: The committing date. refs: The commit refs. subject: The commit message subject. body: The commit message body. url: The commit URL. \"\"\" self . hash : str = commit_hash self . author_name : str = author_name self . author_email : str = author_email self . author_date : datetime = datetime . utcfromtimestamp ( float ( author_date )) self . committer_name : str = committer_name self . committer_email : str = committer_email self . committer_date : datetime = datetime . utcfromtimestamp ( float ( committer_date )) self . subject : str = subject self . body : List [ str ] = body or [] self . url : str = url tag = \"\" for ref in refs . split ( \",\" ): ref = ref . strip () if ref . startswith ( \"tag: \" ): tag = ref . replace ( \"tag: \" , \"\" ) break self . tag : str = tag self . version : str = tag self . text_refs : Dict [ str , List [ Ref ]] = {} self . style : Dict [ str , Any ] = {} def update_with_style ( self , style : \"CommitStyle\" ) -> None : \"\"\" Apply the style-parsed data to this commit. Arguments: style: The style to use. \"\"\" self . style . update ( style . parse_commit ( self )) def update_with_provider ( self , provider : ProviderRefParser ) -> None : \"\"\" Apply the provider-parsed data to this commit. Arguments: provider: The provider to use. \"\"\" # set the commit url based on provider # FIXME: hardcoded 'commits' if \"commits\" in provider . REF : self . url = provider . build_ref_url ( \"commits\" , { \"ref\" : self . hash }) else : # use default \"commit\" url (could be wrong) self . url = f \" { provider . url } / { provider . namespace } / { provider . project } /commit/ { self . hash } \" # build commit text references from its subject and body for ref_type in provider . REF . keys (): self . text_refs [ ref_type ] = provider . get_refs ( ref_type , \" \\n \" . join ([ self . subject ] + self . body )) if \"issues\" in self . text_refs : self . text_refs [ \"issues_not_in_subject\" ] = [] for issue in self . text_refs [ \"issues\" ]: if issue . ref not in self . subject : self . text_refs [ \"issues_not_in_subject\" ] . append ( issue ) __init__ ( commit_hash , author_name = '' , author_email = '' , author_date = '' , committer_name = '' , committer_email = '' , committer_date = '' , refs = '' , subject = '' , body = None , url = '' ) \u00a4 Initialization method. Parameters: Name Type Description Default commit_hash str The commit hash. required author_name str The author name. '' author_email str The author email. '' author_date str The authoring date. '' committer_name str The committer name. '' committer_email str The committer email. '' committer_date str The committing date. '' refs str The commit refs. '' subject str The commit message subject. '' body List [ str ] The commit message body. None url str The commit URL. '' Source code in git_changelog/commit.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , commit_hash : str , author_name : str = \"\" , author_email : str = \"\" , author_date : str = \"\" , committer_name : str = \"\" , committer_email : str = \"\" , committer_date : str = \"\" , refs : str = \"\" , subject : str = \"\" , body : List [ str ] = None , url : str = \"\" , ): \"\"\" Initialization method. Arguments: commit_hash: The commit hash. author_name: The author name. author_email: The author email. author_date: The authoring date. committer_name: The committer name. committer_email: The committer email. committer_date: The committing date. refs: The commit refs. subject: The commit message subject. body: The commit message body. url: The commit URL. \"\"\" self . hash : str = commit_hash self . author_name : str = author_name self . author_email : str = author_email self . author_date : datetime = datetime . utcfromtimestamp ( float ( author_date )) self . committer_name : str = committer_name self . committer_email : str = committer_email self . committer_date : datetime = datetime . utcfromtimestamp ( float ( committer_date )) self . subject : str = subject self . body : List [ str ] = body or [] self . url : str = url tag = \"\" for ref in refs . split ( \",\" ): ref = ref . strip () if ref . startswith ( \"tag: \" ): tag = ref . replace ( \"tag: \" , \"\" ) break self . tag : str = tag self . version : str = tag self . text_refs : Dict [ str , List [ Ref ]] = {} self . style : Dict [ str , Any ] = {} update_with_provider ( provider ) \u00a4 Apply the provider-parsed data to this commit. Parameters: Name Type Description Default provider ProviderRefParser The provider to use. required Source code in git_changelog/commit.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def update_with_provider ( self , provider : ProviderRefParser ) -> None : \"\"\" Apply the provider-parsed data to this commit. Arguments: provider: The provider to use. \"\"\" # set the commit url based on provider # FIXME: hardcoded 'commits' if \"commits\" in provider . REF : self . url = provider . build_ref_url ( \"commits\" , { \"ref\" : self . hash }) else : # use default \"commit\" url (could be wrong) self . url = f \" { provider . url } / { provider . namespace } / { provider . project } /commit/ { self . hash } \" # build commit text references from its subject and body for ref_type in provider . REF . keys (): self . text_refs [ ref_type ] = provider . get_refs ( ref_type , \" \\n \" . join ([ self . subject ] + self . body )) if \"issues\" in self . text_refs : self . text_refs [ \"issues_not_in_subject\" ] = [] for issue in self . text_refs [ \"issues\" ]: if issue . ref not in self . subject : self . text_refs [ \"issues_not_in_subject\" ] . append ( issue ) update_with_style ( style ) \u00a4 Apply the style-parsed data to this commit. Parameters: Name Type Description Default style CommitStyle The style to use. required Source code in git_changelog/commit.py 67 68 69 70 71 72 73 74 def update_with_style ( self , style : \"CommitStyle\" ) -> None : \"\"\" Apply the style-parsed data to this commit. Arguments: style: The style to use. \"\"\" self . style . update ( style . parse_commit ( self )) CommitStyle \u00a4 Bases: ABC A base class for a style of commit messages. Source code in git_changelog/commit.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class CommitStyle ( ABC ): \"\"\"A base class for a style of commit messages.\"\"\" TYPES : Dict [ str , str ] TYPE_REGEX : Pattern BREAK_REGEX : Pattern @abstractmethod def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: \"\"\" Parse the commit to extract information. Arguments: commit: The commit to parse. Returns: A dictionary containing the parsed data. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError parse_commit ( commit ) abstractmethod \u00a4 Parse the commit to extract information. Parameters: Name Type Description Default commit Commit The commit to parse. required Returns: Type Description Dict [ str , Union [ str , bool ]] A dictionary containing the parsed data. Source code in git_changelog/commit.py 109 110 111 112 113 114 115 116 117 118 119 120 @abstractmethod def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: \"\"\" Parse the commit to extract information. Arguments: commit: The commit to parse. Returns: A dictionary containing the parsed data. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError ConventionalCommitStyle \u00a4 Bases: AngularStyle Conventional commit message style. Source code in git_changelog/commit.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 class ConventionalCommitStyle ( AngularStyle ): \"\"\"Conventional commit message style.\"\"\" TYPES : Dict [ str , str ] = AngularStyle . TYPES SUBJECT_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))(?:\\((?P<scope>.+)\\))?(?P<breaking>!)?: (?P<subject>.+)$\" # noqa: WPS323 (%) % ( \"|\" . join ( TYPES . keys ())) ) def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) subject = self . parse_subject ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) or subject . get ( \"breaking\" ) == \"!\" is_minor = not is_major and self . is_minor ( subject [ \"type\" ]) is_patch = not any (( is_major , is_minor )) return { \"type\" : subject [ \"type\" ], \"scope\" : subject [ \"scope\" ], \"subject\" : subject [ \"subject\" ], \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch , }","title":"commit"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularStyle","text":"Bases: CommitStyle Angular commit message style. Source code in git_changelog/commit.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class AngularStyle ( CommitStyle ): \"\"\"Angular commit message style.\"\"\" TYPES : Dict [ str , str ] = { \"build\" : \"Build\" , \"ci\" : \"CI\" , \"perf\" : \"Performance Improvements\" , \"feat\" : \"Features\" , \"fix\" : \"Bug Fixes\" , \"revert\" : \"Reverts\" , \"docs\" : \"Docs\" , \"style\" : \"Style\" , \"refactor\" : \"Code Refactoring\" , \"test\" : \"Tests\" , \"chore\" : \"Chore\" , } SUBJECT_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))(?:\\((?P<scope>.+)\\))?: (?P<subject>.+)$\" % ( \"|\" . join ( TYPES . keys ())) # noqa: WPS323 (%) ) BREAK_REGEX : Pattern = re . compile ( r \"^break(s|ing changes?)?[ :].+$\" , re . I | re . MULTILINE ) DEFAULT_RENDER = [ TYPES [ \"feat\" ], TYPES [ \"fix\" ], TYPES [ \"revert\" ], TYPES [ \"refactor\" ], TYPES [ \"perf\" ]] def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) subject = self . parse_subject ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) is_minor = not is_major and self . is_minor ( subject [ \"type\" ]) is_patch = not any (( is_major , is_minor )) return { \"type\" : subject [ \"type\" ], \"scope\" : subject [ \"scope\" ], \"subject\" : subject [ \"subject\" ], \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch , } def parse_subject ( self , commit_subject : str ) -> Dict [ str , str ]: \"\"\"Parse the subject of the commit (`<type>[(scope)]: Subject`). Arguments: commit_subject: The commit message subject. Returns: The parsed data. \"\"\" subject_match = self . SUBJECT_REGEX . match ( commit_subject ) if subject_match : dct = subject_match . groupdict () dct [ \"type\" ] = self . TYPES [ dct [ \"type\" ]] return dct return { \"type\" : \"\" , \"scope\" : \"\" , \"subject\" : commit_subject } def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"feat\" ] def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message ))","title":"AngularStyle"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularStyle.is_major","text":"Tell if this commit is worth a major bump. Parameters: Name Type Description Default commit_message str The commit message. required Returns: Type Description bool Whether it's a major commit. Source code in git_changelog/commit.py 250 251 252 253 254 255 256 257 258 259 def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message ))","title":"is_major()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularStyle.is_minor","text":"Tell if this commit is worth a minor bump. Parameters: Name Type Description Default commit_type str The commit type. required Returns: Type Description bool Whether it's a minor commit. Source code in git_changelog/commit.py 239 240 241 242 243 244 245 246 247 248 def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"feat\" ]","title":"is_minor()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AngularStyle.parse_subject","text":"Parse the subject of the commit ( <type>[(scope)]: Subject ). Parameters: Name Type Description Default commit_subject str The commit message subject. required Returns: Type Description Dict [ str , str ] The parsed data. Source code in git_changelog/commit.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def parse_subject ( self , commit_subject : str ) -> Dict [ str , str ]: \"\"\"Parse the subject of the commit (`<type>[(scope)]: Subject`). Arguments: commit_subject: The commit message subject. Returns: The parsed data. \"\"\" subject_match = self . SUBJECT_REGEX . match ( commit_subject ) if subject_match : dct = subject_match . groupdict () dct [ \"type\" ] = self . TYPES [ dct [ \"type\" ]] return dct return { \"type\" : \"\" , \"scope\" : \"\" , \"subject\" : commit_subject }","title":"parse_subject()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.AtomStyle","text":"Bases: CommitStyle Atom commit message style. Source code in git_changelog/commit.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 class AtomStyle ( CommitStyle ): \"\"\"Atom commit message style.\"\"\" TYPES : Dict [ str , str ] = { \":art:\" : \"\" , # when improving the format/structure of the code \":racehorse:\" : \"\" , # when improving performance \":non-potable_water:\" : \"\" , # when plugging memory leaks \":memo:\" : \"\" , # when writing docs \":penguin:\" : \"\" , # when fixing something on Linux \":apple:\" : \"\" , # when fixing something on Mac OS \":checkered_flag:\" : \"\" , # when fixing something on Windows \":bug:\" : \"\" , # when fixing a bug \":fire:\" : \"\" , # when removing code or files \":green_heart:\" : \"\" , # when fixing the CI build \":white_check_mark:\" : \"\" , # when adding tests \":lock:\" : \"\" , # when dealing with security \":arrow_up:\" : \"\" , # when upgrading dependencies \":arrow_down:\" : \"\" , # when downgrading dependencies \":shirt:\" : \"\" , # when removing linter warnings }","title":"AtomStyle"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicStyle","text":"Bases: CommitStyle Basic commit message style. Source code in git_changelog/commit.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class BasicStyle ( CommitStyle ): \"\"\"Basic commit message style.\"\"\" TYPES : Dict [ str , str ] = { \"add\" : \"Added\" , \"fix\" : \"Fixed\" , \"change\" : \"Changed\" , \"remove\" : \"Removed\" , \"merge\" : \"Merged\" , \"doc\" : \"Documented\" , } TYPE_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))\" % \"|\" . join ( TYPES . keys ()), re . I ) # noqa: WPS323 BREAK_REGEX : Pattern = re . compile ( r \"^break(s|ing changes?)?[ :].+$\" , re . I | re . MULTILINE ) DEFAULT_RENDER = [ TYPES [ \"add\" ], TYPES [ \"fix\" ], TYPES [ \"change\" ], TYPES [ \"remove\" ]] def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) commit_type = self . parse_type ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) is_minor = not is_major and self . is_minor ( commit_type ) is_patch = not any (( is_major , is_minor )) return { \"type\" : commit_type , \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch } def parse_type ( self , commit_subject : str ) -> str : \"\"\"Parse the type of the commit given its subject. Arguments: commit_subject: The commit message subject. Returns: The commit type. \"\"\" type_match = self . TYPE_REGEX . match ( commit_subject ) if type_match : return self . TYPES . get ( type_match . groupdict ()[ \"type\" ] . lower (), \"\" ) return \"\" def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"add\" ] def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message ))","title":"BasicStyle"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicStyle.is_major","text":"Tell if this commit is worth a major bump. Parameters: Name Type Description Default commit_message str The commit message. required Returns: Type Description bool Whether it's a major commit. Source code in git_changelog/commit.py 173 174 175 176 177 178 179 180 181 182 def is_major ( self , commit_message : str ) -> bool : \"\"\"Tell if this commit is worth a major bump. Arguments: commit_message: The commit message. Returns: Whether it's a major commit. \"\"\" return bool ( self . BREAK_REGEX . search ( commit_message ))","title":"is_major()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicStyle.is_minor","text":"Tell if this commit is worth a minor bump. Parameters: Name Type Description Default commit_type str The commit type. required Returns: Type Description bool Whether it's a minor commit. Source code in git_changelog/commit.py 162 163 164 165 166 167 168 169 170 171 def is_minor ( self , commit_type : str ) -> bool : \"\"\"Tell if this commit is worth a minor bump. Arguments: commit_type: The commit type. Returns: Whether it's a minor commit. \"\"\" return commit_type == self . TYPES [ \"add\" ]","title":"is_minor()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.BasicStyle.parse_type","text":"Parse the type of the commit given its subject. Parameters: Name Type Description Default commit_subject str The commit message subject. required Returns: Type Description str The commit type. Source code in git_changelog/commit.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def parse_type ( self , commit_subject : str ) -> str : \"\"\"Parse the type of the commit given its subject. Arguments: commit_subject: The commit message subject. Returns: The commit type. \"\"\" type_match = self . TYPE_REGEX . match ( commit_subject ) if type_match : return self . TYPES . get ( type_match . groupdict ()[ \"type\" ] . lower (), \"\" ) return \"\"","title":"parse_type()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit","text":"A class to represent a commit. Source code in git_changelog/commit.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Commit : \"\"\"A class to represent a commit.\"\"\" def __init__ ( self , commit_hash : str , author_name : str = \"\" , author_email : str = \"\" , author_date : str = \"\" , committer_name : str = \"\" , committer_email : str = \"\" , committer_date : str = \"\" , refs : str = \"\" , subject : str = \"\" , body : List [ str ] = None , url : str = \"\" , ): \"\"\" Initialization method. Arguments: commit_hash: The commit hash. author_name: The author name. author_email: The author email. author_date: The authoring date. committer_name: The committer name. committer_email: The committer email. committer_date: The committing date. refs: The commit refs. subject: The commit message subject. body: The commit message body. url: The commit URL. \"\"\" self . hash : str = commit_hash self . author_name : str = author_name self . author_email : str = author_email self . author_date : datetime = datetime . utcfromtimestamp ( float ( author_date )) self . committer_name : str = committer_name self . committer_email : str = committer_email self . committer_date : datetime = datetime . utcfromtimestamp ( float ( committer_date )) self . subject : str = subject self . body : List [ str ] = body or [] self . url : str = url tag = \"\" for ref in refs . split ( \",\" ): ref = ref . strip () if ref . startswith ( \"tag: \" ): tag = ref . replace ( \"tag: \" , \"\" ) break self . tag : str = tag self . version : str = tag self . text_refs : Dict [ str , List [ Ref ]] = {} self . style : Dict [ str , Any ] = {} def update_with_style ( self , style : \"CommitStyle\" ) -> None : \"\"\" Apply the style-parsed data to this commit. Arguments: style: The style to use. \"\"\" self . style . update ( style . parse_commit ( self )) def update_with_provider ( self , provider : ProviderRefParser ) -> None : \"\"\" Apply the provider-parsed data to this commit. Arguments: provider: The provider to use. \"\"\" # set the commit url based on provider # FIXME: hardcoded 'commits' if \"commits\" in provider . REF : self . url = provider . build_ref_url ( \"commits\" , { \"ref\" : self . hash }) else : # use default \"commit\" url (could be wrong) self . url = f \" { provider . url } / { provider . namespace } / { provider . project } /commit/ { self . hash } \" # build commit text references from its subject and body for ref_type in provider . REF . keys (): self . text_refs [ ref_type ] = provider . get_refs ( ref_type , \" \\n \" . join ([ self . subject ] + self . body )) if \"issues\" in self . text_refs : self . text_refs [ \"issues_not_in_subject\" ] = [] for issue in self . text_refs [ \"issues\" ]: if issue . ref not in self . subject : self . text_refs [ \"issues_not_in_subject\" ] . append ( issue )","title":"Commit"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.__init__","text":"Initialization method. Parameters: Name Type Description Default commit_hash str The commit hash. required author_name str The author name. '' author_email str The author email. '' author_date str The authoring date. '' committer_name str The committer name. '' committer_email str The committer email. '' committer_date str The committing date. '' refs str The commit refs. '' subject str The commit message subject. '' body List [ str ] The commit message body. None url str The commit URL. '' Source code in git_changelog/commit.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , commit_hash : str , author_name : str = \"\" , author_email : str = \"\" , author_date : str = \"\" , committer_name : str = \"\" , committer_email : str = \"\" , committer_date : str = \"\" , refs : str = \"\" , subject : str = \"\" , body : List [ str ] = None , url : str = \"\" , ): \"\"\" Initialization method. Arguments: commit_hash: The commit hash. author_name: The author name. author_email: The author email. author_date: The authoring date. committer_name: The committer name. committer_email: The committer email. committer_date: The committing date. refs: The commit refs. subject: The commit message subject. body: The commit message body. url: The commit URL. \"\"\" self . hash : str = commit_hash self . author_name : str = author_name self . author_email : str = author_email self . author_date : datetime = datetime . utcfromtimestamp ( float ( author_date )) self . committer_name : str = committer_name self . committer_email : str = committer_email self . committer_date : datetime = datetime . utcfromtimestamp ( float ( committer_date )) self . subject : str = subject self . body : List [ str ] = body or [] self . url : str = url tag = \"\" for ref in refs . split ( \",\" ): ref = ref . strip () if ref . startswith ( \"tag: \" ): tag = ref . replace ( \"tag: \" , \"\" ) break self . tag : str = tag self . version : str = tag self . text_refs : Dict [ str , List [ Ref ]] = {} self . style : Dict [ str , Any ] = {}","title":"__init__()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_provider","text":"Apply the provider-parsed data to this commit. Parameters: Name Type Description Default provider ProviderRefParser The provider to use. required Source code in git_changelog/commit.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def update_with_provider ( self , provider : ProviderRefParser ) -> None : \"\"\" Apply the provider-parsed data to this commit. Arguments: provider: The provider to use. \"\"\" # set the commit url based on provider # FIXME: hardcoded 'commits' if \"commits\" in provider . REF : self . url = provider . build_ref_url ( \"commits\" , { \"ref\" : self . hash }) else : # use default \"commit\" url (could be wrong) self . url = f \" { provider . url } / { provider . namespace } / { provider . project } /commit/ { self . hash } \" # build commit text references from its subject and body for ref_type in provider . REF . keys (): self . text_refs [ ref_type ] = provider . get_refs ( ref_type , \" \\n \" . join ([ self . subject ] + self . body )) if \"issues\" in self . text_refs : self . text_refs [ \"issues_not_in_subject\" ] = [] for issue in self . text_refs [ \"issues\" ]: if issue . ref not in self . subject : self . text_refs [ \"issues_not_in_subject\" ] . append ( issue )","title":"update_with_provider()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.Commit.update_with_style","text":"Apply the style-parsed data to this commit. Parameters: Name Type Description Default style CommitStyle The style to use. required Source code in git_changelog/commit.py 67 68 69 70 71 72 73 74 def update_with_style ( self , style : \"CommitStyle\" ) -> None : \"\"\" Apply the style-parsed data to this commit. Arguments: style: The style to use. \"\"\" self . style . update ( style . parse_commit ( self ))","title":"update_with_style()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitStyle","text":"Bases: ABC A base class for a style of commit messages. Source code in git_changelog/commit.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class CommitStyle ( ABC ): \"\"\"A base class for a style of commit messages.\"\"\" TYPES : Dict [ str , str ] TYPE_REGEX : Pattern BREAK_REGEX : Pattern @abstractmethod def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: \"\"\" Parse the commit to extract information. Arguments: commit: The commit to parse. Returns: A dictionary containing the parsed data. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"CommitStyle"},{"location":"reference/git_changelog/commit/#git_changelog.commit.CommitStyle.parse_commit","text":"Parse the commit to extract information. Parameters: Name Type Description Default commit Commit The commit to parse. required Returns: Type Description Dict [ str , Union [ str , bool ]] A dictionary containing the parsed data. Source code in git_changelog/commit.py 109 110 111 112 113 114 115 116 117 118 119 120 @abstractmethod def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: \"\"\" Parse the commit to extract information. Arguments: commit: The commit to parse. Returns: A dictionary containing the parsed data. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"parse_commit()"},{"location":"reference/git_changelog/commit/#git_changelog.commit.ConventionalCommitStyle","text":"Bases: AngularStyle Conventional commit message style. Source code in git_changelog/commit.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 class ConventionalCommitStyle ( AngularStyle ): \"\"\"Conventional commit message style.\"\"\" TYPES : Dict [ str , str ] = AngularStyle . TYPES SUBJECT_REGEX : Pattern = re . compile ( r \"^(?P<type>( %s ))(?:\\((?P<scope>.+)\\))?(?P<breaking>!)?: (?P<subject>.+)$\" # noqa: WPS323 (%) % ( \"|\" . join ( TYPES . keys ())) ) def parse_commit ( self , commit : Commit ) -> Dict [ str , Union [ str , bool ]]: # noqa: D102 (use parent docstring) subject = self . parse_subject ( commit . subject ) message = \" \\n \" . join ([ commit . subject ] + commit . body ) is_major = self . is_major ( message ) or subject . get ( \"breaking\" ) == \"!\" is_minor = not is_major and self . is_minor ( subject [ \"type\" ]) is_patch = not any (( is_major , is_minor )) return { \"type\" : subject [ \"type\" ], \"scope\" : subject [ \"scope\" ], \"subject\" : subject [ \"subject\" ], \"is_major\" : is_major , \"is_minor\" : is_minor , \"is_patch\" : is_patch , }","title":"ConventionalCommitStyle"},{"location":"reference/git_changelog/providers/","text":"Module containing the parsing utilities for git providers. GitHub \u00a4 Bases: ProviderRefParser A parser for the GitHub references. Source code in git_changelog/providers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class GitHub ( ProviderRefParser ): \"\"\"A parser for the GitHub references.\"\"\" url : str = \"https://github.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /releases/tag/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" }) __init__ ( namespace , project , url = url ) \u00a4 Initialization method. Parameters: Name Type Description Default namespace str The GitHub namespace. required project str The GitHub project. required url str The GitHub URL. url Source code in git_changelog/providers.py 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) GitLab \u00a4 Bases: ProviderRefParser A parser for the GitLab references. Source code in git_changelog/providers.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class GitLab ( ProviderRefParser ): \"\"\"A parser for the GitLab references.\"\"\" url : str = \"https://gitlab.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /tags/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"merge_requests\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"!\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /merge_requests/ {ref} \" , ), \"snippets\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"\\$\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /snippets/ {ref} \" , ), \"labels_ids\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , # no label_id param? ), \"labels_one_word\" : RefDef ( regex = re . compile ( # also matches label IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"labels_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"milestones_ids\" : RefDef ( regex = re . compile ( # also matches milestones IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones/ {ref} \" , ), \"milestones_one_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"milestones_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project if ref_type . startswith ( \"label\" ): match_dict [ \"ref\" ] = match_dict [ \"ref\" ] . replace ( '\"' , \"\" ) . replace ( \" \" , \"+\" ) return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" }) __init__ ( namespace , project , url = url ) \u00a4 Initialization method. Parameters: Name Type Description Default namespace str The GitLab namespace. required project str The GitLab project. required url str The GitLab URL. url Source code in git_changelog/providers.py 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) ProviderRefParser \u00a4 Bases: ABC A base class for specific providers reference parsers. Source code in git_changelog/providers.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class ProviderRefParser ( ABC ): \"\"\"A base class for specific providers reference parsers.\"\"\" url : str namespace : str project : str REF : Dict [ str , RefDef ] = {} def get_refs ( self , ref_type : str , text : str ) -> List [ Ref ]: \"\"\" Find all references in the given text. Arguments: ref_type: The reference type. text: The text in which to search references. Returns: A list of references (instances of [Ref][git_changelog.providers.Ref]). \"\"\" return [ Ref ( ref = match . group () . strip (), url = self . build_ref_url ( ref_type , match . groupdict ())) for match in self . parse_refs ( ref_type , text ) ] def parse_refs ( self , ref_type : str , text : str ) -> List [ Match ]: \"\"\" Parse references in the given text. Arguments: ref_type: The reference type. text: The text to parse. Returns: A list of regular expressions matches. \"\"\" if ref_type not in self . REF : refs = [ key for key in self . REF . keys () if key . startswith ( ref_type )] return [ match for ref in refs for match in self . REF [ ref ] . regex . finditer ( text )] return list ( self . REF [ ref_type ] . regex . finditer ( text )) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : \"\"\" Build the URL for a reference type and a dictionary of matched groups. Arguments: ref_type: The reference type. match_dict: The matched groups. Returns: The built URL. \"\"\" return self . REF [ ref_type ] . url_string . format ( ** match_dict ) @abstractmethod def get_tag_url ( self , tag : str ) -> str : \"\"\" Get the URL for a git tag. Arguments: tag: The git tag. Returns: The tag URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError @abstractmethod def get_compare_url ( self , base : str , target : str ) -> str : \"\"\" Get the URL for a tag comparison. Arguments: base: The base tag. target: The target tag. Returns: The comparison URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError build_ref_url ( ref_type , match_dict ) \u00a4 Build the URL for a reference type and a dictionary of matched groups. Parameters: Name Type Description Default ref_type str The reference type. required match_dict Dict [ str , str ] The matched groups. required Returns: Type Description str The built URL. Source code in git_changelog/providers.py 95 96 97 98 99 100 101 102 103 104 105 106 def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : \"\"\" Build the URL for a reference type and a dictionary of matched groups. Arguments: ref_type: The reference type. match_dict: The matched groups. Returns: The built URL. \"\"\" return self . REF [ ref_type ] . url_string . format ( ** match_dict ) get_compare_url ( base , target ) abstractmethod \u00a4 Get the URL for a tag comparison. Parameters: Name Type Description Default base str The base tag. required target str The target tag. required Returns: Type Description str The comparison URL. Source code in git_changelog/providers.py 121 122 123 124 125 126 127 128 129 130 131 132 133 @abstractmethod def get_compare_url ( self , base : str , target : str ) -> str : \"\"\" Get the URL for a tag comparison. Arguments: base: The base tag. target: The target tag. Returns: The comparison URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError get_refs ( ref_type , text ) \u00a4 Find all references in the given text. Parameters: Name Type Description Default ref_type str The reference type. required text str The text in which to search references. required Returns: Type Description List [ Ref ] A list of references (instances of Ref ). Source code in git_changelog/providers.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def get_refs ( self , ref_type : str , text : str ) -> List [ Ref ]: \"\"\" Find all references in the given text. Arguments: ref_type: The reference type. text: The text in which to search references. Returns: A list of references (instances of [Ref][git_changelog.providers.Ref]). \"\"\" return [ Ref ( ref = match . group () . strip (), url = self . build_ref_url ( ref_type , match . groupdict ())) for match in self . parse_refs ( ref_type , text ) ] get_tag_url ( tag ) abstractmethod \u00a4 Get the URL for a git tag. Parameters: Name Type Description Default tag str The git tag. required Returns: Type Description str The tag URL. Source code in git_changelog/providers.py 108 109 110 111 112 113 114 115 116 117 118 119 @abstractmethod def get_tag_url ( self , tag : str ) -> str : \"\"\" Get the URL for a git tag. Arguments: tag: The git tag. Returns: The tag URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError parse_refs ( ref_type , text ) \u00a4 Parse references in the given text. Parameters: Name Type Description Default ref_type str The reference type. required text str The text to parse. required Returns: Type Description List [ Match ] A list of regular expressions matches. Source code in git_changelog/providers.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def parse_refs ( self , ref_type : str , text : str ) -> List [ Match ]: \"\"\" Parse references in the given text. Arguments: ref_type: The reference type. text: The text to parse. Returns: A list of regular expressions matches. \"\"\" if ref_type not in self . REF : refs = [ key for key in self . REF . keys () if key . startswith ( ref_type )] return [ match for ref in refs for match in self . REF [ ref ] . regex . finditer ( text )] return list ( self . REF [ ref_type ] . regex . finditer ( text )) Ref \u00a4 A class to represent a reference and its URL. Source code in git_changelog/providers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Ref : \"\"\"A class to represent a reference and its URL.\"\"\" def __init__ ( self , ref : str , url : str ) -> None : \"\"\" Initialization method. Arguments: ref: The reference text. url: The reference URL. \"\"\" self . ref : str = ref self . url : str = url def __str__ ( self ): return self . ref + \": \" + self . url __init__ ( ref , url ) \u00a4 Initialization method. Parameters: Name Type Description Default ref str The reference text. required url str The reference URL. required Source code in git_changelog/providers.py 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , ref : str , url : str ) -> None : \"\"\" Initialization method. Arguments: ref: The reference text. url: The reference URL. \"\"\" self . ref : str = ref self . url : str = url RefDef \u00a4 A class to store a reference regular expression and URL building string. Source code in git_changelog/providers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 class RefDef : \"\"\"A class to store a reference regular expression and URL building string.\"\"\" def __init__ ( self , regex : Pattern , url_string : str ): \"\"\" Initialization method. Arguments: regex: The regular expression to match the reference. url_string: The URL string to format using matched groups. \"\"\" self . regex = regex self . url_string = url_string __init__ ( regex , url_string ) \u00a4 Initialization method. Parameters: Name Type Description Default regex Pattern The regular expression to match the reference. required url_string str The URL string to format using matched groups. required Source code in git_changelog/providers.py 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , regex : Pattern , url_string : str ): \"\"\" Initialization method. Arguments: regex: The regular expression to match the reference. url_string: The URL string to format using matched groups. \"\"\" self . regex = regex self . url_string = url_string RefRe \u00a4 An enum helper to store parts of regular expressions for references. Source code in git_changelog/providers.py 8 9 10 11 12 13 14 15 16 17 18 19 class RefRe : \"\"\"An enum helper to store parts of regular expressions for references.\"\"\" BB = r \"(?:^|[\\s,])\" # blank before BA = r \"(?:[\\s,]|$)\" # blank after NP = r \"(?:(?P<namespace>[-\\w]+)/)?(?P<project>[-\\w]+)\" # namespace and project ID = r \" {symbol} (?P<ref>[1-9]\\d*)\" ONE_WORD = r \" {symbol} (?P<ref>\\w*[-a-z_ ][-\\w]*)\" MULTI_WORD = r ' {symbol} (?P<ref>\"\\w[- \\w]*\")' COMMIT = r \"(?P<ref>[0-9a-f]{{ {min} , {max} }})\" COMMIT_RANGE = r \"(?P<ref>[0-9a-f]{{ {min} , {max} }}\\.\\.\\.[0-9a-f]{{ {min} , {max} }})\" MENTION = r \"@(?P<ref>\\w[-\\w]*)\"","title":"providers"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub","text":"Bases: ProviderRefParser A parser for the GitHub references. Source code in git_changelog/providers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class GitHub ( ProviderRefParser ): \"\"\"A parser for the GitHub references.\"\"\" url : str = \"https://github.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /releases/tag/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" })","title":"GitHub"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitHub.__init__","text":"Initialization method. Parameters: Name Type Description Default namespace str The GitHub namespace. required project str The GitHub project. required url str The GitHub URL. url Source code in git_changelog/providers.py 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitHub namespace. project: The GitHub project. url: The GitHub URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default)","title":"__init__()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab","text":"Bases: ProviderRefParser A parser for the GitLab references. Source code in git_changelog/providers.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class GitLab ( ProviderRefParser ): \"\"\"A parser for the GitLab references.\"\"\" url : str = \"https://gitlab.com\" project_url : str = \" {base_url} / {namespace} / {project} \" tag_url : str = \" {base_url} / {namespace} / {project} /tags/ {ref} \" commit_min_length = 8 commit_max_length = 40 REF : Dict [ str , RefDef ] = { \"issues\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = \"#\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues/ {ref} \" , ), \"merge_requests\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"!\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /merge_requests/ {ref} \" , ), \"snippets\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"\\$\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /snippets/ {ref} \" , ), \"labels_ids\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , # no label_id param? ), \"labels_one_word\" : RefDef ( regex = re . compile ( # also matches label IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"labels_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"~\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /issues?label_name[]= {ref} \" , ), \"milestones_ids\" : RefDef ( regex = re . compile ( # also matches milestones IDs RefRe . BB + RefRe . NP + \"?\" + RefRe . ID . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones/ {ref} \" , ), \"milestones_one_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . ONE_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"milestones_multi_word\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . NP + \"?\" + RefRe . MULTI_WORD . format ( symbol = r \"%\" ), re . I ), url_string = \" {base_url} / {namespace} / {project} /milestones\" , # cannot guess ID ), \"commits\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit}{ba} \" . format ( np = RefRe . NP , commit = RefRe . COMMIT . format ( min = commit_min_length , max = commit_max_length ), ba = RefRe . BA ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /commit/ {ref} \" , ), \"commits_ranges\" : RefDef ( regex = re . compile ( RefRe . BB + r \"(?: {np} @)? {commit_range} \" . format ( np = RefRe . NP , commit_range = RefRe . COMMIT_RANGE . format ( min = commit_min_length , max = commit_max_length ) ), re . I , ), url_string = \" {base_url} / {namespace} / {project} /compare/ {ref} \" , ), \"mentions\" : RefDef ( regex = re . compile ( RefRe . BB + RefRe . MENTION , re . I ), url_string = \" {base_url} / {ref} \" ), } def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : # noqa: D102 (use parent docstring) match_dict [ \"base_url\" ] = self . url if not match_dict . get ( \"namespace\" ): match_dict [ \"namespace\" ] = self . namespace if not match_dict . get ( \"project\" ): match_dict [ \"project\" ] = self . project if ref_type . startswith ( \"label\" ): match_dict [ \"ref\" ] = match_dict [ \"ref\" ] . replace ( '\"' , \"\" ) . replace ( \" \" , \"+\" ) return super () . build_ref_url ( ref_type , match_dict ) def get_tag_url ( self , tag : str = \"\" ) -> str : # noqa: D102,WPS615 return self . tag_url . format ( base_url = self . url , namespace = self . namespace , project = self . project , ref = tag ) def get_compare_url ( self , base : str , target : str ) -> str : # noqa: D102 (use parent docstring) return self . build_ref_url ( \"commits_ranges\" , { \"ref\" : f \" { base } ... { target } \" })","title":"GitLab"},{"location":"reference/git_changelog/providers/#git_changelog.providers.GitLab.__init__","text":"Initialization method. Parameters: Name Type Description Default namespace str The GitLab namespace. required project str The GitLab project. required url str The GitLab URL. url Source code in git_changelog/providers.py 276 277 278 279 280 281 282 283 284 285 286 287 def __init__ ( self , namespace : str , project : str , url : str = url ): \"\"\" Initialization method. Arguments: namespace: The GitLab namespace. project: The GitLab project. url: The GitLab URL. \"\"\" self . namespace : str = namespace self . project : str = project self . url : str = url # noqa: WPS601 (shadowing but uses class' as default)","title":"__init__()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser","text":"Bases: ABC A base class for specific providers reference parsers. Source code in git_changelog/providers.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class ProviderRefParser ( ABC ): \"\"\"A base class for specific providers reference parsers.\"\"\" url : str namespace : str project : str REF : Dict [ str , RefDef ] = {} def get_refs ( self , ref_type : str , text : str ) -> List [ Ref ]: \"\"\" Find all references in the given text. Arguments: ref_type: The reference type. text: The text in which to search references. Returns: A list of references (instances of [Ref][git_changelog.providers.Ref]). \"\"\" return [ Ref ( ref = match . group () . strip (), url = self . build_ref_url ( ref_type , match . groupdict ())) for match in self . parse_refs ( ref_type , text ) ] def parse_refs ( self , ref_type : str , text : str ) -> List [ Match ]: \"\"\" Parse references in the given text. Arguments: ref_type: The reference type. text: The text to parse. Returns: A list of regular expressions matches. \"\"\" if ref_type not in self . REF : refs = [ key for key in self . REF . keys () if key . startswith ( ref_type )] return [ match for ref in refs for match in self . REF [ ref ] . regex . finditer ( text )] return list ( self . REF [ ref_type ] . regex . finditer ( text )) def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : \"\"\" Build the URL for a reference type and a dictionary of matched groups. Arguments: ref_type: The reference type. match_dict: The matched groups. Returns: The built URL. \"\"\" return self . REF [ ref_type ] . url_string . format ( ** match_dict ) @abstractmethod def get_tag_url ( self , tag : str ) -> str : \"\"\" Get the URL for a git tag. Arguments: tag: The git tag. Returns: The tag URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError @abstractmethod def get_compare_url ( self , base : str , target : str ) -> str : \"\"\" Get the URL for a tag comparison. Arguments: base: The base tag. target: The target tag. Returns: The comparison URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"ProviderRefParser"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.build_ref_url","text":"Build the URL for a reference type and a dictionary of matched groups. Parameters: Name Type Description Default ref_type str The reference type. required match_dict Dict [ str , str ] The matched groups. required Returns: Type Description str The built URL. Source code in git_changelog/providers.py 95 96 97 98 99 100 101 102 103 104 105 106 def build_ref_url ( self , ref_type : str , match_dict : Dict [ str , str ]) -> str : \"\"\" Build the URL for a reference type and a dictionary of matched groups. Arguments: ref_type: The reference type. match_dict: The matched groups. Returns: The built URL. \"\"\" return self . REF [ ref_type ] . url_string . format ( ** match_dict )","title":"build_ref_url()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_compare_url","text":"Get the URL for a tag comparison. Parameters: Name Type Description Default base str The base tag. required target str The target tag. required Returns: Type Description str The comparison URL. Source code in git_changelog/providers.py 121 122 123 124 125 126 127 128 129 130 131 132 133 @abstractmethod def get_compare_url ( self , base : str , target : str ) -> str : \"\"\" Get the URL for a tag comparison. Arguments: base: The base tag. target: The target tag. Returns: The comparison URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"get_compare_url()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_refs","text":"Find all references in the given text. Parameters: Name Type Description Default ref_type str The reference type. required text str The text in which to search references. required Returns: Type Description List [ Ref ] A list of references (instances of Ref ). Source code in git_changelog/providers.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def get_refs ( self , ref_type : str , text : str ) -> List [ Ref ]: \"\"\" Find all references in the given text. Arguments: ref_type: The reference type. text: The text in which to search references. Returns: A list of references (instances of [Ref][git_changelog.providers.Ref]). \"\"\" return [ Ref ( ref = match . group () . strip (), url = self . build_ref_url ( ref_type , match . groupdict ())) for match in self . parse_refs ( ref_type , text ) ]","title":"get_refs()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.get_tag_url","text":"Get the URL for a git tag. Parameters: Name Type Description Default tag str The git tag. required Returns: Type Description str The tag URL. Source code in git_changelog/providers.py 108 109 110 111 112 113 114 115 116 117 118 119 @abstractmethod def get_tag_url ( self , tag : str ) -> str : \"\"\" Get the URL for a git tag. Arguments: tag: The git tag. Returns: The tag URL. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"get_tag_url()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.ProviderRefParser.parse_refs","text":"Parse references in the given text. Parameters: Name Type Description Default ref_type str The reference type. required text str The text to parse. required Returns: Type Description List [ Match ] A list of regular expressions matches. Source code in git_changelog/providers.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def parse_refs ( self , ref_type : str , text : str ) -> List [ Match ]: \"\"\" Parse references in the given text. Arguments: ref_type: The reference type. text: The text to parse. Returns: A list of regular expressions matches. \"\"\" if ref_type not in self . REF : refs = [ key for key in self . REF . keys () if key . startswith ( ref_type )] return [ match for ref in refs for match in self . REF [ ref ] . regex . finditer ( text )] return list ( self . REF [ ref_type ] . regex . finditer ( text ))","title":"parse_refs()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref","text":"A class to represent a reference and its URL. Source code in git_changelog/providers.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Ref : \"\"\"A class to represent a reference and its URL.\"\"\" def __init__ ( self , ref : str , url : str ) -> None : \"\"\" Initialization method. Arguments: ref: The reference text. url: The reference URL. \"\"\" self . ref : str = ref self . url : str = url def __str__ ( self ): return self . ref + \": \" + self . url","title":"Ref"},{"location":"reference/git_changelog/providers/#git_changelog.providers.Ref.__init__","text":"Initialization method. Parameters: Name Type Description Default ref str The reference text. required url str The reference URL. required Source code in git_changelog/providers.py 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , ref : str , url : str ) -> None : \"\"\" Initialization method. Arguments: ref: The reference text. url: The reference URL. \"\"\" self . ref : str = ref self . url : str = url","title":"__init__()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef","text":"A class to store a reference regular expression and URL building string. Source code in git_changelog/providers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 class RefDef : \"\"\"A class to store a reference regular expression and URL building string.\"\"\" def __init__ ( self , regex : Pattern , url_string : str ): \"\"\" Initialization method. Arguments: regex: The regular expression to match the reference. url_string: The URL string to format using matched groups. \"\"\" self . regex = regex self . url_string = url_string","title":"RefDef"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefDef.__init__","text":"Initialization method. Parameters: Name Type Description Default regex Pattern The regular expression to match the reference. required url_string str The URL string to format using matched groups. required Source code in git_changelog/providers.py 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , regex : Pattern , url_string : str ): \"\"\" Initialization method. Arguments: regex: The regular expression to match the reference. url_string: The URL string to format using matched groups. \"\"\" self . regex = regex self . url_string = url_string","title":"__init__()"},{"location":"reference/git_changelog/providers/#git_changelog.providers.RefRe","text":"An enum helper to store parts of regular expressions for references. Source code in git_changelog/providers.py 8 9 10 11 12 13 14 15 16 17 18 19 class RefRe : \"\"\"An enum helper to store parts of regular expressions for references.\"\"\" BB = r \"(?:^|[\\s,])\" # blank before BA = r \"(?:[\\s,]|$)\" # blank after NP = r \"(?:(?P<namespace>[-\\w]+)/)?(?P<project>[-\\w]+)\" # namespace and project ID = r \" {symbol} (?P<ref>[1-9]\\d*)\" ONE_WORD = r \" {symbol} (?P<ref>\\w*[-a-z_ ][-\\w]*)\" MULTI_WORD = r ' {symbol} (?P<ref>\"\\w[- \\w]*\")' COMMIT = r \"(?P<ref>[0-9a-f]{{ {min} , {max} }})\" COMMIT_RANGE = r \"(?P<ref>[0-9a-f]{{ {min} , {max} }}\\.\\.\\.[0-9a-f]{{ {min} , {max} }})\" MENTION = r \"@(?P<ref>\\w[-\\w]*)\"","title":"RefRe"},{"location":"reference/git_changelog/templates/","text":"The subpackage containing the builtin templates. get_custom_template ( path ) \u00a4 Get a custom templates' path. Parameters: Name Type Description Default path str Path to the directory containing templates. required Returns: Type Description Template The Jinja template. Source code in git_changelog/templates/__init__.py 29 30 31 32 33 34 35 36 37 38 def get_custom_template ( path : str ) -> Template : \"\"\"Get a custom templates' path. Arguments: path: Path to the directory containing templates. Returns: The Jinja template. \"\"\" return get_env ( os . path . abspath ( path )) . get_template ( \"changelog.md\" ) get_env ( path ) \u00a4 Get the Jinja environment. Parameters: Name Type Description Default path str The path to give to the Jinja file system loader. required Returns: Type Description Environment The Jinja environment. Source code in git_changelog/templates/__init__.py 17 18 19 20 21 22 23 24 25 26 def get_env ( path : str ) -> Environment : \"\"\"Get the Jinja environment. Arguments: path: The path to give to the Jinja file system loader. Returns: The Jinja environment. \"\"\" return Environment ( loader = FileSystemLoader ( path )) # noqa: S701 (we are OK with not auto-escaping) get_path () \u00a4 Get the path to the templates directory. Returns: Type Description str The path to the templates directory. Source code in git_changelog/templates/__init__.py 8 9 10 11 12 13 14 def get_path () -> str : \"\"\"Get the path to the templates directory. Returns: The path to the templates directory. \"\"\" return os . path . dirname ( os . path . abspath ( __file__ )) get_template ( name ) \u00a4 Get a builtin template path. Parameters: Name Type Description Default name str The template name. required Returns: Type Description Template The Jinja template. Source code in git_changelog/templates/__init__.py 41 42 43 44 45 46 47 48 49 50 def get_template ( name : str ) -> Template : \"\"\"Get a builtin template path. Arguments: name: The template name. Returns: The Jinja template. \"\"\" return get_env ( os . path . join ( get_path (), name )) . get_template ( \"changelog.md\" )","title":"templates"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_custom_template","text":"Get a custom templates' path. Parameters: Name Type Description Default path str Path to the directory containing templates. required Returns: Type Description Template The Jinja template. Source code in git_changelog/templates/__init__.py 29 30 31 32 33 34 35 36 37 38 def get_custom_template ( path : str ) -> Template : \"\"\"Get a custom templates' path. Arguments: path: Path to the directory containing templates. Returns: The Jinja template. \"\"\" return get_env ( os . path . abspath ( path )) . get_template ( \"changelog.md\" )","title":"get_custom_template()"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_env","text":"Get the Jinja environment. Parameters: Name Type Description Default path str The path to give to the Jinja file system loader. required Returns: Type Description Environment The Jinja environment. Source code in git_changelog/templates/__init__.py 17 18 19 20 21 22 23 24 25 26 def get_env ( path : str ) -> Environment : \"\"\"Get the Jinja environment. Arguments: path: The path to give to the Jinja file system loader. Returns: The Jinja environment. \"\"\" return Environment ( loader = FileSystemLoader ( path )) # noqa: S701 (we are OK with not auto-escaping)","title":"get_env()"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_path","text":"Get the path to the templates directory. Returns: Type Description str The path to the templates directory. Source code in git_changelog/templates/__init__.py 8 9 10 11 12 13 14 def get_path () -> str : \"\"\"Get the path to the templates directory. Returns: The path to the templates directory. \"\"\" return os . path . dirname ( os . path . abspath ( __file__ ))","title":"get_path()"},{"location":"reference/git_changelog/templates/#git_changelog.templates.get_template","text":"Get a builtin template path. Parameters: Name Type Description Default name str The template name. required Returns: Type Description Template The Jinja template. Source code in git_changelog/templates/__init__.py 41 42 43 44 45 46 47 48 49 50 def get_template ( name : str ) -> Template : \"\"\"Get a builtin template path. Arguments: name: The template name. Returns: The Jinja template. \"\"\" return get_env ( os . path . join ( get_path (), name )) . get_template ( \"changelog.md\" )","title":"get_template()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}